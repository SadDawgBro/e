/*! For license information please see dist.min.js.LICENSE.txt */
(() => {
    var e;
    var t;
    var i = {
      971: e => {
        function t(e) {
          if (e) {
            return function (e) {
              for (var i in t.prototype) {
                e[i] = t.prototype[i];
              }
              return e;
            }(e);
          }
        }
        e.exports = t;
        t.prototype.on = t.prototype.addEventListener = function (e, t) {
          this._callbacks = this._callbacks || {};
          (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t);
          return this;
        };
        t.prototype.once = function (e, t) {
          function i() {
            this.off(e, i);
            t.apply(this, arguments);
          }
          i.fn = t;
          this.on(e, i);
          return this;
        };
        t.prototype.off = t.prototype.removeListener = t.prototype.removeAllListeners = t.prototype.removeEventListener = function (e, t) {
          this._callbacks = this._callbacks || {};
          if (arguments.length == 0) {
            this._callbacks = {};
            return this;
          }
          var i;
          var n = this._callbacks["$" + e];
          if (!n) {
            return this;
          }
          if (arguments.length == 1) {
            delete this._callbacks["$" + e];
            return this;
          }
          for (var a = 0; a < n.length; a++) {
            if ((i = n[a]) === t || i.fn === t) {
              n.splice(a, 1);
              break;
            }
          }
          if (n.length === 0) {
            delete this._callbacks["$" + e];
          }
          return this;
        };
        t.prototype.emit = function (e) {
          this._callbacks = this._callbacks || {};
          var t = new Array(arguments.length - 1);
          var i = this._callbacks["$" + e];
          for (var n = 1; n < arguments.length; n++) {
            t[n - 1] = arguments[n];
          }
          if (i) {
            n = 0;
            for (var a = (i = i.slice(0)).length; n < a; ++n) {
              i[n].apply(this, t);
            }
          }
          return this;
        };
        t.prototype.listeners = function (e) {
          this._callbacks = this._callbacks || {};
          return this._callbacks["$" + e] || [];
        };
        t.prototype.hasListeners = function (e) {
          return !!this.listeners(e).length;
        };
      },
      303: e => {
        "use strict";
  
        function t(e) {
          this._offset = 0;
          if (e instanceof ArrayBuffer) {
            this._buffer = e;
            this._view = new DataView(this._buffer);
          } else {
            if (!ArrayBuffer.isView(e)) {
              throw new Error("Invalid argument");
            }
            this._buffer = e.buffer;
            this._view = new DataView(this._buffer, e.byteOffset, e.byteLength);
          }
        }
        t.prototype._array = function (e) {
          var t = new Array(e);
          for (var i = 0; i < e; i++) {
            t[i] = this._parse();
          }
          return t;
        };
        t.prototype._map = function (e) {
          var t = {};
          for (var i = 0; i < e; i++) {
            t[this._parse()] = this._parse();
          }
          return t;
        };
        t.prototype._str = function (e) {
          var t = function (e, t, i) {
            var n = "";
            var a = 0;
            for (var r = t, s = t + i; r < s; r++) {
              var o = e.getUint8(r);
              if (o & 128) {
                if ((o & 224) != 192) {
                  if ((o & 240) != 224) {
                    if ((o & 248) != 240) {
                      throw new Error("Invalid byte " + o.toString(16));
                    }
                    if ((a = (o & 7) << 18 | (e.getUint8(++r) & 63) << 12 | (e.getUint8(++r) & 63) << 6 | e.getUint8(++r) & 63) >= 65536) {
                      a -= 65536;
                      n += String.fromCharCode(55296 + (a >>> 10), 56320 + (a & 1023));
                    } else {
                      n += String.fromCharCode(a);
                    }
                  } else {
                    n += String.fromCharCode((o & 15) << 12 | (e.getUint8(++r) & 63) << 6 | e.getUint8(++r) & 63);
                  }
                } else {
                  n += String.fromCharCode((o & 31) << 6 | e.getUint8(++r) & 63);
                }
              } else {
                n += String.fromCharCode(o);
              }
            }
            return n;
          }(this._view, this._offset, e);
          this._offset += e;
          return t;
        };
        t.prototype._bin = function (e) {
          var t = this._buffer.slice(this._offset, this._offset + e);
          this._offset += e;
          return t;
        };
        t.prototype._parse = function () {
          var e;
          var t = this._view.getUint8(this._offset++);
          var i = 0;
          var n = 0;
          var a = 0;
          var r = 0;
          if (t < 192) {
            if (t < 128) {
              return t;
            } else if (t < 144) {
              return this._map(t & 15);
            } else if (t < 160) {
              return this._array(t & 15);
            } else {
              return this._str(t & 31);
            }
          }
          if (t > 223) {
            return (255 - t + 1) * -1;
          }
          switch (t) {
            case 192:
              return null;
            case 194:
              return false;
            case 195:
              return true;
            case 196:
              i = this._view.getUint8(this._offset);
              this._offset += 1;
              return this._bin(i);
            case 197:
              i = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._bin(i);
            case 198:
              i = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._bin(i);
            case 199:
              i = this._view.getUint8(this._offset);
              n = this._view.getInt8(this._offset + 1);
              this._offset += 2;
              return [n, this._bin(i)];
            case 200:
              i = this._view.getUint16(this._offset);
              n = this._view.getInt8(this._offset + 2);
              this._offset += 3;
              return [n, this._bin(i)];
            case 201:
              i = this._view.getUint32(this._offset);
              n = this._view.getInt8(this._offset + 4);
              this._offset += 5;
              return [n, this._bin(i)];
            case 202:
              e = this._view.getFloat32(this._offset);
              this._offset += 4;
              return e;
            case 203:
              e = this._view.getFloat64(this._offset);
              this._offset += 8;
              return e;
            case 204:
              e = this._view.getUint8(this._offset);
              this._offset += 1;
              return e;
            case 205:
              e = this._view.getUint16(this._offset);
              this._offset += 2;
              return e;
            case 206:
              e = this._view.getUint32(this._offset);
              this._offset += 4;
              return e;
            case 207:
              a = this._view.getUint32(this._offset) * Math.pow(2, 32);
              r = this._view.getUint32(this._offset + 4);
              this._offset += 8;
              return a + r;
            case 208:
              e = this._view.getInt8(this._offset);
              this._offset += 1;
              return e;
            case 209:
              e = this._view.getInt16(this._offset);
              this._offset += 2;
              return e;
            case 210:
              e = this._view.getInt32(this._offset);
              this._offset += 4;
              return e;
            case 211:
              a = this._view.getInt32(this._offset) * Math.pow(2, 32);
              r = this._view.getUint32(this._offset + 4);
              this._offset += 8;
              return a + r;
            case 212:
              n = this._view.getInt8(this._offset);
              this._offset += 1;
              if (n === 0) {
                this._offset += 1;
                return;
              } else {
                return [n, this._bin(1)];
              }
            case 213:
              n = this._view.getInt8(this._offset);
              this._offset += 1;
              return [n, this._bin(2)];
            case 214:
              n = this._view.getInt8(this._offset);
              this._offset += 1;
              return [n, this._bin(4)];
            case 215:
              n = this._view.getInt8(this._offset);
              this._offset += 1;
              if (n === 0) {
                a = this._view.getInt32(this._offset) * Math.pow(2, 32);
                r = this._view.getUint32(this._offset + 4);
                this._offset += 8;
                return new Date(a + r);
              } else {
                return [n, this._bin(8)];
              }
            case 216:
              n = this._view.getInt8(this._offset);
              this._offset += 1;
              return [n, this._bin(16)];
            case 217:
              i = this._view.getUint8(this._offset);
              this._offset += 1;
              return this._str(i);
            case 218:
              i = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._str(i);
            case 219:
              i = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._str(i);
            case 220:
              i = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._array(i);
            case 221:
              i = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._array(i);
            case 222:
              i = this._view.getUint16(this._offset);
              this._offset += 2;
              return this._map(i);
            case 223:
              i = this._view.getUint32(this._offset);
              this._offset += 4;
              return this._map(i);
          }
          throw new Error("Could not parse");
        };
        e.exports = function (e) {
          var i = new t(e);
          var n = i._parse();
          if (i._offset !== e.byteLength) {
            throw new Error(e.byteLength - i._offset + " trailing bytes");
          }
          return n;
        };
      },
      523: e => {
        "use strict";
  
        function t(e, t, i) {
          var n = 0;
          for (var a = 0, r = i.length; a < r; a++) {
            if ((n = i.charCodeAt(a)) < 128) {
              e.setUint8(t++, n);
            } else if (n < 2048) {
              e.setUint8(t++, n >> 6 | 192);
              e.setUint8(t++, n & 63 | 128);
            } else if (n < 55296 || n >= 57344) {
              e.setUint8(t++, n >> 12 | 224);
              e.setUint8(t++, n >> 6 & 63 | 128);
              e.setUint8(t++, n & 63 | 128);
            } else {
              a++;
              n = 65536 + ((n & 1023) << 10 | i.charCodeAt(a) & 1023);
              e.setUint8(t++, n >> 18 | 240);
              e.setUint8(t++, n >> 12 & 63 | 128);
              e.setUint8(t++, n >> 6 & 63 | 128);
              e.setUint8(t++, n & 63 | 128);
            }
          }
        }
        function i(e, t, n) {
          var a = typeof n;
          var r = 0;
          var s = 0;
          var o = 0;
          var l = 0;
          var c = 0;
          var h = 0;
          if (a === "string") {
            c = function (e) {
              var t = 0;
              var i = 0;
              for (var n = 0, a = e.length; n < a; n++) {
                if ((t = e.charCodeAt(n)) < 128) {
                  i += 1;
                } else if (t < 2048) {
                  i += 2;
                } else if (t < 55296 || t >= 57344) {
                  i += 3;
                } else {
                  n++;
                  i += 4;
                }
              }
              return i;
            }(n);
            if (c < 32) {
              e.push(c | 160);
              h = 1;
            } else if (c < 256) {
              e.push(217, c);
              h = 2;
            } else if (c < 65536) {
              e.push(218, c >> 8, c);
              h = 3;
            } else {
              if (!(c < 4294967296)) {
                throw new Error("String too long");
              }
              e.push(219, c >> 24, c >> 16, c >> 8, c);
              h = 5;
            }
            t.push({
              _str: n,
              _length: c,
              _offset: e.length
            });
            return h + c;
          }
          if (a === "number") {
            if (Math.floor(n) === n && isFinite(n)) {
              if (n >= 0) {
                if (n < 128) {
                  e.push(n);
                  return 1;
                } else if (n < 256) {
                  e.push(204, n);
                  return 2;
                } else if (n < 65536) {
                  e.push(205, n >> 8, n);
                  return 3;
                } else if (n < 4294967296) {
                  e.push(206, n >> 24, n >> 16, n >> 8, n);
                  return 5;
                } else {
                  o = n / Math.pow(2, 32) | 0;
                  l = n >>> 0;
                  e.push(207, o >> 24, o >> 16, o >> 8, o, l >> 24, l >> 16, l >> 8, l);
                  return 9;
                }
              } else if (n >= -32) {
                e.push(n);
                return 1;
              } else if (n >= -128) {
                e.push(208, n);
                return 2;
              } else if (n >= -32768) {
                e.push(209, n >> 8, n);
                return 3;
              } else if (n >= -2147483648) {
                e.push(210, n >> 24, n >> 16, n >> 8, n);
                return 5;
              } else {
                o = Math.floor(n / Math.pow(2, 32));
                l = n >>> 0;
                e.push(211, o >> 24, o >> 16, o >> 8, o, l >> 24, l >> 16, l >> 8, l);
                return 9;
              }
            } else {
              e.push(203);
              t.push({
                _float: n,
                _length: 8,
                _offset: e.length
              });
              return 9;
            }
          }
          if (a === "object") {
            if (n === null) {
              e.push(192);
              return 1;
            }
            if (Array.isArray(n)) {
              if ((c = n.length) < 16) {
                e.push(c | 144);
                h = 1;
              } else if (c < 65536) {
                e.push(220, c >> 8, c);
                h = 3;
              } else {
                if (!(c < 4294967296)) {
                  throw new Error("Array too large");
                }
                e.push(221, c >> 24, c >> 16, c >> 8, c);
                h = 5;
              }
              for (r = 0; r < c; r++) {
                h += i(e, t, n[r]);
              }
              return h;
            }
            if (n instanceof Date) {
              var d = n.getTime();
              o = Math.floor(d / Math.pow(2, 32));
              l = d >>> 0;
              e.push(215, 0, o >> 24, o >> 16, o >> 8, o, l >> 24, l >> 16, l >> 8, l);
              return 10;
            }
            if (n instanceof ArrayBuffer) {
              if ((c = n.byteLength) < 256) {
                e.push(196, c);
                h = 2;
              } else if (c < 65536) {
                e.push(197, c >> 8, c);
                h = 3;
              } else {
                if (!(c < 4294967296)) {
                  throw new Error("Buffer too large");
                }
                e.push(198, c >> 24, c >> 16, c >> 8, c);
                h = 5;
              }
              t.push({
                _bin: n,
                _length: c,
                _offset: e.length
              });
              return h + c;
            }
            if (typeof n.toJSON == "function") {
              return i(e, t, n.toJSON());
            }
            var u = [];
            var p = "";
            var m = Object.keys(n);
            r = 0;
            s = m.length;
            for (; r < s; r++) {
              if (typeof n[p = m[r]] != "function") {
                u.push(p);
              }
            }
            if ((c = u.length) < 16) {
              e.push(c | 128);
              h = 1;
            } else if (c < 65536) {
              e.push(222, c >> 8, c);
              h = 3;
            } else {
              if (!(c < 4294967296)) {
                throw new Error("Object too large");
              }
              e.push(223, c >> 24, c >> 16, c >> 8, c);
              h = 5;
            }
            for (r = 0; r < c; r++) {
              h += i(e, t, p = u[r]);
              h += i(e, t, n[p]);
            }
            return h;
          }
          if (a === "boolean") {
            e.push(n ? 195 : 194);
            return 1;
          }
          if (a === "undefined") {
            e.push(212, 0, 0);
            return 3;
          }
          throw new Error("Could not encode");
        }
        e.exports = function (e) {
          var n = [];
          var a = [];
          var r = i(n, a, e);
          var s = new ArrayBuffer(r);
          var o = new DataView(s);
          var l = 0;
          var c = 0;
          var h = -1;
          if (a.length > 0) {
            h = a[0]._offset;
          }
          var d;
          var u = 0;
          var p = 0;
          for (var m = 0, f = n.length; m < f; m++) {
            o.setUint8(c + m, n[m]);
            if (m + 1 === h) {
              u = (d = a[l])._length;
              p = c + h;
              if (d._bin) {
                var g = new Uint8Array(d._bin);
                for (var _ = 0; _ < u; _++) {
                  o.setUint8(p + _, g[_]);
                }
              } else if (d._str) {
                t(o, p, d._str);
              } else if (d._float !== undefined) {
                o.setFloat64(p, d._float);
              }
              c += u;
              if (a[++l]) {
                h = a[l]._offset;
              }
            }
          }
          return s;
        };
      },
      602: (e, t, i) => {
        t.encode = i(523);
        t.decode = i(303);
      },
      129: (e, t, i) => {
        var n = i(602);
        var a = i(971);
        t.protocol = 5;
        var r = t.PacketType = {
          CONNECT: 0,
          DISCONNECT: 1,
          EVENT: 2,
          ACK: 3,
          CONNECT_ERROR: 4
        };
        var s = Number.isInteger || function (e) {
          return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
        };
        function o(e) {
          return typeof e == "string";
        }
        function l(e) {
          return Object.prototype.toString.call(e) === "[object Object]";
        }
        function c() {}
        function h() {}
        c.prototype.encode = function (e) {
          return [n.encode(e)];
        };
        a(h.prototype);
        h.prototype.add = function (e) {
          var t = n.decode(e);
          this.checkPacket(t);
          this.emit("decoded", t);
        };
        h.prototype.checkPacket = function (e) {
          if (!s(e.type) || !(e.type >= r.CONNECT) || !(e.type <= r.CONNECT_ERROR)) {
            throw new Error("invalid packet type");
          }
          if (!o(e.nsp)) {
            throw new Error("invalid namespace");
          }
          if (!function (e) {
            switch (e.type) {
              case r.CONNECT:
                return e.data === undefined || l(e.data);
              case r.DISCONNECT:
                return e.data === undefined;
              case r.CONNECT_ERROR:
                return o(e.data) || l(e.data);
              default:
                return Array.isArray(e.data);
            }
          }(e)) {
            throw new Error("invalid payload");
          }
          if (e.id !== undefined && !s(e.id)) {
            throw new Error("invalid packet id");
          }
        };
        h.prototype.destroy = function () {};
        t.Encoder = c;
        t.Decoder = h;
      },
      114: e => {
        window;
        e.exports = function (e) {
          var t = {};
          function i(n) {
            if (t[n]) {
              return t[n].exports;
            }
            var a = t[n] = {
              i: n,
              l: false,
              exports: {}
            };
            e[n].call(a.exports, a, a.exports, i);
            a.l = true;
            return a.exports;
          }
          i.m = e;
          i.c = t;
          i.d = function (e, t, n) {
            if (!i.o(e, t)) {
              Object.defineProperty(e, t, {
                enumerable: true,
                get: n
              });
            }
          };
          i.r = function (e) {
            if (typeof Symbol != "undefined" && Symbol.toStringTag) {
              Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
              });
            }
            Object.defineProperty(e, "__esModule", {
              value: true
            });
          };
          i.t = function (e, t) {
            if (t & 1) {
              e = i(e);
            }
            if (t & 8) {
              return e;
            }
            if (t & 4 && typeof e == "object" && e && e.__esModule) {
              return e;
            }
            var n = Object.create(null);
            i.r(n);
            Object.defineProperty(n, "default", {
              enumerable: true,
              value: e
            });
            if (t & 2 && typeof e != "string") {
              for (var a in e) {
                i.d(n, a, function (t) {
                  return e[t];
                }.bind(null, a));
              }
            }
            return n;
          };
          i.n = function (e) {
            var t = e && e.__esModule ? function () {
              return e.default;
            } : function () {
              return e;
            };
            i.d(t, "a", t);
            return t;
          };
          i.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          };
          i.p = "";
          return i(i.s = 7);
        }([function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          Number.isInteger = Number.isInteger || function (e) {
            return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
          };
          var n = function () {
            function e(t, i) {
              this.nodes = [];
              this.pseudoSelector = "";
              this.callbacks = {};
              i ||= document;
              if (typeof t == "string") {
                if (t[0] === "<" && t[t.length - 1] === ">") {
                  this.nodes = [e.createNode(t)];
                } else {
                  if (t.search(/(:before|:after)$/gi) !== -1) {
                    var n = t.match(/(:before|:after)$/gi);
                    t = t.split(n[0])[0];
                    this.pseudoSelector = n[0];
                  }
                  this.nodes = [].slice.call(i.querySelectorAll(t));
                }
              } else if (t instanceof NodeList) {
                this.nodes = t.length > 1 ? [].slice.call(t) : [t];
              } else if (t instanceof HTMLDocument || t instanceof Window || t instanceof HTMLElement) {
                this.nodes = [t];
              }
            }
            e.select = function (t, i) {
              return new e(t, i);
            };
            e.create = function (t) {
              return new e(e.createNode(t));
            };
            e.prototype.attr = function (e, t) {
              if (t != null) {
                this.each(this.nodes, function (i) {
                  i.setAttribute(e, t);
                });
                return this;
              } else {
                return this.getLastNode().getAttribute(e);
              }
            };
            e.prototype.append = function (t) {
              var i;
              i = t instanceof e ? t.get() : t;
              this.each(this.nodes, function (e) {
                e.appendChild(i);
              });
              return this;
            };
            e.prototype.parent = function () {
              return new e(this.getLastNode().parentNode);
            };
            e.prototype.each = function (e, t) {
              if (e instanceof Function) {
                t = e;
                e = this.nodes;
              }
              for (var i = 0; i < e.length; i++) {
                t.call(this.nodes[i], this.nodes[i], i);
              }
              return this;
            };
            e.prototype.hasClass = function (e) {
              return this.getLastNode().classList.contains(e);
            };
            e.prototype.addClass = function (e) {
              if (e) {
                var t = e.split(" ");
                this.each(this.nodes, function (e) {
                  for (var i in t) {
                    e.classList.add(t[i]);
                  }
                });
              }
              return this;
            };
            e.prototype.removeClass = function (e) {
              var t = e.split(" ");
              this.each(this.nodes, function (e) {
                for (var i in t) {
                  e.classList.remove(t[i]);
                }
              });
              return this;
            };
            e.prototype.find = function (t) {
              return new e(t, this.getLastNode());
            };
            e.prototype.trigger = function (e, t) {
              var i = new CustomEvent(e, {
                detail: t
              });
              this.each(this.nodes, function (e) {
                e.dispatchEvent(i);
              });
              return this;
            };
            e.prototype.text = function (e) {
              this.each(this.nodes, function (t) {
                t.innerText = e;
              });
              return this;
            };
            e.prototype.css = function (t, i) {
              if (i === undefined) {
                var n = this.getLastNode();
                var a = null;
                t = e.convertToJsProperty(t);
                if (typeof n.getBoundingClientRect == "function" && !this.pseudoSelector) {
                  a = n.getBoundingClientRect()[t];
                }
                if (!a) {
                  var r = getComputedStyle(n, this.pseudoSelector)[t];
                  if (r.search("px")) {
                    a = parseInt(r, 10);
                  }
                }
                if (isNaN(a)) {
                  throw "Undefined css property: " + t;
                }
                return a;
              }
              if (Number.isInteger(i)) {
                i += "px";
              }
              if (this.nodes.length > 1) {
                this.each(this.nodes, function (e) {
                  e.style[t] = i;
                });
              } else {
                this.nodes[0].style[t] = i;
              }
              return this;
            };
            e.prototype.on = function (e, t) {
              var i = this;
              this.each(this.nodes, function (n) {
                function a(e) {
                  t.call(n, e);
                }
                i.callbacks[e] = a;
                n.addEventListener(e, a);
              });
              return this;
            };
            e.prototype.off = function (e) {
              var t = this.callbacks[e];
              this.each(this.nodes, function (i) {
                i.removeEventListener(e, t, false);
              });
              return this;
            };
            e.prototype.val = function (e) {
              if (e === undefined) {
                return this.getLastNode().value;
              } else {
                this.each(this.nodes, function (t) {
                  t.value = e;
                });
                return this;
              }
            };
            e.prototype.is = function (e) {
              return this.getLastNode().tagName.toLowerCase() === e;
            };
            e.prototype.get = function (e = 0) {
              return this.nodes[e];
            };
            e.prototype.length = function () {
              return this.nodes.length;
            };
            e.prototype.hide = function () {
              this.each(this.nodes, function (t) {
                e.select(t).css("display", "none");
              });
              return this;
            };
            e.prototype.show = function () {
              this.each(this.nodes, function (t) {
                e.select(t).css("display", "");
              });
              return this;
            };
            e.prototype.empty = function () {
              this.each(this.nodes, function (t) {
                e.select(t).get().innerHTML = "";
              });
              return this;
            };
            e.prototype.html = function (e) {
              this.each(this.nodes, function (t) {
                t.innerHTML = e;
              });
            };
            e.prototype.remove = function () {
              this.each(this.nodes, function (e) {
                e.remove();
              });
            };
            e.prototype.insertBefore = function (e) {
              var t = this.resolveElement(e);
              this.each(this.nodes, function (e) {
                e.parentNode.insertBefore(t, t.previousSibling);
              });
              return this;
            };
            e.prototype.insertAfter = function (e) {
              var t = this.resolveElement(e);
              this.each(this.nodes, function (e) {
                e.parentNode.insertBefore(t, e.nextSibling);
              });
              return this;
            };
            e.prototype.resolveElement = function (t) {
              var i;
              if (e.isHtml(t)) {
                i = e.createNode(t);
              } else if (t instanceof HTMLElement) {
                i = t;
              } else if (t instanceof e) {
                i = t.get();
              }
              return i;
            };
            e.prototype.closest = function (t) {
              return e.select(this.getLastNode().closest(t));
            };
            e.prototype.data = function (e) {
              return this.attr("data-" + e);
            };
            e.prototype.width = function (e) {
              if (e !== undefined) {
                this.css("width", e);
                return this;
              } else if (this.getLastNode() === window) {
                return parseInt(this.getLastNode().innerWidth, 10);
              } else {
                return parseInt(this.css("width"), 10);
              }
            };
            e.prototype.height = function (e) {
              if (e !== undefined) {
                this.css("height", e);
                return this;
              } else if (this.getLastNode() === window) {
                return parseInt(this.getLastNode().innerHeight, 10);
              } else {
                return parseInt(this.css("height"), 10);
              }
            };
            e.prototype.position = function () {
              return {
                top: Number(this.getLastNode().getBoundingClientRect().top),
                bottom: Number(this.getLastNode().getBoundingClientRect().bottom),
                left: Number(this.getLastNode().getBoundingClientRect().left),
                right: Number(this.getLastNode().getBoundingClientRect().right)
              };
            };
            e.prototype.offset = function () {
              return {
                top: Number(this.getLastNode().offsetTop),
                left: Number(this.getLastNode().offsetLeft)
              };
            };
            e.createNode = function (e) {
              if (e[0] === "<" && e[e.length - 1] === ">") {
                var t = document.createElement("div");
                t.innerHTML = e;
                return t.firstChild;
              }
              return document.createElement(e);
            };
            e.isHtml = function (e) {
              return e[0] === "<" && e[e.length - 1] === ">";
            };
            e.convertToJsProperty = function (e) {
              return (e = (e = (e = e.toLowerCase().replace("-", " ")).replace(/(^| )(\w)/g, function (e) {
                return e.toUpperCase();
              })).charAt(0).toLowerCase() + e.slice(1)).replace(" ", "");
            };
            e.prototype.getLastNode = function () {
              return this.nodes[this.nodes.length - 1];
            };
            return e;
          }();
          t.default = n;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin + 305;
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                n.default.select(e).css("top", i).css("right", t.margin);
                i += n.default.select(e).height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "top-right";
            return e;
          }();
          t.TopRightPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin + 45;
              n.default.select(".growl-notification-center.position-" + e.position).each(function (e) {
                var a = n.default.select(e);
                a.css("top", i).css("left", "calc(50% - " + Math.ceil(a.width() / 2) + "px)");
                i += a.height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification-center.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "top-center";
            return e;
          }();
          t.TopCenterPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin;
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                var a = n.default.select(e);
                a.css("bottom", i).css("right", t.margin);
                i += a.height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "bottom-right";
            return e;
          }();
          t.BottomRightPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin;
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                var a = n.default.select(e);
                a.css("top", i).css("left", t.margin);
                i += a.height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "top-left";
            return e;
          }();
          t.TopLeftPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin;
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                var a = n.default.select(e);
                a.css("bottom", i).css("left", "calc(50% - " + Math.ceil(a.width() / 2) + "px)");
                i += a.height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "bottom-center";
            return e;
          }();
          t.BottomCenterPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(0);
          var a = function () {
            function e(e, t) {
              this.notification = e;
              this.margin = t;
            }
            e.prototype.calculate = function () {
              var t = this;
              var i = this.margin;
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                var a = n.default.select(e);
                a.css("bottom", i).css("left", t.margin);
                i += a.height() + t.margin;
              });
            };
            e.prototype.instances = function () {
              var t = [];
              n.default.select(".growl-notification.position-" + e.position).each(function (e) {
                t.push(n.default.select(e));
              });
              return t;
            };
            e.position = "bottom-left";
            return e;
          }();
          t.BottomLeftPosition = a;
        }, function (e, t, i) {
          "use strict";
  
          i(10);
          i(15);
          i(17);
          var n = i(8);
          var a = i(9);
          var r = i(0);
          var s = i(2);
          var o = i(1);
          var l = i(4);
          var c = i(5);
          var h = i(6);
          var d = i(3);
          var u = function () {
            function e(t = {}) {
              this.options = a.all([e.defaultOptions, e.globalOptions, t]);
              if (!this.options.animationClose || this.options.animationClose == "none") {
                this.options.animationDuration = 0;
              }
              this.notification = r.default.create("div");
              this.body = r.default.select("body");
              this.template = e.template;
              this.position = n.PositionFactory.newInstance(this.options.position, this.notification, this.options.margin);
              e.instances.push(this);
            }
            Object.defineProperty(e, "defaultOptions", {
              get: function () {
                return {
                  margin: 5,
                  type: "default",
                  title: "",
                  description: "",
                  imageVisible: false,
                  imageCustom: "",
                  closeTimeout: 0,
                  closeWith: ["click", "button"],
                  animationOpen: "slide-in",
                  animationClose: "slide-out",
                  animationDuration: 0.2,
                  position: "top-right",
                  showBorder: false,
                  showButtons: false,
                  buttons: {
                    action: {
                      text: "Ok",
                      callback: function () {}
                    },
                    cancel: {
                      text: "Cancel",
                      callback: function () {}
                    }
                  },
                  showProgress: false
                };
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(e, "template", {
              get: function () {
                return "<span class=\"growl-notification__close\">\n                  <span class=\"growl-notification__close-icon\"></span>\n                </span>\n                <div class=\"growl-notification__progress\">\n                    <div class=\"growl-notification__progress-bar\"></div>\n                </div>\n               <div class=\"growl-notification__body\">\n                 {{ image }}\n                 <div class=\"growl-notification__content\">\n                   <div class=\"growl-notification__title\">{{ title }}</div>\n                   <div class=\"growl-notification__desc\">{{ description }}</div>\n                 </div>\n                </div>\n                <div class=\"growl-notification__buttons\">\n                    <span class=\"growl-notification__button growl-notification__button--action\">Ok</span>\n                    <span class=\"growl-notification__button growl-notification__button--cancel\">Cancel</span>\n                </div>";
              },
              enumerable: true,
              configurable: true
            });
            e.notify = function (t = {}) {
              var i = new e(t).show();
              var n = 0;
              var a = [];
              i.position.instances().forEach(function (t) {
                if (e.hasOverflow(i, n)) {
                  a.push(t);
                  n += t.height() + i.options.margin;
                }
              });
              a.forEach(function (e) {
                e.remove();
              });
              i.position.calculate();
              return i;
            };
            e.hasOverflow = function (e, t = 0) {
              var i = false;
              var n = r.default.select(window).height();
              if (e.position instanceof s.TopCenterPosition || e.position instanceof o.TopRightPosition || e.position instanceof l.TopLeftPosition) {
                if (e.getContent().offset().top + e.getContent().height() + e.options.margin - t >= n) {
                  i = true;
                }
              } else if ((e.position instanceof c.BottomCenterPosition || e.position instanceof d.BottomRightPosition || e.position instanceof h.BottomLeftPosition) && e.getContent().offset().top + t <= 0) {
                i = true;
              }
              return i;
            };
            e.closeAll = function () {
              e.instances = [];
              r.default.select(e.position === "top-center" ? ".growl-notification-center" : ".growl-notification").each(function (e) {
                r.default.select(e).remove();
              });
            };
            e.prototype.show = function () {
              this.addNotification();
              this.initPosition();
              this.bindEvents();
              return this;
            };
            e.prototype.close = function () {
              var e = this;
              this.notification.removeClass("animation-" + this.options.animationOpen).addClass("animation-" + this.options.animationClose).addClass("growl-notification--closed");
              setTimeout(function () {
                e.remove();
                e.position.calculate();
              }, this.options.animationDuration * 1000);
            };
            e.prototype.remove = function () {
              var t = e.instances.indexOf(this);
              e.instances.splice(t, 1);
              this.notification.remove();
              return this;
            };
            e.prototype.getContent = function () {
              return this.notification;
            };
            e.prototype.addNotification = function () {
              var e = this.options;
              var t = this.template.replace("{{ title }}", e.title);
              t = t.replace("{{ description }}", e.description);
              t = this.options.imageVisible ? this.options.imageCustom ? t.replace("{{ image }}", "<div class=\"growl-notification__image growl-notification__image--custom\"><img src=\"" + this.options.imageCustom + "\" alt=\"\"></div>") : t.replace("{{ image }}", "<div class=\"growl-notification__image\"></div>") : t.replace("{{ image }}", "");
              this.notification.addClass(e.position === "top-center" ? "growl-notification-center" : "growl-notification").addClass("growl-notification--" + e.type).addClass("animation-" + e.animationOpen).addClass("position-" + e.position);
              if (e.image) {
                this.notification.addClass("growl-notification--image");
              }
              this.notification.html(t);
              if (!e.title) {
                this.notification.find(".growl-notification__title").remove();
              }
              if (e.width) {
                this.notification.width(e.width);
              }
              if (e.zIndex) {
                this.notification.css("z-index", e.zIndex);
              }
              if (e.showProgress && e.closeTimeout > 0) {
                this.notification.find(".growl-notification__progress").addClass("is-visible");
                this.notification.addClass("has-progress");
              }
              if (e.showButtons) {
                this.notification.find(".growl-notification__buttons").addClass("is-visible");
                this.notification.find(".growl-notification__button--action").text(e.buttons.action.text);
                this.notification.find(".growl-notification__button--cancel").text(e.buttons.cancel.text);
              }
              this.body.append(this.notification);
              if (e.showProgress && e.closeTimeout > 0) {
                this.calculateProgress();
              }
            };
            e.prototype.initPosition = function () {
              this.position.calculate();
            };
            e.prototype.calculateProgress = function () {
              var e = this;
              var t = Math.ceil(Number(this.options.closeTimeout) / 100);
              var i = 1;
              var n = setInterval(function () {
                if (i >= 100) {
                  clearInterval(n);
                } else {
                  e.notification.find(".growl-notification__progress-bar").css("width", i + "%");
                  i++;
                }
              }, t);
            };
            e.prototype.bindEvents = function () {
              var e = this;
              if (this.options.closeWith.indexOf("click") > -1) {
                this.notification.addClass("growl-notification--close-on-click").on("click", function () {
                  return e.close();
                });
              } else if (this.options.closeWith.indexOf("button") > -1) {
                this.notification.find(".growl-notification__close").on("click", function () {
                  return e.close();
                });
              }
              if (this.options.showButtons) {
                this.notification.find(".growl-notification__button--action").on("click", function (t) {
                  e.options.buttons.action.callback.apply(e);
                  e.close();
                  t.stopPropagation();
                });
                this.notification.find(".growl-notification__button--cancel").on("click", function (t) {
                  e.options.buttons.cancel.callback.apply(e);
                  e.close();
                  t.stopPropagation();
                });
              }
              if (this.options.closeTimeout && this.options.closeTimeout > 0) {
                setTimeout(function () {
                  return e.close();
                }, this.options.closeTimeout);
              }
            };
            e.setGlobalOptions = function (t) {
              e.globalOptions = t;
            };
            e.globalOptions = {};
            e.instances = [];
            return e;
          }();
          e.exports = u;
        }, function (e, t, i) {
          "use strict";
  
          Object.defineProperty(t, "__esModule", {
            value: true
          });
          var n = i(1);
          var a = i(2);
          var r = i(3);
          var s = i(4);
          var o = i(5);
          var l = i(6);
          var c = function () {
            function e() {}
            e.newInstance = function (e, t, i) {
              var c = null;
              if (e === n.TopRightPosition.position) {
                c = n.TopRightPosition;
              } else if (e === a.TopCenterPosition.position) {
                c = a.TopCenterPosition;
              } else if (e === r.BottomRightPosition.position) {
                c = r.BottomRightPosition;
              } else if (e === s.TopLeftPosition.position) {
                c = s.TopLeftPosition;
              } else if (e === o.BottomCenterPosition.position) {
                c = o.BottomCenterPosition;
              } else if (e === l.BottomLeftPosition.position) {
                c = l.BottomLeftPosition;
              }
              return new c(t, i);
            };
            return e;
          }();
          t.PositionFactory = c;
        }, function (e, t, i) {
          e.exports = function () {
            "use strict";
  
            function e(e) {
              return function (e) {
                return !!e && typeof e == "object";
              }(e) && !function (e) {
                var i = Object.prototype.toString.call(e);
                return i === "[object RegExp]" || i === "[object Date]" || function (e) {
                  return e.$$typeof === t;
                }(e);
              }(e);
            }
            var t = typeof Symbol == "function" && Symbol.for ? Symbol.for("react.element") : 60103;
            function i(e, t) {
              if (t.clone !== false && t.isMergeableObject(e)) {
                return a(function (e) {
                  if (Array.isArray(e)) {
                    return [];
                  } else {
                    return {};
                  }
                }(e), e, t);
              } else {
                return e;
              }
            }
            function n(e, t, n) {
              return e.concat(t).map(function (e) {
                return i(e, n);
              });
            }
            function a(t, r, s) {
              (s = s || {}).arrayMerge = s.arrayMerge || n;
              s.isMergeableObject = s.isMergeableObject || e;
              var o = Array.isArray(r);
              if (o === Array.isArray(t)) {
                if (o) {
                  return s.arrayMerge(t, r, s);
                } else {
                  return function (e, t, n) {
                    var r = {};
                    if (n.isMergeableObject(e)) {
                      Object.keys(e).forEach(function (t) {
                        r[t] = i(e[t], n);
                      });
                    }
                    Object.keys(t).forEach(function (s) {
                      if (n.isMergeableObject(t[s]) && e[s]) {
                        r[s] = a(e[s], t[s], n);
                      } else {
                        r[s] = i(t[s], n);
                      }
                    });
                    return r;
                  }(t, r, s);
                }
              } else {
                return i(r, s);
              }
            }
            a.all = function (e, t) {
              if (!Array.isArray(e)) {
                throw new Error("first argument should be an array");
              }
              return e.reduce(function (e, i) {
                return a(e, i, t);
              }, {});
            };
            return a;
          }();
        }, function (e, t) {},,,,, function (e, t) {},, function (e, t) {}]);
      }
    };
    var n = {};
    function a(e) {
      var t = n[e];
      if (t !== undefined) {
        return t.exports;
      }
      var r = n[e] = {
        exports: {}
      };
      i[e](r, r.exports, a);
      return r.exports;
    }
    t = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__;
    a.t = function (i, n) {
      if (n & 1) {
        i = this(i);
      }
      if (n & 8) {
        return i;
      }
      if (typeof i == "object" && i) {
        if (n & 4 && i.__esModule) {
          return i;
        }
        if (n & 16 && typeof i.then == "function") {
          return i;
        }
      }
      var r = Object.create(null);
      a.r(r);
      var s = {};
      e = e || [null, t({}), t([]), t(t)];
      for (var o = n & 2 && i; typeof o == "object" && !~e.indexOf(o); o = t(o)) {
        Object.getOwnPropertyNames(o).forEach(e => s[e] = () => i[e]);
      }
      s.default = () => i;
      a.d(r, s);
      return r;
    };
    a.d = (e, t) => {
      for (var i in t) {
        if (a.o(t, i) && !a.o(e, i)) {
          Object.defineProperty(e, i, {
            enumerable: true,
            get: t[i]
          });
        }
      }
    };
    a.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
    a.r = e => {
      if (typeof Symbol != "undefined" && Symbol.toStringTag) {
        Object.defineProperty(e, Symbol.toStringTag, {
          value: "Module"
        });
      }
      Object.defineProperty(e, "__esModule", {
        value: true
      });
    };
    (() => {
      "use strict";
  
      var e = {};
      a.r(e);
      a.d(e, {
        Decoder: () => Fl,
        Encoder: () => Ol,
        PacketType: () => Nl,
        protocol: () => zl
      });
      const t = "144";
      const i = 0;
      const n = 1;
      const r = 2;
      const s = 1;
      const o = 2;
      const l = 3;
      const c = 0;
      const h = 1;
      const d = 2;
      const u = 0;
      const p = 1;
      const m = 2;
      const f = 3;
      const g = 4;
      const _ = 5;
      const v = 100;
      const b = 101;
      const y = 102;
      const x = 103;
      const w = 104;
      const M = 200;
      const S = 201;
      const E = 202;
      const T = 203;
      const C = 204;
      const k = 205;
      const A = 206;
      const L = 207;
      const R = 208;
      const P = 209;
      const D = 210;
      const I = 0;
      const z = 1;
      const N = 2;
      const O = 3;
      const U = 4;
      const F = 5;
      const B = 6;
      const H = 7;
      const V = 0;
      const G = 1;
      const W = 2;
      const q = 0;
      const j = 1;
      const X = 2;
      const K = 3;
      const Y = 4;
      const J = 5;
      const Z = 301;
      const Q = 302;
      const ee = 303;
      const te = 304;
      const ie = 306;
      const ne = 1000;
      const ae = 1001;
      const re = 1002;
      const se = 1003;
      const oe = 1004;
      const le = 1005;
      const ce = 1006;
      const he = 1007;
      const de = 1008;
      const ue = 1009;
      const pe = 1010;
      const me = 1011;
      const fe = 1012;
      const ge = 1013;
      const _e = 1014;
      const ve = 1015;
      const be = 1016;
      const ye = 1017;
      const xe = 1018;
      const we = 1020;
      const Me = 1021;
      const Se = 1022;
      const Ee = 1023;
      const Te = 1024;
      const Ce = 1025;
      const ke = 1026;
      const Ae = 1027;
      const Le = 1028;
      const Re = 1029;
      const Pe = 1030;
      const De = 1031;
      const Ie = 1033;
      const $e = 33776;
      const ze = 33777;
      const Ne = 33778;
      const Oe = 33779;
      const Ue = 35840;
      const Fe = 35841;
      const Be = 35842;
      const He = 35843;
      const Ve = 36196;
      const Ge = 37492;
      const We = 37496;
      const qe = 37808;
      const je = 37809;
      const Xe = 37810;
      const Ke = 37811;
      const Ye = 37812;
      const Je = 37813;
      const Ze = 37814;
      const Qe = 37815;
      const et = 37816;
      const tt = 37817;
      const it = 37818;
      const nt = 37819;
      const at = 37820;
      const rt = 37821;
      const st = 36492;
      const ot = 2300;
      const lt = 2301;
      const ct = 2302;
      const ht = 3000;
      const dt = 3001;
      const ut = 3201;
      const pt = 0;
      const mt = 1;
      const ft = "srgb";
      const gt = "srgb-linear";
      const _t = 7680;
      const vt = "300 es";
      const bt = 1035;
      class yt {
        addEventListener(e, t) {
          if (this._listeners === undefined) {
            this._listeners = {};
          }
          const i = this._listeners;
          if (i[e] === undefined) {
            i[e] = [];
          }
          if (i[e].indexOf(t) === -1) {
            i[e].push(t);
          }
        }
        hasEventListener(e, t) {
          if (this._listeners === undefined) {
            return false;
          }
          const i = this._listeners;
          return i[e] !== undefined && i[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          if (this._listeners === undefined) {
            return;
          }
          const i = this._listeners[e];
          if (i !== undefined) {
            const e = i.indexOf(t);
            if (e !== -1) {
              i.splice(e, 1);
            }
          }
        }
        dispatchEvent(e) {
          if (this._listeners === undefined) {
            return;
          }
          const t = this._listeners[e.type];
          if (t !== undefined) {
            e.target = this;
            const i = t.slice(0);
            for (let t = 0, n = i.length; t < n; t++) {
              i[t].call(this, e);
            }
            e.target = null;
          }
        }
      }
      const xt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
      const wt = Math.PI / 180;
      const Mt = 180 / Math.PI;
      function St() {
        const e = Math.random() * 4294967295 | 0;
        const t = Math.random() * 4294967295 | 0;
        const i = Math.random() * 4294967295 | 0;
        const n = Math.random() * 4294967295 | 0;
        return (xt[e & 255] + xt[e >> 8 & 255] + xt[e >> 16 & 255] + xt[e >> 24 & 255] + "-" + xt[t & 255] + xt[t >> 8 & 255] + "-" + xt[t >> 16 & 15 | 64] + xt[t >> 24 & 255] + "-" + xt[i & 63 | 128] + xt[i >> 8 & 255] + "-" + xt[i >> 16 & 255] + xt[i >> 24 & 255] + xt[n & 255] + xt[n >> 8 & 255] + xt[n >> 16 & 255] + xt[n >> 24 & 255]).toLowerCase();
      }
      function Et(e, t, i) {
        return Math.max(t, Math.min(i, e));
      }
      function Tt(e, t, i) {
        return (1 - i) * e + i * t;
      }
      function Ct(e) {
        return !(e & e - 1) && e !== 0;
      }
      function kt(e) {
        return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
      }
      function At(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function Lt(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint16Array:
            return Math.round(e * 65535);
          case Uint8Array:
            return Math.round(e * 255);
          case Int16Array:
            return Math.round(e * 32767);
          case Int8Array:
            return Math.round(e * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      class Rt {
        constructor(e = 0, t = 0) {
          Rt.prototype.isVector2 = true;
          this.x = e;
          this.y = t;
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          this.x = e;
          this.y = t;
          return this;
        }
        setScalar(e) {
          this.x = e;
          this.y = e;
          return this;
        }
        setX(e) {
          this.x = e;
          return this;
        }
        setY(e) {
          this.y = e;
          return this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          this.x = e.x;
          this.y = e.y;
          return this;
        }
        add(e) {
          this.x += e.x;
          this.y += e.y;
          return this;
        }
        addScalar(e) {
          this.x += e;
          this.y += e;
          return this;
        }
        addVectors(e, t) {
          this.x = e.x + t.x;
          this.y = e.y + t.y;
          return this;
        }
        addScaledVector(e, t) {
          this.x += e.x * t;
          this.y += e.y * t;
          return this;
        }
        sub(e) {
          this.x -= e.x;
          this.y -= e.y;
          return this;
        }
        subScalar(e) {
          this.x -= e;
          this.y -= e;
          return this;
        }
        subVectors(e, t) {
          this.x = e.x - t.x;
          this.y = e.y - t.y;
          return this;
        }
        multiply(e) {
          this.x *= e.x;
          this.y *= e.y;
          return this;
        }
        multiplyScalar(e) {
          this.x *= e;
          this.y *= e;
          return this;
        }
        divide(e) {
          this.x /= e.x;
          this.y /= e.y;
          return this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x;
          const i = this.y;
          const n = e.elements;
          this.x = n[0] * t + n[3] * i + n[6];
          this.y = n[1] * t + n[4] * i + n[7];
          return this;
        }
        min(e) {
          this.x = Math.min(this.x, e.x);
          this.y = Math.min(this.y, e.y);
          return this;
        }
        max(e) {
          this.x = Math.max(this.x, e.x);
          this.y = Math.max(this.y, e.y);
          return this;
        }
        clamp(e, t) {
          this.x = Math.max(e.x, Math.min(t.x, this.x));
          this.y = Math.max(e.y, Math.min(t.y, this.y));
          return this;
        }
        clampScalar(e, t) {
          this.x = Math.max(e, Math.min(t, this.x));
          this.y = Math.max(e, Math.min(t, this.y));
          return this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          return this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x;
          const i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          this.x += (e.x - this.x) * t;
          this.y += (e.y - this.y) * t;
          return this;
        }
        lerpVectors(e, t, i) {
          this.x = e.x + (t.x - e.x) * i;
          this.y = e.y + (t.y - e.y) * i;
          return this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          this.x = e[t];
          this.y = e[t + 1];
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this.x;
          e[t + 1] = this.y;
          return e;
        }
        fromBufferAttribute(e, t) {
          this.x = e.getX(t);
          this.y = e.getY(t);
          return this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t);
          const n = Math.sin(t);
          const a = this.x - e.x;
          const r = this.y - e.y;
          this.x = a * i - r * n + e.x;
          this.y = a * n + r * i + e.y;
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
        }
      }
      class Pt {
        constructor() {
          Pt.prototype.isMatrix3 = true;
          this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        }
        set(e, t, i, n, a, r, s, o, l) {
          const c = this.elements;
          c[0] = e;
          c[1] = n;
          c[2] = s;
          c[3] = t;
          c[4] = a;
          c[5] = o;
          c[6] = i;
          c[7] = r;
          c[8] = l;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
          return this;
        }
        copy(e) {
          const t = this.elements;
          const i = e.elements;
          t[0] = i[0];
          t[1] = i[1];
          t[2] = i[2];
          t[3] = i[3];
          t[4] = i[4];
          t[5] = i[5];
          t[6] = i[6];
          t[7] = i[7];
          t[8] = i[8];
          return this;
        }
        extractBasis(e, t, i) {
          e.setFromMatrix3Column(this, 0);
          t.setFromMatrix3Column(this, 1);
          i.setFromMatrix3Column(this, 2);
          return this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]);
          return this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements;
          const n = t.elements;
          const a = this.elements;
          const r = i[0];
          const s = i[3];
          const o = i[6];
          const l = i[1];
          const c = i[4];
          const h = i[7];
          const d = i[2];
          const u = i[5];
          const p = i[8];
          const m = n[0];
          const f = n[3];
          const g = n[6];
          const _ = n[1];
          const v = n[4];
          const b = n[7];
          const y = n[2];
          const x = n[5];
          const w = n[8];
          a[0] = r * m + s * _ + o * y;
          a[3] = r * f + s * v + o * x;
          a[6] = r * g + s * b + o * w;
          a[1] = l * m + c * _ + h * y;
          a[4] = l * f + c * v + h * x;
          a[7] = l * g + c * b + h * w;
          a[2] = d * m + u * _ + p * y;
          a[5] = d * f + u * v + p * x;
          a[8] = d * g + u * b + p * w;
          return this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          t[0] *= e;
          t[3] *= e;
          t[6] *= e;
          t[1] *= e;
          t[4] *= e;
          t[7] *= e;
          t[2] *= e;
          t[5] *= e;
          t[8] *= e;
          return this;
        }
        determinant() {
          const e = this.elements;
          const t = e[0];
          const i = e[1];
          const n = e[2];
          const a = e[3];
          const r = e[4];
          const s = e[5];
          const o = e[6];
          const l = e[7];
          const c = e[8];
          return t * r * c - t * s * l - i * a * c + i * s * o + n * a * l - n * r * o;
        }
        invert() {
          const e = this.elements;
          const t = e[0];
          const i = e[1];
          const n = e[2];
          const a = e[3];
          const r = e[4];
          const s = e[5];
          const o = e[6];
          const l = e[7];
          const c = e[8];
          const h = c * r - s * l;
          const d = s * o - c * a;
          const u = l * a - r * o;
          const p = t * h + i * d + n * u;
          if (p === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
          const m = 1 / p;
          e[0] = h * m;
          e[1] = (n * l - c * i) * m;
          e[2] = (s * i - n * r) * m;
          e[3] = d * m;
          e[4] = (c * t - n * o) * m;
          e[5] = (n * a - s * t) * m;
          e[6] = u * m;
          e[7] = (i * o - l * t) * m;
          e[8] = (r * t - i * a) * m;
          return this;
        }
        transpose() {
          let e;
          const t = this.elements;
          e = t[1];
          t[1] = t[3];
          t[3] = e;
          e = t[2];
          t[2] = t[6];
          t[6] = e;
          e = t[5];
          t[5] = t[7];
          t[7] = e;
          return this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          e[0] = t[0];
          e[1] = t[3];
          e[2] = t[6];
          e[3] = t[1];
          e[4] = t[4];
          e[5] = t[7];
          e[6] = t[2];
          e[7] = t[5];
          e[8] = t[8];
          return this;
        }
        setUvTransform(e, t, i, n, a, r, s) {
          const o = Math.cos(a);
          const l = Math.sin(a);
          this.set(i * o, i * l, -i * (o * r + l * s) + r + e, -n * l, n * o, -n * (-l * r + o * s) + s + t, 0, 0, 1);
          return this;
        }
        scale(e, t) {
          const i = this.elements;
          i[0] *= e;
          i[3] *= e;
          i[6] *= e;
          i[1] *= t;
          i[4] *= t;
          i[7] *= t;
          return this;
        }
        rotate(e) {
          const t = Math.cos(e);
          const i = Math.sin(e);
          const n = this.elements;
          const a = n[0];
          const r = n[3];
          const s = n[6];
          const o = n[1];
          const l = n[4];
          const c = n[7];
          n[0] = t * a + i * o;
          n[3] = t * r + i * l;
          n[6] = t * s + i * c;
          n[1] = -i * a + t * o;
          n[4] = -i * r + t * l;
          n[7] = -i * s + t * c;
          return this;
        }
        translate(e, t) {
          const i = this.elements;
          i[0] += e * i[2];
          i[3] += e * i[5];
          i[6] += e * i[8];
          i[1] += t * i[2];
          i[4] += t * i[5];
          i[7] += t * i[8];
          return this;
        }
        equals(e) {
          const t = this.elements;
          const i = e.elements;
          for (let e = 0; e < 9; e++) {
            if (t[e] !== i[e]) {
              return false;
            }
          }
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) {
            this.elements[i] = e[i + t];
          }
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          e[t] = i[0];
          e[t + 1] = i[1];
          e[t + 2] = i[2];
          e[t + 3] = i[3];
          e[t + 4] = i[4];
          e[t + 5] = i[5];
          e[t + 6] = i[6];
          e[t + 7] = i[7];
          e[t + 8] = i[8];
          return e;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      function Dt(e) {
        for (let t = e.length - 1; t >= 0; --t) {
          if (e[t] >= 65535) {
            return true;
          }
        }
        return false;
      }
      function It(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function $t(e) {
        if (e < 0.04045) {
          return e * 0.0773993808;
        } else {
          return Math.pow(e * 0.9478672986 + 0.0521327014, 2.4);
        }
      }
      function zt(e) {
        if (e < 0.0031308) {
          return e * 12.92;
        } else {
          return Math.pow(e, 0.41666) * 1.055 - 0.055;
        }
      }
      Int8Array;
      Uint8Array;
      Uint8ClampedArray;
      Int16Array;
      Uint16Array;
      Int32Array;
      Uint32Array;
      Float32Array;
      Float64Array;
      const Nt = {
        [ft]: {
          [gt]: $t
        },
        [gt]: {
          [ft]: zt
        }
      };
      const Ot = {
        legacyMode: true,
        get workingColorSpace() {
          return gt;
        },
        set workingColorSpace(e) {
          console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
        },
        convert: function (e, t, i) {
          if (this.legacyMode || t === i || !t || !i) {
            return e;
          }
          if (Nt[t] && Nt[t][i] !== undefined) {
            const n = Nt[t][i];
            e.r = n(e.r);
            e.g = n(e.g);
            e.b = n(e.b);
            return e;
          }
          throw new Error("Unsupported color space conversion.");
        },
        fromWorkingColorSpace: function (e, t) {
          return this.convert(e, this.workingColorSpace, t);
        },
        toWorkingColorSpace: function (e, t) {
          return this.convert(e, t, this.workingColorSpace);
        }
      };
      const Ut = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      };
      const Ft = {
        r: 0,
        g: 0,
        b: 0
      };
      const Bt = {
        h: 0,
        s: 0,
        l: 0
      };
      const Ht = {
        h: 0,
        s: 0,
        l: 0
      };
      function Vt(e, t, i) {
        if (i < 0) {
          i += 1;
        }
        if (i > 1) {
          i -= 1;
        }
        if (i < 1 / 6) {
          return e + (t - e) * 6 * i;
        } else if (i < 0.5) {
          return t;
        } else if (i < 2 / 3) {
          return e + (t - e) * 6 * (2 / 3 - i);
        } else {
          return e;
        }
      }
      function Gt(e, t) {
        t.r = e.r;
        t.g = e.g;
        t.b = e.b;
        return t;
      }
      class Wt {
        constructor(e, t, i) {
          this.isColor = true;
          this.r = 1;
          this.g = 1;
          this.b = 1;
          if (t === undefined && i === undefined) {
            return this.set(e);
          } else {
            return this.setRGB(e, t, i);
          }
        }
        set(e) {
          if (e && e.isColor) {
            this.copy(e);
          } else if (typeof e == "number") {
            this.setHex(e);
          } else if (typeof e == "string") {
            this.setStyle(e);
          }
          return this;
        }
        setScalar(e) {
          this.r = e;
          this.g = e;
          this.b = e;
          return this;
        }
        setHex(e, t = ft) {
          e = Math.floor(e);
          this.r = (e >> 16 & 255) / 255;
          this.g = (e >> 8 & 255) / 255;
          this.b = (e & 255) / 255;
          Ot.toWorkingColorSpace(this, t);
          return this;
        }
        setRGB(e, t, i, n = gt) {
          this.r = e;
          this.g = t;
          this.b = i;
          Ot.toWorkingColorSpace(this, n);
          return this;
        }
        setHSL(e, t, i, n = gt) {
          e = (e % (a = 1) + a) % a;
          t = Et(t, 0, 1);
          i = Et(i, 0, 1);
          if (t === 0) {
            this.r = this.g = this.b = i;
          } else {
            const n = i <= 0.5 ? i * (1 + t) : i + t - i * t;
            const a = i * 2 - n;
            this.r = Vt(a, n, e + 1 / 3);
            this.g = Vt(a, n, e);
            this.b = Vt(a, n, e - 1 / 3);
          }
          var a;
          Ot.toWorkingColorSpace(this, n);
          return this;
        }
        setStyle(e, t = ft) {
          function i(t) {
            if (t !== undefined && parseFloat(t) < 1) {
              console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
            }
          }
          let n;
          if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
            let e;
            const a = n[1];
            const r = n[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                  this.r = Math.min(255, parseInt(e[1], 10)) / 255;
                  this.g = Math.min(255, parseInt(e[2], 10)) / 255;
                  this.b = Math.min(255, parseInt(e[3], 10)) / 255;
                  Ot.toWorkingColorSpace(this, t);
                  i(e[4]);
                  return this;
                }
                if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                  this.r = Math.min(100, parseInt(e[1], 10)) / 100;
                  this.g = Math.min(100, parseInt(e[2], 10)) / 100;
                  this.b = Math.min(100, parseInt(e[3], 10)) / 100;
                  Ot.toWorkingColorSpace(this, t);
                  i(e[4]);
                  return this;
                }
                break;
              case "hsl":
              case "hsla":
                if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                  const n = parseFloat(e[1]) / 360;
                  const a = parseFloat(e[2]) / 100;
                  const r = parseFloat(e[3]) / 100;
                  i(e[4]);
                  return this.setHSL(n, a, r, t);
                }
            }
          } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const e = n[1];
            const i = e.length;
            if (i === 3) {
              this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255;
              this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255;
              this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255;
              Ot.toWorkingColorSpace(this, t);
              return this;
            }
            if (i === 6) {
              this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255;
              this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255;
              this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255;
              Ot.toWorkingColorSpace(this, t);
              return this;
            }
          }
          if (e && e.length > 0) {
            return this.setColorName(e, t);
          } else {
            return this;
          }
        }
        setColorName(e, t = ft) {
          const i = Ut[e.toLowerCase()];
          if (i !== undefined) {
            this.setHex(i, t);
          } else {
            console.warn("THREE.Color: Unknown color " + e);
          }
          return this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          this.r = e.r;
          this.g = e.g;
          this.b = e.b;
          return this;
        }
        copySRGBToLinear(e) {
          this.r = $t(e.r);
          this.g = $t(e.g);
          this.b = $t(e.b);
          return this;
        }
        copyLinearToSRGB(e) {
          this.r = zt(e.r);
          this.g = zt(e.g);
          this.b = zt(e.b);
          return this;
        }
        convertSRGBToLinear() {
          this.copySRGBToLinear(this);
          return this;
        }
        convertLinearToSRGB() {
          this.copyLinearToSRGB(this);
          return this;
        }
        getHex(e = ft) {
          Ot.fromWorkingColorSpace(Gt(this, Ft), e);
          return Et(Ft.r * 255, 0, 255) << 16 ^ Et(Ft.g * 255, 0, 255) << 8 ^ Et(Ft.b * 255, 0, 255);
        }
        getHexString(e = ft) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = gt) {
          Ot.fromWorkingColorSpace(Gt(this, Ft), t);
          const i = Ft.r;
          const n = Ft.g;
          const a = Ft.b;
          const r = Math.max(i, n, a);
          const s = Math.min(i, n, a);
          let o;
          let l;
          const c = (s + r) / 2;
          if (s === r) {
            o = 0;
            l = 0;
          } else {
            const e = r - s;
            l = c <= 0.5 ? e / (r + s) : e / (2 - r - s);
            switch (r) {
              case i:
                o = (n - a) / e + (n < a ? 6 : 0);
                break;
              case n:
                o = (a - i) / e + 2;
                break;
              case a:
                o = (i - n) / e + 4;
            }
            o /= 6;
          }
          e.h = o;
          e.s = l;
          e.l = c;
          return e;
        }
        getRGB(e, t = gt) {
          Ot.fromWorkingColorSpace(Gt(this, Ft), t);
          e.r = Ft.r;
          e.g = Ft.g;
          e.b = Ft.b;
          return e;
        }
        getStyle(e = ft) {
          Ot.fromWorkingColorSpace(Gt(this, Ft), e);
          if (e !== ft) {
            return `color(${e} ${Ft.r} ${Ft.g} ${Ft.b})`;
          } else {
            return `rgb(${Ft.r * 255 | 0},${Ft.g * 255 | 0},${Ft.b * 255 | 0})`;
          }
        }
        offsetHSL(e, t, i) {
          this.getHSL(Bt);
          Bt.h += e;
          Bt.s += t;
          Bt.l += i;
          this.setHSL(Bt.h, Bt.s, Bt.l);
          return this;
        }
        add(e) {
          this.r += e.r;
          this.g += e.g;
          this.b += e.b;
          return this;
        }
        addColors(e, t) {
          this.r = e.r + t.r;
          this.g = e.g + t.g;
          this.b = e.b + t.b;
          return this;
        }
        addScalar(e) {
          this.r += e;
          this.g += e;
          this.b += e;
          return this;
        }
        sub(e) {
          this.r = Math.max(0, this.r - e.r);
          this.g = Math.max(0, this.g - e.g);
          this.b = Math.max(0, this.b - e.b);
          return this;
        }
        multiply(e) {
          this.r *= e.r;
          this.g *= e.g;
          this.b *= e.b;
          return this;
        }
        multiplyScalar(e) {
          this.r *= e;
          this.g *= e;
          this.b *= e;
          return this;
        }
        lerp(e, t) {
          this.r += (e.r - this.r) * t;
          this.g += (e.g - this.g) * t;
          this.b += (e.b - this.b) * t;
          return this;
        }
        lerpColors(e, t, i) {
          this.r = e.r + (t.r - e.r) * i;
          this.g = e.g + (t.g - e.g) * i;
          this.b = e.b + (t.b - e.b) * i;
          return this;
        }
        lerpHSL(e, t) {
          this.getHSL(Bt);
          e.getHSL(Ht);
          const i = Tt(Bt.h, Ht.h, t);
          const n = Tt(Bt.s, Ht.s, t);
          const a = Tt(Bt.l, Ht.l, t);
          this.setHSL(i, n, a);
          return this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          this.r = e[t];
          this.g = e[t + 1];
          this.b = e[t + 2];
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this.r;
          e[t + 1] = this.g;
          e[t + 2] = this.b;
          return e;
        }
        fromBufferAttribute(e, t) {
          this.r = e.getX(t);
          this.g = e.getY(t);
          this.b = e.getZ(t);
          return this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r;
          yield this.g;
          yield this.b;
        }
      }
      let qt;
      Wt.NAMES = Ut;
      class jt {
        static getDataURL(e) {
          if (/^data:/i.test(e.src)) {
            return e.src;
          }
          if (typeof HTMLCanvasElement == "undefined") {
            return e.src;
          }
          let t;
          if (e instanceof HTMLCanvasElement) {
            t = e;
          } else {
            if (qt === undefined) {
              qt = It("canvas");
            }
            qt.width = e.width;
            qt.height = e.height;
            const i = qt.getContext("2d");
            if (e instanceof ImageData) {
              i.putImageData(e, 0, 0);
            } else {
              i.drawImage(e, 0, 0, e.width, e.height);
            }
            t = qt;
          }
          if (t.width > 2048 || t.height > 2048) {
            console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e);
            return t.toDataURL("image/jpeg", 0.6);
          } else {
            return t.toDataURL("image/png");
          }
        }
        static sRGBToLinear(e) {
          if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
            const t = It("canvas");
            t.width = e.width;
            t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const n = i.getImageData(0, 0, e.width, e.height);
            const a = n.data;
            for (let e = 0; e < a.length; e++) {
              a[e] = $t(a[e] / 255) * 255;
            }
            i.putImageData(n, 0, 0);
            return t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++) {
              if (t instanceof Uint8Array || t instanceof Uint8ClampedArray) {
                t[e] = Math.floor($t(t[e] / 255) * 255);
              } else {
                t[e] = $t(t[e]);
              }
            }
            return {
              data: t,
              width: e.width,
              height: e.height
            };
          }
          console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
          return e;
        }
      }
      class Xt {
        constructor(e = null) {
          this.isSource = true;
          this.uuid = St();
          this.data = e;
          this.version = 0;
        }
        set needsUpdate(e) {
          if (e === true) {
            this.version++;
          }
        }
        toJSON(e) {
          const t = e === undefined || typeof e == "string";
          if (!t && e.images[this.uuid] !== undefined) {
            return e.images[this.uuid];
          }
          const i = {
            uuid: this.uuid,
            url: ""
          };
          const n = this.data;
          if (n !== null) {
            let e;
            if (Array.isArray(n)) {
              e = [];
              for (let t = 0, i = n.length; t < i; t++) {
                if (n[t].isDataTexture) {
                  e.push(Kt(n[t].image));
                } else {
                  e.push(Kt(n[t]));
                }
              }
            } else {
              e = Kt(n);
            }
            i.url = e;
          }
          if (!t) {
            e.images[this.uuid] = i;
          }
          return i;
        }
      }
      function Kt(e) {
        if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
          return jt.getDataURL(e);
        } else if (e.data) {
          return {
            data: Array.from(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
          };
        } else {
          console.warn("THREE.Texture: Unable to serialize Texture.");
          return {};
        }
      }
      let Yt = 0;
      class Jt extends yt {
        constructor(e = Jt.DEFAULT_IMAGE, t = Jt.DEFAULT_MAPPING, i = ae, n = ae, a = ce, r = de, s = Ee, o = ue, l = 1, c = ht) {
          super();
          this.isTexture = true;
          Object.defineProperty(this, "id", {
            value: Yt++
          });
          this.uuid = St();
          this.name = "";
          this.source = new Xt(e);
          this.mipmaps = [];
          this.mapping = t;
          this.wrapS = i;
          this.wrapT = n;
          this.magFilter = a;
          this.minFilter = r;
          this.anisotropy = l;
          this.format = s;
          this.internalFormat = null;
          this.type = o;
          this.offset = new Rt(0, 0);
          this.repeat = new Rt(1, 1);
          this.center = new Rt(0, 0);
          this.rotation = 0;
          this.matrixAutoUpdate = true;
          this.matrix = new Pt();
          this.generateMipmaps = true;
          this.premultiplyAlpha = false;
          this.flipY = true;
          this.unpackAlignment = 4;
          this.encoding = c;
          this.userData = {};
          this.version = 0;
          this.onUpdate = null;
          this.isRenderTargetTexture = false;
          this.needsPMREMUpdate = false;
        }
        get image() {
          return this.source.data;
        }
        set image(e) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name;
          this.source = e.source;
          this.mipmaps = e.mipmaps.slice(0);
          this.mapping = e.mapping;
          this.wrapS = e.wrapS;
          this.wrapT = e.wrapT;
          this.magFilter = e.magFilter;
          this.minFilter = e.minFilter;
          this.anisotropy = e.anisotropy;
          this.format = e.format;
          this.internalFormat = e.internalFormat;
          this.type = e.type;
          this.offset.copy(e.offset);
          this.repeat.copy(e.repeat);
          this.center.copy(e.center);
          this.rotation = e.rotation;
          this.matrixAutoUpdate = e.matrixAutoUpdate;
          this.matrix.copy(e.matrix);
          this.generateMipmaps = e.generateMipmaps;
          this.premultiplyAlpha = e.premultiplyAlpha;
          this.flipY = e.flipY;
          this.unpackAlignment = e.unpackAlignment;
          this.encoding = e.encoding;
          this.userData = JSON.parse(JSON.stringify(e.userData));
          this.needsUpdate = true;
          return this;
        }
        toJSON(e) {
          const t = e === undefined || typeof e == "string";
          if (!t && e.textures[this.uuid] !== undefined) {
            return e.textures[this.uuid];
          }
          const i = {
            metadata: {
              version: 4.5,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            type: this.type,
            encoding: this.encoding,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          if (JSON.stringify(this.userData) !== "{}") {
            i.userData = this.userData;
          }
          if (!t) {
            e.textures[this.uuid] = i;
          }
          return i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(e) {
          if (this.mapping !== 300) {
            return e;
          }
          e.applyMatrix3(this.matrix);
          if (e.x < 0 || e.x > 1) {
            switch (this.wrapS) {
              case ne:
                e.x = e.x - Math.floor(e.x);
                break;
              case ae:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case re:
                if (Math.abs(Math.floor(e.x) % 2) === 1) {
                  e.x = Math.ceil(e.x) - e.x;
                } else {
                  e.x = e.x - Math.floor(e.x);
                }
            }
          }
          if (e.y < 0 || e.y > 1) {
            switch (this.wrapT) {
              case ne:
                e.y = e.y - Math.floor(e.y);
                break;
              case ae:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case re:
                if (Math.abs(Math.floor(e.y) % 2) === 1) {
                  e.y = Math.ceil(e.y) - e.y;
                } else {
                  e.y = e.y - Math.floor(e.y);
                }
            }
          }
          if (this.flipY) {
            e.y = 1 - e.y;
          }
          return e;
        }
        set needsUpdate(e) {
          if (e === true) {
            this.version++;
            this.source.needsUpdate = true;
          }
        }
      }
      Jt.DEFAULT_IMAGE = null;
      Jt.DEFAULT_MAPPING = 300;
      class Zt {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          Zt.prototype.isVector4 = true;
          this.x = e;
          this.y = t;
          this.z = i;
          this.w = n;
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, n) {
          this.x = e;
          this.y = t;
          this.z = i;
          this.w = n;
          return this;
        }
        setScalar(e) {
          this.x = e;
          this.y = e;
          this.z = e;
          this.w = e;
          return this;
        }
        setX(e) {
          this.x = e;
          return this;
        }
        setY(e) {
          this.y = e;
          return this;
        }
        setZ(e) {
          this.z = e;
          return this;
        }
        setW(e) {
          this.w = e;
          return this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          this.x = e.x;
          this.y = e.y;
          this.z = e.z;
          this.w = e.w !== undefined ? e.w : 1;
          return this;
        }
        add(e) {
          this.x += e.x;
          this.y += e.y;
          this.z += e.z;
          this.w += e.w;
          return this;
        }
        addScalar(e) {
          this.x += e;
          this.y += e;
          this.z += e;
          this.w += e;
          return this;
        }
        addVectors(e, t) {
          this.x = e.x + t.x;
          this.y = e.y + t.y;
          this.z = e.z + t.z;
          this.w = e.w + t.w;
          return this;
        }
        addScaledVector(e, t) {
          this.x += e.x * t;
          this.y += e.y * t;
          this.z += e.z * t;
          this.w += e.w * t;
          return this;
        }
        sub(e) {
          this.x -= e.x;
          this.y -= e.y;
          this.z -= e.z;
          this.w -= e.w;
          return this;
        }
        subScalar(e) {
          this.x -= e;
          this.y -= e;
          this.z -= e;
          this.w -= e;
          return this;
        }
        subVectors(e, t) {
          this.x = e.x - t.x;
          this.y = e.y - t.y;
          this.z = e.z - t.z;
          this.w = e.w - t.w;
          return this;
        }
        multiply(e) {
          this.x *= e.x;
          this.y *= e.y;
          this.z *= e.z;
          this.w *= e.w;
          return this;
        }
        multiplyScalar(e) {
          this.x *= e;
          this.y *= e;
          this.z *= e;
          this.w *= e;
          return this;
        }
        applyMatrix4(e) {
          const t = this.x;
          const i = this.y;
          const n = this.z;
          const a = this.w;
          const r = e.elements;
          this.x = r[0] * t + r[4] * i + r[8] * n + r[12] * a;
          this.y = r[1] * t + r[5] * i + r[9] * n + r[13] * a;
          this.z = r[2] * t + r[6] * i + r[10] * n + r[14] * a;
          this.w = r[3] * t + r[7] * i + r[11] * n + r[15] * a;
          return this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = Math.acos(e.w) * 2;
          const t = Math.sqrt(1 - e.w * e.w);
          if (t < 0.0001) {
            this.x = 1;
            this.y = 0;
            this.z = 0;
          } else {
            this.x = e.x / t;
            this.y = e.y / t;
            this.z = e.z / t;
          }
          return this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t;
          let i;
          let n;
          let a;
          const r = 0.01;
          const s = 0.1;
          const o = e.elements;
          const l = o[0];
          const c = o[4];
          const h = o[8];
          const d = o[1];
          const u = o[5];
          const p = o[9];
          const m = o[2];
          const f = o[6];
          const g = o[10];
          if (Math.abs(c - d) < r && Math.abs(h - m) < r && Math.abs(p - f) < r) {
            if (Math.abs(c + d) < s && Math.abs(h + m) < s && Math.abs(p + f) < s && Math.abs(l + u + g - 3) < s) {
              this.set(1, 0, 0, 0);
              return this;
            }
            t = Math.PI;
            const e = (l + 1) / 2;
            const o = (u + 1) / 2;
            const _ = (g + 1) / 2;
            const v = (c + d) / 4;
            const b = (h + m) / 4;
            const y = (p + f) / 4;
            if (e > o && e > _) {
              if (e < r) {
                i = 0;
                n = 0.707106781;
                a = 0.707106781;
              } else {
                i = Math.sqrt(e);
                n = v / i;
                a = b / i;
              }
            } else if (o > _) {
              if (o < r) {
                i = 0.707106781;
                n = 0;
                a = 0.707106781;
              } else {
                n = Math.sqrt(o);
                i = v / n;
                a = y / n;
              }
            } else if (_ < r) {
              i = 0.707106781;
              n = 0.707106781;
              a = 0;
            } else {
              a = Math.sqrt(_);
              i = b / a;
              n = y / a;
            }
            this.set(i, n, a, t);
            return this;
          }
          let _ = Math.sqrt((f - p) * (f - p) + (h - m) * (h - m) + (d - c) * (d - c));
          if (Math.abs(_) < 0.001) {
            _ = 1;
          }
          this.x = (f - p) / _;
          this.y = (h - m) / _;
          this.z = (d - c) / _;
          this.w = Math.acos((l + u + g - 1) / 2);
          return this;
        }
        min(e) {
          this.x = Math.min(this.x, e.x);
          this.y = Math.min(this.y, e.y);
          this.z = Math.min(this.z, e.z);
          this.w = Math.min(this.w, e.w);
          return this;
        }
        max(e) {
          this.x = Math.max(this.x, e.x);
          this.y = Math.max(this.y, e.y);
          this.z = Math.max(this.z, e.z);
          this.w = Math.max(this.w, e.w);
          return this;
        }
        clamp(e, t) {
          this.x = Math.max(e.x, Math.min(t.x, this.x));
          this.y = Math.max(e.y, Math.min(t.y, this.y));
          this.z = Math.max(e.z, Math.min(t.z, this.z));
          this.w = Math.max(e.w, Math.min(t.w, this.w));
          return this;
        }
        clampScalar(e, t) {
          this.x = Math.max(e, Math.min(t, this.x));
          this.y = Math.max(e, Math.min(t, this.y));
          this.z = Math.max(e, Math.min(t, this.z));
          this.w = Math.max(e, Math.min(t, this.w));
          return this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          this.w = Math.floor(this.w);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          this.w = Math.ceil(this.w);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          this.w = Math.round(this.w);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          this.w = -this.w;
          return this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          this.x += (e.x - this.x) * t;
          this.y += (e.y - this.y) * t;
          this.z += (e.z - this.z) * t;
          this.w += (e.w - this.w) * t;
          return this;
        }
        lerpVectors(e, t, i) {
          this.x = e.x + (t.x - e.x) * i;
          this.y = e.y + (t.y - e.y) * i;
          this.z = e.z + (t.z - e.z) * i;
          this.w = e.w + (t.w - e.w) * i;
          return this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          this.x = e[t];
          this.y = e[t + 1];
          this.z = e[t + 2];
          this.w = e[t + 3];
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this.x;
          e[t + 1] = this.y;
          e[t + 2] = this.z;
          e[t + 3] = this.w;
          return e;
        }
        fromBufferAttribute(e, t) {
          this.x = e.getX(t);
          this.y = e.getY(t);
          this.z = e.getZ(t);
          this.w = e.getW(t);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          this.w = Math.random();
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
          yield this.w;
        }
      }
      class Qt extends yt {
        constructor(e, t, i = {}) {
          super();
          this.isWebGLRenderTarget = true;
          this.width = e;
          this.height = t;
          this.depth = 1;
          this.scissor = new Zt(0, 0, e, t);
          this.scissorTest = false;
          this.viewport = new Zt(0, 0, e, t);
          const n = {
            width: e,
            height: t,
            depth: 1
          };
          this.texture = new Jt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.flipY = false;
          this.texture.generateMipmaps = i.generateMipmaps !== undefined && i.generateMipmaps;
          this.texture.internalFormat = i.internalFormat !== undefined ? i.internalFormat : null;
          this.texture.minFilter = i.minFilter !== undefined ? i.minFilter : ce;
          this.depthBuffer = i.depthBuffer === undefined || i.depthBuffer;
          this.stencilBuffer = i.stencilBuffer !== undefined && i.stencilBuffer;
          this.depthTexture = i.depthTexture !== undefined ? i.depthTexture : null;
          this.samples = i.samples !== undefined ? i.samples : 0;
        }
        setSize(e, t, i = 1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e;
            this.height = t;
            this.depth = i;
            this.texture.image.width = e;
            this.texture.image.height = t;
            this.texture.image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, e, t);
          this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.width = e.width;
          this.height = e.height;
          this.depth = e.depth;
          this.viewport.copy(e.viewport);
          this.texture = e.texture.clone();
          this.texture.isRenderTargetTexture = true;
          const t = Object.assign({}, e.texture.image);
          this.texture.source = new Xt(t);
          this.depthBuffer = e.depthBuffer;
          this.stencilBuffer = e.stencilBuffer;
          if (e.depthTexture !== null) {
            this.depthTexture = e.depthTexture.clone();
          }
          this.samples = e.samples;
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class ei extends Jt {
        constructor(e = null, t = 1, i = 1, n = 1) {
          super(null);
          this.isDataArrayTexture = true;
          this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
          };
          this.magFilter = se;
          this.minFilter = se;
          this.wrapR = ae;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      }
      class ti extends Jt {
        constructor(e = null, t = 1, i = 1, n = 1) {
          super(null);
          this.isData3DTexture = true;
          this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
          };
          this.magFilter = se;
          this.minFilter = se;
          this.wrapR = ae;
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      }
      class ii {
        constructor(e = 0, t = 0, i = 0, n = 1) {
          this.isQuaternion = true;
          this._x = e;
          this._y = t;
          this._z = i;
          this._w = n;
        }
        static slerpFlat(e, t, i, n, a, r, s) {
          let o = i[n + 0];
          let l = i[n + 1];
          let c = i[n + 2];
          let h = i[n + 3];
          const d = a[r + 0];
          const u = a[r + 1];
          const p = a[r + 2];
          const m = a[r + 3];
          if (s === 0) {
            e[t + 0] = o;
            e[t + 1] = l;
            e[t + 2] = c;
            e[t + 3] = h;
            return;
          }
          if (s === 1) {
            e[t + 0] = d;
            e[t + 1] = u;
            e[t + 2] = p;
            e[t + 3] = m;
            return;
          }
          if (h !== m || o !== d || l !== u || c !== p) {
            let e = 1 - s;
            const t = o * d + l * u + c * p + h * m;
            const i = t >= 0 ? 1 : -1;
            const n = 1 - t * t;
            if (n > Number.EPSILON) {
              const a = Math.sqrt(n);
              const r = Math.atan2(a, t * i);
              e = Math.sin(e * r) / a;
              s = Math.sin(s * r) / a;
            }
            const a = s * i;
            o = o * e + d * a;
            l = l * e + u * a;
            c = c * e + p * a;
            h = h * e + m * a;
            if (e === 1 - s) {
              const e = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
              o *= e;
              l *= e;
              c *= e;
              h *= e;
            }
          }
          e[t] = o;
          e[t + 1] = l;
          e[t + 2] = c;
          e[t + 3] = h;
        }
        static multiplyQuaternionsFlat(e, t, i, n, a, r) {
          const s = i[n];
          const o = i[n + 1];
          const l = i[n + 2];
          const c = i[n + 3];
          const h = a[r];
          const d = a[r + 1];
          const u = a[r + 2];
          const p = a[r + 3];
          e[t] = s * p + c * h + o * u - l * d;
          e[t + 1] = o * p + c * d + l * h - s * u;
          e[t + 2] = l * p + c * u + s * d - o * h;
          e[t + 3] = c * p - s * h - o * d - l * u;
          return e;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e;
          this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          this._w = e;
          this._onChangeCallback();
        }
        set(e, t, i, n) {
          this._x = e;
          this._y = t;
          this._z = i;
          this._w = n;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          this._x = e.x;
          this._y = e.y;
          this._z = e.z;
          this._w = e.w;
          this._onChangeCallback();
          return this;
        }
        setFromEuler(e, t) {
          const i = e._x;
          const n = e._y;
          const a = e._z;
          const r = e._order;
          const s = Math.cos;
          const o = Math.sin;
          const l = s(i / 2);
          const c = s(n / 2);
          const h = s(a / 2);
          const d = o(i / 2);
          const u = o(n / 2);
          const p = o(a / 2);
          switch (r) {
            case "XYZ":
              this._x = d * c * h + l * u * p;
              this._y = l * u * h - d * c * p;
              this._z = l * c * p + d * u * h;
              this._w = l * c * h - d * u * p;
              break;
            case "YXZ":
              this._x = d * c * h + l * u * p;
              this._y = l * u * h - d * c * p;
              this._z = l * c * p - d * u * h;
              this._w = l * c * h + d * u * p;
              break;
            case "ZXY":
              this._x = d * c * h - l * u * p;
              this._y = l * u * h + d * c * p;
              this._z = l * c * p + d * u * h;
              this._w = l * c * h - d * u * p;
              break;
            case "ZYX":
              this._x = d * c * h - l * u * p;
              this._y = l * u * h + d * c * p;
              this._z = l * c * p - d * u * h;
              this._w = l * c * h + d * u * p;
              break;
            case "YZX":
              this._x = d * c * h + l * u * p;
              this._y = l * u * h + d * c * p;
              this._z = l * c * p - d * u * h;
              this._w = l * c * h - d * u * p;
              break;
            case "XZY":
              this._x = d * c * h - l * u * p;
              this._y = l * u * h - d * c * p;
              this._z = l * c * p + d * u * h;
              this._w = l * c * h + d * u * p;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r);
          }
          if (t !== false) {
            this._onChangeCallback();
          }
          return this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2;
          const n = Math.sin(i);
          this._x = e.x * n;
          this._y = e.y * n;
          this._z = e.z * n;
          this._w = Math.cos(i);
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements;
          const i = t[0];
          const n = t[4];
          const a = t[8];
          const r = t[1];
          const s = t[5];
          const o = t[9];
          const l = t[2];
          const c = t[6];
          const h = t[10];
          const d = i + s + h;
          if (d > 0) {
            const e = 0.5 / Math.sqrt(d + 1);
            this._w = 0.25 / e;
            this._x = (c - o) * e;
            this._y = (a - l) * e;
            this._z = (r - n) * e;
          } else if (i > s && i > h) {
            const e = Math.sqrt(1 + i - s - h) * 2;
            this._w = (c - o) / e;
            this._x = e * 0.25;
            this._y = (n + r) / e;
            this._z = (a + l) / e;
          } else if (s > h) {
            const e = Math.sqrt(1 + s - i - h) * 2;
            this._w = (a - l) / e;
            this._x = (n + r) / e;
            this._y = e * 0.25;
            this._z = (o + c) / e;
          } else {
            const e = Math.sqrt(1 + h - i - s) * 2;
            this._w = (r - n) / e;
            this._x = (a + l) / e;
            this._y = (o + c) / e;
            this._z = e * 0.25;
          }
          this._onChangeCallback();
          return this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          if (i < Number.EPSILON) {
            i = 0;
            if (Math.abs(e.x) > Math.abs(e.z)) {
              this._x = -e.y;
              this._y = e.x;
              this._z = 0;
              this._w = i;
            } else {
              this._x = 0;
              this._y = -e.z;
              this._z = e.y;
              this._w = i;
            }
          } else {
            this._x = e.y * t.z - e.z * t.y;
            this._y = e.z * t.x - e.x * t.z;
            this._z = e.x * t.y - e.y * t.x;
            this._w = i;
          }
          return this.normalize();
        }
        angleTo(e) {
          return Math.acos(Math.abs(Et(this.dot(e), -1, 1))) * 2;
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (i === 0) {
            return this;
          }
          const n = Math.min(1, t / i);
          this.slerp(e, n);
          return this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          this._x *= -1;
          this._y *= -1;
          this._z *= -1;
          this._onChangeCallback();
          return this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          if (e === 0) {
            this._x = 0;
            this._y = 0;
            this._z = 0;
            this._w = 1;
          } else {
            e = 1 / e;
            this._x = this._x * e;
            this._y = this._y * e;
            this._z = this._z * e;
            this._w = this._w * e;
          }
          this._onChangeCallback();
          return this;
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x;
          const n = e._y;
          const a = e._z;
          const r = e._w;
          const s = t._x;
          const o = t._y;
          const l = t._z;
          const c = t._w;
          this._x = i * c + r * s + n * l - a * o;
          this._y = n * c + r * o + a * s - i * l;
          this._z = a * c + r * l + i * o - n * s;
          this._w = r * c - i * s - n * o - a * l;
          this._onChangeCallback();
          return this;
        }
        slerp(e, t) {
          if (t === 0) {
            return this;
          }
          if (t === 1) {
            return this.copy(e);
          }
          const i = this._x;
          const n = this._y;
          const a = this._z;
          const r = this._w;
          let s = r * e._w + i * e._x + n * e._y + a * e._z;
          if (s < 0) {
            this._w = -e._w;
            this._x = -e._x;
            this._y = -e._y;
            this._z = -e._z;
            s = -s;
          } else {
            this.copy(e);
          }
          if (s >= 1) {
            this._w = r;
            this._x = i;
            this._y = n;
            this._z = a;
            return this;
          }
          const o = 1 - s * s;
          if (o <= Number.EPSILON) {
            const e = 1 - t;
            this._w = e * r + t * this._w;
            this._x = e * i + t * this._x;
            this._y = e * n + t * this._y;
            this._z = e * a + t * this._z;
            this.normalize();
            this._onChangeCallback();
            return this;
          }
          const l = Math.sqrt(o);
          const c = Math.atan2(l, s);
          const h = Math.sin((1 - t) * c) / l;
          const d = Math.sin(t * c) / l;
          this._w = r * h + this._w * d;
          this._x = i * h + this._x * d;
          this._y = n * h + this._y * d;
          this._z = a * h + this._z * d;
          this._onChangeCallback();
          return this;
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = Math.random();
          const t = Math.sqrt(1 - e);
          const i = Math.sqrt(e);
          const n = Math.PI * 2 * Math.random();
          const a = Math.PI * 2 * Math.random();
          return this.set(t * Math.cos(n), i * Math.sin(a), i * Math.cos(a), t * Math.sin(n));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          this._x = e[t];
          this._y = e[t + 1];
          this._z = e[t + 2];
          this._w = e[t + 3];
          this._onChangeCallback();
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this._x;
          e[t + 1] = this._y;
          e[t + 2] = this._z;
          e[t + 3] = this._w;
          return e;
        }
        fromBufferAttribute(e, t) {
          this._x = e.getX(t);
          this._y = e.getY(t);
          this._z = e.getZ(t);
          this._w = e.getW(t);
          return this;
        }
        _onChange(e) {
          this._onChangeCallback = e;
          return this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._w;
        }
      }
      class ni {
        constructor(e = 0, t = 0, i = 0) {
          ni.prototype.isVector3 = true;
          this.x = e;
          this.y = t;
          this.z = i;
        }
        set(e, t, i = this.z) {
          this.x = e;
          this.y = t;
          this.z = i;
          return this;
        }
        setScalar(e) {
          this.x = e;
          this.y = e;
          this.z = e;
          return this;
        }
        setX(e) {
          this.x = e;
          return this;
        }
        setY(e) {
          this.y = e;
          return this;
        }
        setZ(e) {
          this.z = e;
          return this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          this.x = e.x;
          this.y = e.y;
          this.z = e.z;
          return this;
        }
        add(e) {
          this.x += e.x;
          this.y += e.y;
          this.z += e.z;
          return this;
        }
        addScalar(e) {
          this.x += e;
          this.y += e;
          this.z += e;
          return this;
        }
        addVectors(e, t) {
          this.x = e.x + t.x;
          this.y = e.y + t.y;
          this.z = e.z + t.z;
          return this;
        }
        addScaledVector(e, t) {
          this.x += e.x * t;
          this.y += e.y * t;
          this.z += e.z * t;
          return this;
        }
        sub(e) {
          this.x -= e.x;
          this.y -= e.y;
          this.z -= e.z;
          return this;
        }
        subScalar(e) {
          this.x -= e;
          this.y -= e;
          this.z -= e;
          return this;
        }
        subVectors(e, t) {
          this.x = e.x - t.x;
          this.y = e.y - t.y;
          this.z = e.z - t.z;
          return this;
        }
        multiply(e) {
          this.x *= e.x;
          this.y *= e.y;
          this.z *= e.z;
          return this;
        }
        multiplyScalar(e) {
          this.x *= e;
          this.y *= e;
          this.z *= e;
          return this;
        }
        multiplyVectors(e, t) {
          this.x = e.x * t.x;
          this.y = e.y * t.y;
          this.z = e.z * t.z;
          return this;
        }
        applyEuler(e) {
          return this.applyQuaternion(ri.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(ri.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x;
          const i = this.y;
          const n = this.z;
          const a = e.elements;
          this.x = a[0] * t + a[3] * i + a[6] * n;
          this.y = a[1] * t + a[4] * i + a[7] * n;
          this.z = a[2] * t + a[5] * i + a[8] * n;
          return this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x;
          const i = this.y;
          const n = this.z;
          const a = e.elements;
          const r = 1 / (a[3] * t + a[7] * i + a[11] * n + a[15]);
          this.x = (a[0] * t + a[4] * i + a[8] * n + a[12]) * r;
          this.y = (a[1] * t + a[5] * i + a[9] * n + a[13]) * r;
          this.z = (a[2] * t + a[6] * i + a[10] * n + a[14]) * r;
          return this;
        }
        applyQuaternion(e) {
          const t = this.x;
          const i = this.y;
          const n = this.z;
          const a = e.x;
          const r = e.y;
          const s = e.z;
          const o = e.w;
          const l = o * t + r * n - s * i;
          const c = o * i + s * t - a * n;
          const h = o * n + a * i - r * t;
          const d = -a * t - r * i - s * n;
          this.x = l * o + d * -a + c * -s - h * -r;
          this.y = c * o + d * -r + h * -a - l * -s;
          this.z = h * o + d * -s + l * -r - c * -a;
          return this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x;
          const i = this.y;
          const n = this.z;
          const a = e.elements;
          this.x = a[0] * t + a[4] * i + a[8] * n;
          this.y = a[1] * t + a[5] * i + a[9] * n;
          this.z = a[2] * t + a[6] * i + a[10] * n;
          return this.normalize();
        }
        divide(e) {
          this.x /= e.x;
          this.y /= e.y;
          this.z /= e.z;
          return this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          this.x = Math.min(this.x, e.x);
          this.y = Math.min(this.y, e.y);
          this.z = Math.min(this.z, e.z);
          return this;
        }
        max(e) {
          this.x = Math.max(this.x, e.x);
          this.y = Math.max(this.y, e.y);
          this.z = Math.max(this.z, e.z);
          return this;
        }
        clamp(e, t) {
          this.x = Math.max(e.x, Math.min(t.x, this.x));
          this.y = Math.max(e.y, Math.min(t.y, this.y));
          this.z = Math.max(e.z, Math.min(t.z, this.z));
          return this;
        }
        clampScalar(e, t) {
          this.x = Math.max(e, Math.min(t, this.x));
          this.y = Math.max(e, Math.min(t, this.y));
          this.z = Math.max(e, Math.min(t, this.z));
          return this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
        }
        floor() {
          this.x = Math.floor(this.x);
          this.y = Math.floor(this.y);
          this.z = Math.floor(this.z);
          return this;
        }
        ceil() {
          this.x = Math.ceil(this.x);
          this.y = Math.ceil(this.y);
          this.z = Math.ceil(this.z);
          return this;
        }
        round() {
          this.x = Math.round(this.x);
          this.y = Math.round(this.y);
          this.z = Math.round(this.z);
          return this;
        }
        roundToZero() {
          this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
          this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
          this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
          return this;
        }
        negate() {
          this.x = -this.x;
          this.y = -this.y;
          this.z = -this.z;
          return this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          this.x += (e.x - this.x) * t;
          this.y += (e.y - this.y) * t;
          this.z += (e.z - this.z) * t;
          return this;
        }
        lerpVectors(e, t, i) {
          this.x = e.x + (t.x - e.x) * i;
          this.y = e.y + (t.y - e.y) * i;
          this.z = e.z + (t.z - e.z) * i;
          return this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x;
          const n = e.y;
          const a = e.z;
          const r = t.x;
          const s = t.y;
          const o = t.z;
          this.x = n * o - a * s;
          this.y = a * r - i * o;
          this.z = i * s - n * r;
          return this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) {
            return this.set(0, 0, 0);
          }
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          ai.copy(this).projectOnVector(e);
          return this.sub(ai);
        }
        reflect(e) {
          return this.sub(ai.copy(e).multiplyScalar(this.dot(e) * 2));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) {
            return Math.PI / 2;
          }
          const i = this.dot(e) / t;
          return Math.acos(Et(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x;
          const i = this.y - e.y;
          const n = this.z - e.z;
          return t * t + i * i + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const n = Math.sin(t) * e;
          this.x = n * Math.sin(i);
          this.y = Math.cos(t) * e;
          this.z = n * Math.cos(i);
          return this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          this.x = e * Math.sin(t);
          this.y = i;
          this.z = e * Math.cos(t);
          return this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          this.x = t[12];
          this.y = t[13];
          this.z = t[14];
          return this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length();
          const i = this.setFromMatrixColumn(e, 1).length();
          const n = this.setFromMatrixColumn(e, 2).length();
          this.x = t;
          this.y = i;
          this.z = n;
          return this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          this.x = e._x;
          this.y = e._y;
          this.z = e._z;
          return this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          this.x = e[t];
          this.y = e[t + 1];
          this.z = e[t + 2];
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this.x;
          e[t + 1] = this.y;
          e[t + 2] = this.z;
          return e;
        }
        fromBufferAttribute(e, t) {
          this.x = e.getX(t);
          this.y = e.getY(t);
          this.z = e.getZ(t);
          return this;
        }
        random() {
          this.x = Math.random();
          this.y = Math.random();
          this.z = Math.random();
          return this;
        }
        randomDirection() {
          const e = (Math.random() - 0.5) * 2;
          const t = Math.random() * Math.PI * 2;
          const i = Math.sqrt(1 - e ** 2);
          this.x = i * Math.cos(t);
          this.y = i * Math.sin(t);
          this.z = e;
          return this;
        }
        *[Symbol.iterator]() {
          yield this.x;
          yield this.y;
          yield this.z;
        }
      }
      const ai = new ni();
      const ri = new ii();
      class si {
        constructor(e = new ni(Infinity, Infinity, Infinity), t = new ni(-Infinity, -Infinity, -Infinity)) {
          this.isBox3 = true;
          this.min = e;
          this.max = t;
        }
        set(e, t) {
          this.min.copy(e);
          this.max.copy(t);
          return this;
        }
        setFromArray(e) {
          let t = Infinity;
          let i = Infinity;
          let n = Infinity;
          let a = -Infinity;
          let r = -Infinity;
          let s = -Infinity;
          for (let o = 0, l = e.length; o < l; o += 3) {
            const l = e[o];
            const c = e[o + 1];
            const h = e[o + 2];
            if (l < t) {
              t = l;
            }
            if (c < i) {
              i = c;
            }
            if (h < n) {
              n = h;
            }
            if (l > a) {
              a = l;
            }
            if (c > r) {
              r = c;
            }
            if (h > s) {
              s = h;
            }
          }
          this.min.set(t, i, n);
          this.max.set(a, r, s);
          return this;
        }
        setFromBufferAttribute(e) {
          let t = Infinity;
          let i = Infinity;
          let n = Infinity;
          let a = -Infinity;
          let r = -Infinity;
          let s = -Infinity;
          for (let o = 0, l = e.count; o < l; o++) {
            const l = e.getX(o);
            const c = e.getY(o);
            const h = e.getZ(o);
            if (l < t) {
              t = l;
            }
            if (c < i) {
              i = c;
            }
            if (h < n) {
              n = h;
            }
            if (l > a) {
              a = l;
            }
            if (c > r) {
              r = c;
            }
            if (h > s) {
              s = h;
            }
          }
          this.min.set(t, i, n);
          this.max.set(a, r, s);
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) {
            this.expandByPoint(e[t]);
          }
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = li.copy(t).multiplyScalar(0.5);
          this.min.copy(e).sub(i);
          this.max.copy(e).add(i);
          return this;
        }
        setFromObject(e, t = false) {
          this.makeEmpty();
          return this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.min.copy(e.min);
          this.max.copy(e.max);
          return this;
        }
        makeEmpty() {
          this.min.x = this.min.y = this.min.z = Infinity;
          this.max.x = this.max.y = this.max.z = -Infinity;
          return this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          if (this.isEmpty()) {
            return e.set(0, 0, 0);
          } else {
            return e.addVectors(this.min, this.max).multiplyScalar(0.5);
          }
        }
        getSize(e) {
          if (this.isEmpty()) {
            return e.set(0, 0, 0);
          } else {
            return e.subVectors(this.max, this.min);
          }
        }
        expandByPoint(e) {
          this.min.min(e);
          this.max.max(e);
          return this;
        }
        expandByVector(e) {
          this.min.sub(e);
          this.max.add(e);
          return this;
        }
        expandByScalar(e) {
          this.min.addScalar(-e);
          this.max.addScalar(e);
          return this;
        }
        expandByObject(e, t = false) {
          e.updateWorldMatrix(false, false);
          const i = e.geometry;
          if (i !== undefined) {
            if (t && i.attributes != null && i.attributes.position !== undefined) {
              const t = i.attributes.position;
              for (let i = 0, n = t.count; i < n; i++) {
                li.fromBufferAttribute(t, i).applyMatrix4(e.matrixWorld);
                this.expandByPoint(li);
              }
            } else {
              if (i.boundingBox === null) {
                i.computeBoundingBox();
              }
              ci.copy(i.boundingBox);
              ci.applyMatrix4(e.matrixWorld);
              this.union(ci);
            }
          }
          const n = e.children;
          for (let e = 0, i = n.length; e < i; e++) {
            this.expandByObject(n[e], t);
          }
          return this;
        }
        containsPoint(e) {
          return !(e.x < this.min.x) && !(e.x > this.max.x) && !(e.y < this.min.y) && !(e.y > this.max.y) && !(e.z < this.min.z) && !(e.z > this.max.z);
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
          return !(e.max.x < this.min.x) && !(e.min.x > this.max.x) && !(e.max.y < this.min.y) && !(e.min.y > this.max.y) && !(e.max.z < this.min.z) && !(e.min.z > this.max.z);
        }
        intersectsSphere(e) {
          this.clampPoint(e.center, li);
          return li.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t;
          let i;
          if (e.normal.x > 0) {
            t = e.normal.x * this.min.x;
            i = e.normal.x * this.max.x;
          } else {
            t = e.normal.x * this.max.x;
            i = e.normal.x * this.min.x;
          }
          if (e.normal.y > 0) {
            t += e.normal.y * this.min.y;
            i += e.normal.y * this.max.y;
          } else {
            t += e.normal.y * this.max.y;
            i += e.normal.y * this.min.y;
          }
          if (e.normal.z > 0) {
            t += e.normal.z * this.min.z;
            i += e.normal.z * this.max.z;
          } else {
            t += e.normal.z * this.max.z;
            i += e.normal.z * this.min.z;
          }
          return t <= -e.constant && i >= -e.constant;
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) {
            return false;
          }
          this.getCenter(gi);
          _i.subVectors(this.max, gi);
          hi.subVectors(e.a, gi);
          di.subVectors(e.b, gi);
          ui.subVectors(e.c, gi);
          pi.subVectors(di, hi);
          mi.subVectors(ui, di);
          fi.subVectors(hi, ui);
          let t = [0, -pi.z, pi.y, 0, -mi.z, mi.y, 0, -fi.z, fi.y, pi.z, 0, -pi.x, mi.z, 0, -mi.x, fi.z, 0, -fi.x, -pi.y, pi.x, 0, -mi.y, mi.x, 0, -fi.y, fi.x, 0];
          return !!yi(t, hi, di, ui, _i) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!yi(t, hi, di, ui, _i) && (vi.crossVectors(pi, mi), t = [vi.x, vi.y, vi.z], yi(t, hi, di, ui, _i)));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return li.copy(e).clamp(this.min, this.max).sub(e).length();
        }
        getBoundingSphere(e) {
          this.getCenter(e.center);
          e.radius = this.getSize(li).length() * 0.5;
          return e;
        }
        intersect(e) {
          this.min.max(e.min);
          this.max.min(e.max);
          if (this.isEmpty()) {
            this.makeEmpty();
          }
          return this;
        }
        union(e) {
          this.min.min(e.min);
          this.max.max(e.max);
          return this;
        }
        applyMatrix4(e) {
          if (!this.isEmpty()) {
            oi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e);
            oi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e);
            oi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e);
            oi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e);
            oi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e);
            oi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e);
            oi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e);
            oi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e);
            this.setFromPoints(oi);
          }
          return this;
        }
        translate(e) {
          this.min.add(e);
          this.max.add(e);
          return this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const oi = [new ni(), new ni(), new ni(), new ni(), new ni(), new ni(), new ni(), new ni()];
      const li = new ni();
      const ci = new si();
      const hi = new ni();
      const di = new ni();
      const ui = new ni();
      const pi = new ni();
      const mi = new ni();
      const fi = new ni();
      const gi = new ni();
      const _i = new ni();
      const vi = new ni();
      const bi = new ni();
      function yi(e, t, i, n, a) {
        for (let r = 0, s = e.length - 3; r <= s; r += 3) {
          bi.fromArray(e, r);
          const s = a.x * Math.abs(bi.x) + a.y * Math.abs(bi.y) + a.z * Math.abs(bi.z);
          const o = t.dot(bi);
          const l = i.dot(bi);
          const c = n.dot(bi);
          if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > s) {
            return false;
          }
        }
        return true;
      }
      const xi = new si();
      const wi = new ni();
      const Mi = new ni();
      const Si = new ni();
      class Ei {
        constructor(e = new ni(), t = -1) {
          this.center = e;
          this.radius = t;
        }
        set(e, t) {
          this.center.copy(e);
          this.radius = t;
          return this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          if (t !== undefined) {
            i.copy(t);
          } else {
            xi.setFromPoints(e).getCenter(i);
          }
          let n = 0;
          for (let t = 0, a = e.length; t < a; t++) {
            n = Math.max(n, i.distanceToSquared(e[t]));
          }
          this.radius = Math.sqrt(n);
          return this;
        }
        copy(e) {
          this.center.copy(e.center);
          this.radius = e.radius;
          return this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          this.center.set(0, 0, 0);
          this.radius = -1;
          return this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          t.copy(e);
          if (i > this.radius * this.radius) {
            t.sub(this.center).normalize();
            t.multiplyScalar(this.radius).add(this.center);
          }
          return t;
        }
        getBoundingBox(e) {
          if (this.isEmpty()) {
            e.makeEmpty();
            return e;
          } else {
            e.set(this.center, this.center);
            e.expandByScalar(this.radius);
            return e;
          }
        }
        applyMatrix4(e) {
          this.center.applyMatrix4(e);
          this.radius = this.radius * e.getMaxScaleOnAxis();
          return this;
        }
        translate(e) {
          this.center.add(e);
          return this;
        }
        expandByPoint(e) {
          Si.subVectors(e, this.center);
          const t = Si.lengthSq();
          if (t > this.radius * this.radius) {
            const e = Math.sqrt(t);
            const i = (e - this.radius) * 0.5;
            this.center.add(Si.multiplyScalar(i / e));
            this.radius += i;
          }
          return this;
        }
        union(e) {
          if (this.center.equals(e.center) === true) {
            Mi.set(0, 0, 1).multiplyScalar(e.radius);
          } else {
            Mi.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius);
          }
          this.expandByPoint(wi.copy(e.center).add(Mi));
          this.expandByPoint(wi.copy(e.center).sub(Mi));
          return this;
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Ti = new ni();
      const Ci = new ni();
      const ki = new ni();
      const Ai = new ni();
      const Li = new ni();
      const Ri = new ni();
      const Pi = new ni();
      class Di {
        constructor(e = new ni(), t = new ni(0, 0, -1)) {
          this.origin = e;
          this.direction = t;
        }
        set(e, t) {
          this.origin.copy(e);
          this.direction.copy(t);
          return this;
        }
        copy(e) {
          this.origin.copy(e.origin);
          this.direction.copy(e.direction);
          return this;
        }
        at(e, t) {
          return t.copy(this.direction).multiplyScalar(e).add(this.origin);
        }
        lookAt(e) {
          this.direction.copy(e).sub(this.origin).normalize();
          return this;
        }
        recast(e) {
          this.origin.copy(this.at(e, Ti));
          return this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          if (i < 0) {
            return t.copy(this.origin);
          } else {
            return t.copy(this.direction).multiplyScalar(i).add(this.origin);
          }
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Ti.subVectors(e, this.origin).dot(this.direction);
          if (t < 0) {
            return this.origin.distanceToSquared(e);
          } else {
            Ti.copy(this.direction).multiplyScalar(t).add(this.origin);
            return Ti.distanceToSquared(e);
          }
        }
        distanceSqToSegment(e, t, i, n) {
          Ci.copy(e).add(t).multiplyScalar(0.5);
          ki.copy(t).sub(e).normalize();
          Ai.copy(this.origin).sub(Ci);
          const a = e.distanceTo(t) * 0.5;
          const r = -this.direction.dot(ki);
          const s = Ai.dot(this.direction);
          const o = -Ai.dot(ki);
          const l = Ai.lengthSq();
          const c = Math.abs(1 - r * r);
          let h;
          let d;
          let u;
          let p;
          if (c > 0) {
            h = r * o - s;
            d = r * s - o;
            p = a * c;
            if (h >= 0) {
              if (d >= -p) {
                if (d <= p) {
                  const e = 1 / c;
                  h *= e;
                  d *= e;
                  u = h * (h + r * d + s * 2) + d * (r * h + d + o * 2) + l;
                } else {
                  d = a;
                  h = Math.max(0, -(r * d + s));
                  u = -h * h + d * (d + o * 2) + l;
                }
              } else {
                d = -a;
                h = Math.max(0, -(r * d + s));
                u = -h * h + d * (d + o * 2) + l;
              }
            } else if (d <= -p) {
              h = Math.max(0, -(-r * a + s));
              d = h > 0 ? -a : Math.min(Math.max(-a, -o), a);
              u = -h * h + d * (d + o * 2) + l;
            } else if (d <= p) {
              h = 0;
              d = Math.min(Math.max(-a, -o), a);
              u = d * (d + o * 2) + l;
            } else {
              h = Math.max(0, -(r * a + s));
              d = h > 0 ? a : Math.min(Math.max(-a, -o), a);
              u = -h * h + d * (d + o * 2) + l;
            }
          } else {
            d = r > 0 ? -a : a;
            h = Math.max(0, -(r * d + s));
            u = -h * h + d * (d + o * 2) + l;
          }
          if (i) {
            i.copy(this.direction).multiplyScalar(h).add(this.origin);
          }
          if (n) {
            n.copy(ki).multiplyScalar(d).add(Ci);
          }
          return u;
        }
        intersectSphere(e, t) {
          Ti.subVectors(e.center, this.origin);
          const i = Ti.dot(this.direction);
          const n = Ti.dot(Ti) - i * i;
          const a = e.radius * e.radius;
          if (n > a) {
            return null;
          }
          const r = Math.sqrt(a - n);
          const s = i - r;
          const o = i + r;
          if (s < 0 && o < 0) {
            return null;
          } else if (s < 0) {
            return this.at(o, t);
          } else {
            return this.at(s, t);
          }
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) {
            if (e.distanceToPoint(this.origin) === 0) {
              return 0;
            } else {
              return null;
            }
          }
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          if (i >= 0) {
            return i;
          } else {
            return null;
          }
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          if (i === null) {
            return null;
          } else {
            return this.at(i, t);
          }
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i;
          let n;
          let a;
          let r;
          let s;
          let o;
          const l = 1 / this.direction.x;
          const c = 1 / this.direction.y;
          const h = 1 / this.direction.z;
          const d = this.origin;
          if (l >= 0) {
            i = (e.min.x - d.x) * l;
            n = (e.max.x - d.x) * l;
          } else {
            i = (e.max.x - d.x) * l;
            n = (e.min.x - d.x) * l;
          }
          if (c >= 0) {
            a = (e.min.y - d.y) * c;
            r = (e.max.y - d.y) * c;
          } else {
            a = (e.max.y - d.y) * c;
            r = (e.min.y - d.y) * c;
          }
          if (i > r || a > n) {
            return null;
          } else {
            if (a > i || i != i) {
              i = a;
            }
            if (r < n || n != n) {
              n = r;
            }
            if (h >= 0) {
              s = (e.min.z - d.z) * h;
              o = (e.max.z - d.z) * h;
            } else {
              s = (e.max.z - d.z) * h;
              o = (e.min.z - d.z) * h;
            }
            if (i > o || s > n) {
              return null;
            } else {
              if (s > i || i != i) {
                i = s;
              }
              if (o < n || n != n) {
                n = o;
              }
              if (n < 0) {
                return null;
              } else {
                return this.at(i >= 0 ? i : n, t);
              }
            }
          }
        }
        intersectsBox(e) {
          return this.intersectBox(e, Ti) !== null;
        }
        intersectTriangle(e, t, i, n, a) {
          Li.subVectors(t, e);
          Ri.subVectors(i, e);
          Pi.crossVectors(Li, Ri);
          let r;
          let s = this.direction.dot(Pi);
          if (s > 0) {
            if (n) {
              return null;
            }
            r = 1;
          } else {
            if (!(s < 0)) {
              return null;
            }
            r = -1;
            s = -s;
          }
          Ai.subVectors(this.origin, e);
          const o = r * this.direction.dot(Ri.crossVectors(Ai, Ri));
          if (o < 0) {
            return null;
          }
          const l = r * this.direction.dot(Li.cross(Ai));
          if (l < 0) {
            return null;
          }
          if (o + l > s) {
            return null;
          }
          const c = -r * Ai.dot(Pi);
          if (c < 0) {
            return null;
          } else {
            return this.at(c / s, a);
          }
        }
        applyMatrix4(e) {
          this.origin.applyMatrix4(e);
          this.direction.transformDirection(e);
          return this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Ii {
        constructor() {
          Ii.prototype.isMatrix4 = true;
          this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        }
        set(e, t, i, n, a, r, s, o, l, c, h, d, u, p, m, f) {
          const g = this.elements;
          g[0] = e;
          g[4] = t;
          g[8] = i;
          g[12] = n;
          g[1] = a;
          g[5] = r;
          g[9] = s;
          g[13] = o;
          g[2] = l;
          g[6] = c;
          g[10] = h;
          g[14] = d;
          g[3] = u;
          g[7] = p;
          g[11] = m;
          g[15] = f;
          return this;
        }
        identity() {
          this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        clone() {
          return new Ii().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements;
          const i = e.elements;
          t[0] = i[0];
          t[1] = i[1];
          t[2] = i[2];
          t[3] = i[3];
          t[4] = i[4];
          t[5] = i[5];
          t[6] = i[6];
          t[7] = i[7];
          t[8] = i[8];
          t[9] = i[9];
          t[10] = i[10];
          t[11] = i[11];
          t[12] = i[12];
          t[13] = i[13];
          t[14] = i[14];
          t[15] = i[15];
          return this;
        }
        copyPosition(e) {
          const t = this.elements;
          const i = e.elements;
          t[12] = i[12];
          t[13] = i[13];
          t[14] = i[14];
          return this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1);
          return this;
        }
        extractBasis(e, t, i) {
          e.setFromMatrixColumn(this, 0);
          t.setFromMatrixColumn(this, 1);
          i.setFromMatrixColumn(this, 2);
          return this;
        }
        makeBasis(e, t, i) {
          this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1);
          return this;
        }
        extractRotation(e) {
          const t = this.elements;
          const i = e.elements;
          const n = 1 / $i.setFromMatrixColumn(e, 0).length();
          const a = 1 / $i.setFromMatrixColumn(e, 1).length();
          const r = 1 / $i.setFromMatrixColumn(e, 2).length();
          t[0] = i[0] * n;
          t[1] = i[1] * n;
          t[2] = i[2] * n;
          t[3] = 0;
          t[4] = i[4] * a;
          t[5] = i[5] * a;
          t[6] = i[6] * a;
          t[7] = 0;
          t[8] = i[8] * r;
          t[9] = i[9] * r;
          t[10] = i[10] * r;
          t[11] = 0;
          t[12] = 0;
          t[13] = 0;
          t[14] = 0;
          t[15] = 1;
          return this;
        }
        makeRotationFromEuler(e) {
          const t = this.elements;
          const i = e.x;
          const n = e.y;
          const a = e.z;
          const r = Math.cos(i);
          const s = Math.sin(i);
          const o = Math.cos(n);
          const l = Math.sin(n);
          const c = Math.cos(a);
          const h = Math.sin(a);
          if (e.order === "XYZ") {
            const e = r * c;
            const i = r * h;
            const n = s * c;
            const a = s * h;
            t[0] = o * c;
            t[4] = -o * h;
            t[8] = l;
            t[1] = i + n * l;
            t[5] = e - a * l;
            t[9] = -s * o;
            t[2] = a - e * l;
            t[6] = n + i * l;
            t[10] = r * o;
          } else if (e.order === "YXZ") {
            const e = o * c;
            const i = o * h;
            const n = l * c;
            const a = l * h;
            t[0] = e + a * s;
            t[4] = n * s - i;
            t[8] = r * l;
            t[1] = r * h;
            t[5] = r * c;
            t[9] = -s;
            t[2] = i * s - n;
            t[6] = a + e * s;
            t[10] = r * o;
          } else if (e.order === "ZXY") {
            const e = o * c;
            const i = o * h;
            const n = l * c;
            const a = l * h;
            t[0] = e - a * s;
            t[4] = -r * h;
            t[8] = n + i * s;
            t[1] = i + n * s;
            t[5] = r * c;
            t[9] = a - e * s;
            t[2] = -r * l;
            t[6] = s;
            t[10] = r * o;
          } else if (e.order === "ZYX") {
            const e = r * c;
            const i = r * h;
            const n = s * c;
            const a = s * h;
            t[0] = o * c;
            t[4] = n * l - i;
            t[8] = e * l + a;
            t[1] = o * h;
            t[5] = a * l + e;
            t[9] = i * l - n;
            t[2] = -l;
            t[6] = s * o;
            t[10] = r * o;
          } else if (e.order === "YZX") {
            const e = r * o;
            const i = r * l;
            const n = s * o;
            const a = s * l;
            t[0] = o * c;
            t[4] = a - e * h;
            t[8] = n * h + i;
            t[1] = h;
            t[5] = r * c;
            t[9] = -s * c;
            t[2] = -l * c;
            t[6] = i * h + n;
            t[10] = e - a * h;
          } else if (e.order === "XZY") {
            const e = r * o;
            const i = r * l;
            const n = s * o;
            const a = s * l;
            t[0] = o * c;
            t[4] = -h;
            t[8] = l * c;
            t[1] = e * h + a;
            t[5] = r * c;
            t[9] = i * h - n;
            t[2] = n * h - i;
            t[6] = s * c;
            t[10] = a * h + e;
          }
          t[3] = 0;
          t[7] = 0;
          t[11] = 0;
          t[12] = 0;
          t[13] = 0;
          t[14] = 0;
          t[15] = 1;
          return this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(Ni, e, Oi);
        }
        lookAt(e, t, i) {
          const n = this.elements;
          Bi.subVectors(e, t);
          if (Bi.lengthSq() === 0) {
            Bi.z = 1;
          }
          Bi.normalize();
          Ui.crossVectors(i, Bi);
          if (Ui.lengthSq() === 0) {
            if (Math.abs(i.z) === 1) {
              Bi.x += 0.0001;
            } else {
              Bi.z += 0.0001;
            }
            Bi.normalize();
            Ui.crossVectors(i, Bi);
          }
          Ui.normalize();
          Fi.crossVectors(Bi, Ui);
          n[0] = Ui.x;
          n[4] = Fi.x;
          n[8] = Bi.x;
          n[1] = Ui.y;
          n[5] = Fi.y;
          n[9] = Bi.y;
          n[2] = Ui.z;
          n[6] = Fi.z;
          n[10] = Bi.z;
          return this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements;
          const n = t.elements;
          const a = this.elements;
          const r = i[0];
          const s = i[4];
          const o = i[8];
          const l = i[12];
          const c = i[1];
          const h = i[5];
          const d = i[9];
          const u = i[13];
          const p = i[2];
          const m = i[6];
          const f = i[10];
          const g = i[14];
          const _ = i[3];
          const v = i[7];
          const b = i[11];
          const y = i[15];
          const x = n[0];
          const w = n[4];
          const M = n[8];
          const S = n[12];
          const E = n[1];
          const T = n[5];
          const C = n[9];
          const k = n[13];
          const A = n[2];
          const L = n[6];
          const R = n[10];
          const P = n[14];
          const D = n[3];
          const I = n[7];
          const $ = n[11];
          const z = n[15];
          a[0] = r * x + s * E + o * A + l * D;
          a[4] = r * w + s * T + o * L + l * I;
          a[8] = r * M + s * C + o * R + l * $;
          a[12] = r * S + s * k + o * P + l * z;
          a[1] = c * x + h * E + d * A + u * D;
          a[5] = c * w + h * T + d * L + u * I;
          a[9] = c * M + h * C + d * R + u * $;
          a[13] = c * S + h * k + d * P + u * z;
          a[2] = p * x + m * E + f * A + g * D;
          a[6] = p * w + m * T + f * L + g * I;
          a[10] = p * M + m * C + f * R + g * $;
          a[14] = p * S + m * k + f * P + g * z;
          a[3] = _ * x + v * E + b * A + y * D;
          a[7] = _ * w + v * T + b * L + y * I;
          a[11] = _ * M + v * C + b * R + y * $;
          a[15] = _ * S + v * k + b * P + y * z;
          return this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          t[0] *= e;
          t[4] *= e;
          t[8] *= e;
          t[12] *= e;
          t[1] *= e;
          t[5] *= e;
          t[9] *= e;
          t[13] *= e;
          t[2] *= e;
          t[6] *= e;
          t[10] *= e;
          t[14] *= e;
          t[3] *= e;
          t[7] *= e;
          t[11] *= e;
          t[15] *= e;
          return this;
        }
        determinant() {
          const e = this.elements;
          const t = e[0];
          const i = e[4];
          const n = e[8];
          const a = e[12];
          const r = e[1];
          const s = e[5];
          const o = e[9];
          const l = e[13];
          const c = e[2];
          const h = e[6];
          const d = e[10];
          const u = e[14];
          return e[3] * (+a * o * h - n * l * h - a * s * d + i * l * d + n * s * u - i * o * u) + e[7] * (+t * o * u - t * l * d + a * r * d - n * r * u + n * l * c - a * o * c) + e[11] * (+t * l * h - t * s * u - a * r * h + i * r * u + a * s * c - i * l * c) + e[15] * (-n * s * c - t * o * h + t * s * d + n * r * h - i * r * d + i * o * c);
        }
        transpose() {
          const e = this.elements;
          let t;
          t = e[1];
          e[1] = e[4];
          e[4] = t;
          t = e[2];
          e[2] = e[8];
          e[8] = t;
          t = e[6];
          e[6] = e[9];
          e[9] = t;
          t = e[3];
          e[3] = e[12];
          e[12] = t;
          t = e[7];
          e[7] = e[13];
          e[13] = t;
          t = e[11];
          e[11] = e[14];
          e[14] = t;
          return this;
        }
        setPosition(e, t, i) {
          const n = this.elements;
          if (e.isVector3) {
            n[12] = e.x;
            n[13] = e.y;
            n[14] = e.z;
          } else {
            n[12] = e;
            n[13] = t;
            n[14] = i;
          }
          return this;
        }
        invert() {
          const e = this.elements;
          const t = e[0];
          const i = e[1];
          const n = e[2];
          const a = e[3];
          const r = e[4];
          const s = e[5];
          const o = e[6];
          const l = e[7];
          const c = e[8];
          const h = e[9];
          const d = e[10];
          const u = e[11];
          const p = e[12];
          const m = e[13];
          const f = e[14];
          const g = e[15];
          const _ = h * f * l - m * d * l + m * o * u - s * f * u - h * o * g + s * d * g;
          const v = p * d * l - c * f * l - p * o * u + r * f * u + c * o * g - r * d * g;
          const b = c * m * l - p * h * l + p * s * u - r * m * u - c * s * g + r * h * g;
          const y = p * h * o - c * m * o - p * s * d + r * m * d + c * s * f - r * h * f;
          const x = t * _ + i * v + n * b + a * y;
          if (x === 0) {
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
          const w = 1 / x;
          e[0] = _ * w;
          e[1] = (m * d * a - h * f * a - m * n * u + i * f * u + h * n * g - i * d * g) * w;
          e[2] = (s * f * a - m * o * a + m * n * l - i * f * l - s * n * g + i * o * g) * w;
          e[3] = (h * o * a - s * d * a - h * n * l + i * d * l + s * n * u - i * o * u) * w;
          e[4] = v * w;
          e[5] = (c * f * a - p * d * a + p * n * u - t * f * u - c * n * g + t * d * g) * w;
          e[6] = (p * o * a - r * f * a - p * n * l + t * f * l + r * n * g - t * o * g) * w;
          e[7] = (r * d * a - c * o * a + c * n * l - t * d * l - r * n * u + t * o * u) * w;
          e[8] = b * w;
          e[9] = (p * h * a - c * m * a - p * i * u + t * m * u + c * i * g - t * h * g) * w;
          e[10] = (r * m * a - p * s * a + p * i * l - t * m * l - r * i * g + t * s * g) * w;
          e[11] = (c * s * a - r * h * a - c * i * l + t * h * l + r * i * u - t * s * u) * w;
          e[12] = y * w;
          e[13] = (c * m * n - p * h * n + p * i * d - t * m * d - c * i * f + t * h * f) * w;
          e[14] = (p * s * n - r * m * n - p * i * o + t * m * o + r * i * f - t * s * f) * w;
          e[15] = (r * h * n - c * s * n + c * i * o - t * h * o - r * i * d + t * s * d) * w;
          return this;
        }
        scale(e) {
          const t = this.elements;
          const i = e.x;
          const n = e.y;
          const a = e.z;
          t[0] *= i;
          t[4] *= n;
          t[8] *= a;
          t[1] *= i;
          t[5] *= n;
          t[9] *= a;
          t[2] *= i;
          t[6] *= n;
          t[10] *= a;
          t[3] *= i;
          t[7] *= n;
          t[11] *= a;
          return this;
        }
        getMaxScaleOnAxis() {
          const e = this.elements;
          const t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2];
          const i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6];
          const n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, n));
        }
        makeTranslation(e, t, i) {
          this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1);
          return this;
        }
        makeRotationX(e) {
          const t = Math.cos(e);
          const i = Math.sin(e);
          this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationY(e) {
          const t = Math.cos(e);
          const i = Math.sin(e);
          this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e);
          const i = Math.sin(e);
          this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          return this;
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t);
          const n = Math.sin(t);
          const a = 1 - i;
          const r = e.x;
          const s = e.y;
          const o = e.z;
          const l = a * r;
          const c = a * s;
          this.set(l * r + i, l * s - n * o, l * o + n * s, 0, l * s + n * o, c * s + i, c * o - n * r, 0, l * o - n * s, c * o + n * r, a * o * o + i, 0, 0, 0, 0, 1);
          return this;
        }
        makeScale(e, t, i) {
          this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1);
          return this;
        }
        makeShear(e, t, i, n, a, r) {
          this.set(1, i, a, 0, e, 1, r, 0, t, n, 1, 0, 0, 0, 0, 1);
          return this;
        }
        compose(e, t, i) {
          const n = this.elements;
          const a = t._x;
          const r = t._y;
          const s = t._z;
          const o = t._w;
          const l = a + a;
          const c = r + r;
          const h = s + s;
          const d = a * l;
          const u = a * c;
          const p = a * h;
          const m = r * c;
          const f = r * h;
          const g = s * h;
          const _ = o * l;
          const v = o * c;
          const b = o * h;
          const y = i.x;
          const x = i.y;
          const w = i.z;
          n[0] = (1 - (m + g)) * y;
          n[1] = (u + b) * y;
          n[2] = (p - v) * y;
          n[3] = 0;
          n[4] = (u - b) * x;
          n[5] = (1 - (d + g)) * x;
          n[6] = (f + _) * x;
          n[7] = 0;
          n[8] = (p + v) * w;
          n[9] = (f - _) * w;
          n[10] = (1 - (d + m)) * w;
          n[11] = 0;
          n[12] = e.x;
          n[13] = e.y;
          n[14] = e.z;
          n[15] = 1;
          return this;
        }
        decompose(e, t, i) {
          const n = this.elements;
          let a = $i.set(n[0], n[1], n[2]).length();
          const r = $i.set(n[4], n[5], n[6]).length();
          const s = $i.set(n[8], n[9], n[10]).length();
          if (this.determinant() < 0) {
            a = -a;
          }
          e.x = n[12];
          e.y = n[13];
          e.z = n[14];
          zi.copy(this);
          const o = 1 / a;
          const l = 1 / r;
          const c = 1 / s;
          zi.elements[0] *= o;
          zi.elements[1] *= o;
          zi.elements[2] *= o;
          zi.elements[4] *= l;
          zi.elements[5] *= l;
          zi.elements[6] *= l;
          zi.elements[8] *= c;
          zi.elements[9] *= c;
          zi.elements[10] *= c;
          t.setFromRotationMatrix(zi);
          i.x = a;
          i.y = r;
          i.z = s;
          return this;
        }
        makePerspective(e, t, i, n, a, r) {
          const s = this.elements;
          const o = a * 2 / (t - e);
          const l = a * 2 / (i - n);
          const c = (t + e) / (t - e);
          const h = (i + n) / (i - n);
          const d = -(r + a) / (r - a);
          const u = r * -2 * a / (r - a);
          s[0] = o;
          s[4] = 0;
          s[8] = c;
          s[12] = 0;
          s[1] = 0;
          s[5] = l;
          s[9] = h;
          s[13] = 0;
          s[2] = 0;
          s[6] = 0;
          s[10] = d;
          s[14] = u;
          s[3] = 0;
          s[7] = 0;
          s[11] = -1;
          s[15] = 0;
          return this;
        }
        makeOrthographic(e, t, i, n, a, r) {
          const s = this.elements;
          const o = 1 / (t - e);
          const l = 1 / (i - n);
          const c = 1 / (r - a);
          const h = (t + e) * o;
          const d = (i + n) * l;
          const u = (r + a) * c;
          s[0] = o * 2;
          s[4] = 0;
          s[8] = 0;
          s[12] = -h;
          s[1] = 0;
          s[5] = l * 2;
          s[9] = 0;
          s[13] = -d;
          s[2] = 0;
          s[6] = 0;
          s[10] = c * -2;
          s[14] = -u;
          s[3] = 0;
          s[7] = 0;
          s[11] = 0;
          s[15] = 1;
          return this;
        }
        equals(e) {
          const t = this.elements;
          const i = e.elements;
          for (let e = 0; e < 16; e++) {
            if (t[e] !== i[e]) {
              return false;
            }
          }
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) {
            this.elements[i] = e[i + t];
          }
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          e[t] = i[0];
          e[t + 1] = i[1];
          e[t + 2] = i[2];
          e[t + 3] = i[3];
          e[t + 4] = i[4];
          e[t + 5] = i[5];
          e[t + 6] = i[6];
          e[t + 7] = i[7];
          e[t + 8] = i[8];
          e[t + 9] = i[9];
          e[t + 10] = i[10];
          e[t + 11] = i[11];
          e[t + 12] = i[12];
          e[t + 13] = i[13];
          e[t + 14] = i[14];
          e[t + 15] = i[15];
          return e;
        }
      }
      const $i = new ni();
      const zi = new Ii();
      const Ni = new ni(0, 0, 0);
      const Oi = new ni(1, 1, 1);
      const Ui = new ni();
      const Fi = new ni();
      const Bi = new ni();
      const Hi = new Ii();
      const Vi = new ii();
      class Gi {
        constructor(e = 0, t = 0, i = 0, n = Gi.DefaultOrder) {
          this.isEuler = true;
          this._x = e;
          this._y = t;
          this._z = i;
          this._order = n;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e;
          this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e;
          this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e;
          this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          this._order = e;
          this._onChangeCallback();
        }
        set(e, t, i, n = this._order) {
          this._x = e;
          this._y = t;
          this._z = i;
          this._order = n;
          this._onChangeCallback();
          return this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          this._x = e._x;
          this._y = e._y;
          this._z = e._z;
          this._order = e._order;
          this._onChangeCallback();
          return this;
        }
        setFromRotationMatrix(e, t = this._order, i = true) {
          const n = e.elements;
          const a = n[0];
          const r = n[4];
          const s = n[8];
          const o = n[1];
          const l = n[5];
          const c = n[9];
          const h = n[2];
          const d = n[6];
          const u = n[10];
          switch (t) {
            case "XYZ":
              this._y = Math.asin(Et(s, -1, 1));
              if (Math.abs(s) < 0.9999999) {
                this._x = Math.atan2(-c, u);
                this._z = Math.atan2(-r, a);
              } else {
                this._x = Math.atan2(d, l);
                this._z = 0;
              }
              break;
            case "YXZ":
              this._x = Math.asin(-Et(c, -1, 1));
              if (Math.abs(c) < 0.9999999) {
                this._y = Math.atan2(s, u);
                this._z = Math.atan2(o, l);
              } else {
                this._y = Math.atan2(-h, a);
                this._z = 0;
              }
              break;
            case "ZXY":
              this._x = Math.asin(Et(d, -1, 1));
              if (Math.abs(d) < 0.9999999) {
                this._y = Math.atan2(-h, u);
                this._z = Math.atan2(-r, l);
              } else {
                this._y = 0;
                this._z = Math.atan2(o, a);
              }
              break;
            case "ZYX":
              this._y = Math.asin(-Et(h, -1, 1));
              if (Math.abs(h) < 0.9999999) {
                this._x = Math.atan2(d, u);
                this._z = Math.atan2(o, a);
              } else {
                this._x = 0;
                this._z = Math.atan2(-r, l);
              }
              break;
            case "YZX":
              this._z = Math.asin(Et(o, -1, 1));
              if (Math.abs(o) < 0.9999999) {
                this._x = Math.atan2(-c, l);
                this._y = Math.atan2(-h, a);
              } else {
                this._x = 0;
                this._y = Math.atan2(s, u);
              }
              break;
            case "XZY":
              this._z = Math.asin(-Et(r, -1, 1));
              if (Math.abs(r) < 0.9999999) {
                this._x = Math.atan2(d, l);
                this._y = Math.atan2(s, a);
              } else {
                this._x = Math.atan2(-c, u);
                this._y = 0;
              }
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          this._order = t;
          if (i === true) {
            this._onChangeCallback();
          }
          return this;
        }
        setFromQuaternion(e, t, i) {
          Hi.makeRotationFromQuaternion(e);
          return this.setFromRotationMatrix(Hi, t, i);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          Vi.setFromEuler(this);
          return this.setFromQuaternion(Vi, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          this._x = e[0];
          this._y = e[1];
          this._z = e[2];
          if (e[3] !== undefined) {
            this._order = e[3];
          }
          this._onChangeCallback();
          return this;
        }
        toArray(e = [], t = 0) {
          e[t] = this._x;
          e[t + 1] = this._y;
          e[t + 2] = this._z;
          e[t + 3] = this._order;
          return e;
        }
        _onChange(e) {
          this._onChangeCallback = e;
          return this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x;
          yield this._y;
          yield this._z;
          yield this._order;
        }
        toVector3() {
          console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
        }
      }
      Gi.DefaultOrder = "XYZ";
      Gi.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
      class Wi {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = 1 << e >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e;
        }
        disable(e) {
          this.mask &= ~(1 << e);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return !!(this.mask & e.mask);
        }
        isEnabled(e) {
          return !!(this.mask & 1 << e);
        }
      }
      let qi = 0;
      const ji = new ni();
      const Xi = new ii();
      const Ki = new Ii();
      const Yi = new ni();
      const Ji = new ni();
      const Zi = new ni();
      const Qi = new ii();
      const en = new ni(1, 0, 0);
      const tn = new ni(0, 1, 0);
      const nn = new ni(0, 0, 1);
      const an = {
        type: "added"
      };
      const rn = {
        type: "removed"
      };
      class sn extends yt {
        constructor() {
          super();
          this.isObject3D = true;
          Object.defineProperty(this, "id", {
            value: qi++
          });
          this.uuid = St();
          this.name = "";
          this.type = "Object3D";
          this.parent = null;
          this.children = [];
          this.up = sn.DefaultUp.clone();
          const e = new ni();
          const t = new Gi();
          const i = new ii();
          const n = new ni(1, 1, 1);
          t._onChange(function () {
            i.setFromEuler(t, false);
          });
          i._onChange(function () {
            t.setFromQuaternion(i, undefined, false);
          });
          Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: e
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: t
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: n
            },
            modelViewMatrix: {
              value: new Ii()
            },
            normalMatrix: {
              value: new Pt()
            }
          });
          this.matrix = new Ii();
          this.matrixWorld = new Ii();
          this.matrixAutoUpdate = sn.DefaultMatrixAutoUpdate;
          this.matrixWorldNeedsUpdate = false;
          this.matrixWorldAutoUpdate = sn.DefaultMatrixWorldAutoUpdate;
          this.layers = new Wi();
          this.visible = true;
          this.castShadow = false;
          this.receiveShadow = false;
          this.frustumCulled = true;
          this.renderOrder = 0;
          this.animations = [];
          this.userData = {};
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          if (this.matrixAutoUpdate) {
            this.updateMatrix();
          }
          this.matrix.premultiply(e);
          this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          this.quaternion.premultiply(e);
          return this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, true);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          Xi.setFromAxisAngle(e, t);
          this.quaternion.multiply(Xi);
          return this;
        }
        rotateOnWorldAxis(e, t) {
          Xi.setFromAxisAngle(e, t);
          this.quaternion.premultiply(Xi);
          return this;
        }
        rotateX(e) {
          return this.rotateOnAxis(en, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(tn, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(nn, e);
        }
        translateOnAxis(e, t) {
          ji.copy(e).applyQuaternion(this.quaternion);
          this.position.add(ji.multiplyScalar(t));
          return this;
        }
        translateX(e) {
          return this.translateOnAxis(en, e);
        }
        translateY(e) {
          return this.translateOnAxis(tn, e);
        }
        translateZ(e) {
          return this.translateOnAxis(nn, e);
        }
        localToWorld(e) {
          return e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return e.applyMatrix4(Ki.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, i) {
          if (e.isVector3) {
            Yi.copy(e);
          } else {
            Yi.set(e, t, i);
          }
          const n = this.parent;
          this.updateWorldMatrix(true, false);
          Ji.setFromMatrixPosition(this.matrixWorld);
          if (this.isCamera || this.isLight) {
            Ki.lookAt(Ji, Yi, this.up);
          } else {
            Ki.lookAt(Yi, Ji, this.up);
          }
          this.quaternion.setFromRotationMatrix(Ki);
          if (n) {
            Ki.extractRotation(n.matrixWorld);
            Xi.setFromRotationMatrix(Ki);
            this.quaternion.premultiply(Xi.invert());
          }
        }
        add(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) {
              this.add(arguments[e]);
            }
            return this;
          }
          if (e === this) {
            console.error("THREE.Object3D.add: object can't be added as a child of itself.", e);
            return this;
          } else {
            if (e && e.isObject3D) {
              if (e.parent !== null) {
                e.parent.remove(e);
              }
              e.parent = this;
              this.children.push(e);
              e.dispatchEvent(an);
            } else {
              console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e);
            }
            return this;
          }
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) {
              this.remove(arguments[e]);
            }
            return this;
          }
          const t = this.children.indexOf(e);
          if (t !== -1) {
            e.parent = null;
            this.children.splice(t, 1);
            e.dispatchEvent(rn);
          }
          return this;
        }
        removeFromParent() {
          const e = this.parent;
          if (e !== null) {
            e.remove(this);
          }
          return this;
        }
        clear() {
          for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            t.parent = null;
            t.dispatchEvent(rn);
          }
          this.children.length = 0;
          return this;
        }
        attach(e) {
          this.updateWorldMatrix(true, false);
          Ki.copy(this.matrixWorld).invert();
          if (e.parent !== null) {
            e.parent.updateWorldMatrix(true, false);
            Ki.multiply(e.parent.matrixWorld);
          }
          e.applyMatrix4(Ki);
          this.add(e);
          e.updateWorldMatrix(false, true);
          return this;
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) {
            return this;
          }
          for (let i = 0, n = this.children.length; i < n; i++) {
            const n = this.children[i].getObjectByProperty(e, t);
            if (n !== undefined) {
              return n;
            }
          }
        }
        getWorldPosition(e) {
          this.updateWorldMatrix(true, false);
          return e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(Ji, e, Zi);
          return e;
        }
        getWorldScale(e) {
          this.updateWorldMatrix(true, false);
          this.matrixWorld.decompose(Ji, Qi, e);
          return e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(true, false);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) {
            t[i].traverse(e);
          }
        }
        traverseVisible(e) {
          if (this.visible === false) {
            return;
          }
          e(this);
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) {
            t[i].traverseVisible(e);
          }
        }
        traverseAncestors(e) {
          const t = this.parent;
          if (t !== null) {
            e(t);
            t.traverseAncestors(e);
          }
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale);
          this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e) {
          if (this.matrixAutoUpdate) {
            this.updateMatrix();
          }
          if (this.matrixWorldNeedsUpdate || e) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
            this.matrixWorldNeedsUpdate = false;
            e = true;
          }
          const t = this.children;
          for (let i = 0, n = t.length; i < n; i++) {
            const n = t[i];
            if (n.matrixWorldAutoUpdate === true || e === true) {
              n.updateMatrixWorld(e);
            }
          }
        }
        updateWorldMatrix(e, t) {
          const i = this.parent;
          if (e === true && i !== null && i.matrixWorldAutoUpdate === true) {
            i.updateWorldMatrix(true, false);
          }
          if (this.matrixAutoUpdate) {
            this.updateMatrix();
          }
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          if (t === true) {
            const e = this.children;
            for (let t = 0, i = e.length; t < i; t++) {
              const i = e[t];
              if (i.matrixWorldAutoUpdate === true) {
                i.updateWorldMatrix(false, true);
              }
            }
          }
        }
        toJSON(e) {
          const t = e === undefined || typeof e == "string";
          const i = {};
          if (t) {
            e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {}
            };
            i.metadata = {
              version: 4.5,
              type: "Object",
              generator: "Object3D.toJSON"
            };
          }
          const n = {};
          function a(t, i) {
            if (t[i.uuid] === undefined) {
              t[i.uuid] = i.toJSON(e);
            }
            return i.uuid;
          }
          n.uuid = this.uuid;
          n.type = this.type;
          if (this.name !== "") {
            n.name = this.name;
          }
          if (this.castShadow === true) {
            n.castShadow = true;
          }
          if (this.receiveShadow === true) {
            n.receiveShadow = true;
          }
          if (this.visible === false) {
            n.visible = false;
          }
          if (this.frustumCulled === false) {
            n.frustumCulled = false;
          }
          if (this.renderOrder !== 0) {
            n.renderOrder = this.renderOrder;
          }
          if (JSON.stringify(this.userData) !== "{}") {
            n.userData = this.userData;
          }
          n.layers = this.layers.mask;
          n.matrix = this.matrix.toArray();
          if (this.matrixAutoUpdate === false) {
            n.matrixAutoUpdate = false;
          }
          if (this.isInstancedMesh) {
            n.type = "InstancedMesh";
            n.count = this.count;
            n.instanceMatrix = this.instanceMatrix.toJSON();
            if (this.instanceColor !== null) {
              n.instanceColor = this.instanceColor.toJSON();
            }
          }
          if (this.isScene) {
            if (this.background) {
              if (this.background.isColor) {
                n.background = this.background.toJSON();
              } else if (this.background.isTexture) {
                n.background = this.background.toJSON(e).uuid;
              }
            }
            if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
              n.environment = this.environment.toJSON(e).uuid;
            }
          } else if (this.isMesh || this.isLine || this.isPoints) {
            n.geometry = a(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (t !== undefined && t.shapes !== undefined) {
              const i = t.shapes;
              if (Array.isArray(i)) {
                for (let t = 0, n = i.length; t < n; t++) {
                  const n = i[t];
                  a(e.shapes, n);
                }
              } else {
                a(e.shapes, i);
              }
            }
          }
          if (this.isSkinnedMesh) {
            n.bindMode = this.bindMode;
            n.bindMatrix = this.bindMatrix.toArray();
            if (this.skeleton !== undefined) {
              a(e.skeletons, this.skeleton);
              n.skeleton = this.skeleton.uuid;
            }
          }
          if (this.material !== undefined) {
            if (Array.isArray(this.material)) {
              const t = [];
              for (let i = 0, n = this.material.length; i < n; i++) {
                t.push(a(e.materials, this.material[i]));
              }
              n.material = t;
            } else {
              n.material = a(e.materials, this.material);
            }
          }
          if (this.children.length > 0) {
            n.children = [];
            for (let t = 0; t < this.children.length; t++) {
              n.children.push(this.children[t].toJSON(e).object);
            }
          }
          if (this.animations.length > 0) {
            n.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
              const i = this.animations[t];
              n.animations.push(a(e.animations, i));
            }
          }
          if (t) {
            const t = r(e.geometries);
            const n = r(e.materials);
            const a = r(e.textures);
            const s = r(e.images);
            const o = r(e.shapes);
            const l = r(e.skeletons);
            const c = r(e.animations);
            const h = r(e.nodes);
            if (t.length > 0) {
              i.geometries = t;
            }
            if (n.length > 0) {
              i.materials = n;
            }
            if (a.length > 0) {
              i.textures = a;
            }
            if (s.length > 0) {
              i.images = s;
            }
            if (o.length > 0) {
              i.shapes = o;
            }
            if (l.length > 0) {
              i.skeletons = l;
            }
            if (c.length > 0) {
              i.animations = c;
            }
            if (h.length > 0) {
              i.nodes = h;
            }
          }
          i.object = n;
          return i;
          function r(e) {
            const t = [];
            for (const i in e) {
              const n = e[i];
              delete n.metadata;
              t.push(n);
            }
            return t;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = true) {
          this.name = e.name;
          this.up.copy(e.up);
          this.position.copy(e.position);
          this.rotation.order = e.rotation.order;
          this.quaternion.copy(e.quaternion);
          this.scale.copy(e.scale);
          this.matrix.copy(e.matrix);
          this.matrixWorld.copy(e.matrixWorld);
          this.matrixAutoUpdate = e.matrixAutoUpdate;
          this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate;
          this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate;
          this.layers.mask = e.layers.mask;
          this.visible = e.visible;
          this.castShadow = e.castShadow;
          this.receiveShadow = e.receiveShadow;
          this.frustumCulled = e.frustumCulled;
          this.renderOrder = e.renderOrder;
          this.userData = JSON.parse(JSON.stringify(e.userData));
          if (t === true) {
            for (let t = 0; t < e.children.length; t++) {
              const i = e.children[t];
              this.add(i.clone());
            }
          }
          return this;
        }
      }
      sn.DefaultUp = new ni(0, 1, 0);
      sn.DefaultMatrixAutoUpdate = true;
      sn.DefaultMatrixWorldAutoUpdate = true;
      const on = new ni();
      const ln = new ni();
      const cn = new ni();
      const hn = new ni();
      const dn = new ni();
      const un = new ni();
      const pn = new ni();
      const mn = new ni();
      const fn = new ni();
      const gn = new ni();
      class _n {
        constructor(e = new ni(), t = new ni(), i = new ni()) {
          this.a = e;
          this.b = t;
          this.c = i;
        }
        static getNormal(e, t, i, n) {
          n.subVectors(i, t);
          on.subVectors(e, t);
          n.cross(on);
          const a = n.lengthSq();
          if (a > 0) {
            return n.multiplyScalar(1 / Math.sqrt(a));
          } else {
            return n.set(0, 0, 0);
          }
        }
        static getBarycoord(e, t, i, n, a) {
          on.subVectors(n, t);
          ln.subVectors(i, t);
          cn.subVectors(e, t);
          const r = on.dot(on);
          const s = on.dot(ln);
          const o = on.dot(cn);
          const l = ln.dot(ln);
          const c = ln.dot(cn);
          const h = r * l - s * s;
          if (h === 0) {
            return a.set(-2, -1, -1);
          }
          const d = 1 / h;
          const u = (l * o - s * c) * d;
          const p = (r * c - s * o) * d;
          return a.set(1 - u - p, p, u);
        }
        static containsPoint(e, t, i, n) {
          this.getBarycoord(e, t, i, n, hn);
          return hn.x >= 0 && hn.y >= 0 && hn.x + hn.y <= 1;
        }
        static getUV(e, t, i, n, a, r, s, o) {
          this.getBarycoord(e, t, i, n, hn);
          o.set(0, 0);
          o.addScaledVector(a, hn.x);
          o.addScaledVector(r, hn.y);
          o.addScaledVector(s, hn.z);
          return o;
        }
        static isFrontFacing(e, t, i, n) {
          on.subVectors(i, t);
          ln.subVectors(e, t);
          return on.cross(ln).dot(n) < 0;
        }
        set(e, t, i) {
          this.a.copy(e);
          this.b.copy(t);
          this.c.copy(i);
          return this;
        }
        setFromPointsAndIndices(e, t, i, n) {
          this.a.copy(e[t]);
          this.b.copy(e[i]);
          this.c.copy(e[n]);
          return this;
        }
        setFromAttributeAndIndices(e, t, i, n) {
          this.a.fromBufferAttribute(e, t);
          this.b.fromBufferAttribute(e, i);
          this.c.fromBufferAttribute(e, n);
          return this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.a.copy(e.a);
          this.b.copy(e.b);
          this.c.copy(e.c);
          return this;
        }
        getArea() {
          on.subVectors(this.c, this.b);
          ln.subVectors(this.a, this.b);
          return on.cross(ln).length() * 0.5;
        }
        getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return _n.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return _n.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getUV(e, t, i, n, a) {
          return _n.getUV(e, this.a, this.b, this.c, t, i, n, a);
        }
        containsPoint(e) {
          return _n.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return _n.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a;
          const n = this.b;
          const a = this.c;
          let r;
          let s;
          dn.subVectors(n, i);
          un.subVectors(a, i);
          mn.subVectors(e, i);
          const o = dn.dot(mn);
          const l = un.dot(mn);
          if (o <= 0 && l <= 0) {
            return t.copy(i);
          }
          fn.subVectors(e, n);
          const c = dn.dot(fn);
          const h = un.dot(fn);
          if (c >= 0 && h <= c) {
            return t.copy(n);
          }
          const d = o * h - c * l;
          if (d <= 0 && o >= 0 && c <= 0) {
            r = o / (o - c);
            return t.copy(i).addScaledVector(dn, r);
          }
          gn.subVectors(e, a);
          const u = dn.dot(gn);
          const p = un.dot(gn);
          if (p >= 0 && u <= p) {
            return t.copy(a);
          }
          const m = u * l - o * p;
          if (m <= 0 && l >= 0 && p <= 0) {
            s = l / (l - p);
            return t.copy(i).addScaledVector(un, s);
          }
          const f = c * p - u * h;
          if (f <= 0 && h - c >= 0 && u - p >= 0) {
            pn.subVectors(a, n);
            s = (h - c) / (h - c + (u - p));
            return t.copy(n).addScaledVector(pn, s);
          }
          const g = 1 / (f + m + d);
          r = m * g;
          s = d * g;
          return t.copy(i).addScaledVector(dn, r).addScaledVector(un, s);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      let vn = 0;
      class bn extends yt {
        constructor() {
          super();
          this.isMaterial = true;
          Object.defineProperty(this, "id", {
            value: vn++
          });
          this.uuid = St();
          this.name = "";
          this.type = "Material";
          this.blending = p;
          this.side = c;
          this.vertexColors = false;
          this.opacity = 1;
          this.transparent = false;
          this.blendSrc = C;
          this.blendDst = k;
          this.blendEquation = v;
          this.blendSrcAlpha = null;
          this.blendDstAlpha = null;
          this.blendEquationAlpha = null;
          this.depthFunc = O;
          this.depthTest = true;
          this.depthWrite = true;
          this.stencilWriteMask = 255;
          this.stencilFunc = 519;
          this.stencilRef = 0;
          this.stencilFuncMask = 255;
          this.stencilFail = _t;
          this.stencilZFail = _t;
          this.stencilZPass = _t;
          this.stencilWrite = false;
          this.clippingPlanes = null;
          this.clipIntersection = false;
          this.clipShadows = false;
          this.shadowSide = null;
          this.colorWrite = true;
          this.precision = null;
          this.polygonOffset = false;
          this.polygonOffsetFactor = 0;
          this.polygonOffsetUnits = 0;
          this.dithering = false;
          this.alphaToCoverage = false;
          this.premultipliedAlpha = false;
          this.visible = true;
          this.toneMapped = true;
          this.userData = {};
          this.version = 0;
          this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          if (this._alphaTest > 0 != e > 0) {
            this.version++;
          }
          this._alphaTest = e;
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== undefined) {
            for (const t in e) {
              const i = e[t];
              if (i === undefined) {
                console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                continue;
              }
              const n = this[t];
              if (n !== undefined) {
                if (n && n.isColor) {
                  n.set(i);
                } else if (n && n.isVector3 && i && i.isVector3) {
                  n.copy(i);
                } else {
                  this[t] = i;
                }
              } else {
                console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.");
              }
            }
          }
        }
        toJSON(e) {
          const t = e === undefined || typeof e == "string";
          if (t) {
            e = {
              textures: {},
              images: {}
            };
          }
          const i = {
            metadata: {
              version: 4.5,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          function n(e) {
            const t = [];
            for (const i in e) {
              const n = e[i];
              delete n.metadata;
              t.push(n);
            }
            return t;
          }
          i.uuid = this.uuid;
          i.type = this.type;
          if (this.name !== "") {
            i.name = this.name;
          }
          if (this.color && this.color.isColor) {
            i.color = this.color.getHex();
          }
          if (this.roughness !== undefined) {
            i.roughness = this.roughness;
          }
          if (this.metalness !== undefined) {
            i.metalness = this.metalness;
          }
          if (this.sheen !== undefined) {
            i.sheen = this.sheen;
          }
          if (this.sheenColor && this.sheenColor.isColor) {
            i.sheenColor = this.sheenColor.getHex();
          }
          if (this.sheenRoughness !== undefined) {
            i.sheenRoughness = this.sheenRoughness;
          }
          if (this.emissive && this.emissive.isColor) {
            i.emissive = this.emissive.getHex();
          }
          if (this.emissiveIntensity && this.emissiveIntensity !== 1) {
            i.emissiveIntensity = this.emissiveIntensity;
          }
          if (this.specular && this.specular.isColor) {
            i.specular = this.specular.getHex();
          }
          if (this.specularIntensity !== undefined) {
            i.specularIntensity = this.specularIntensity;
          }
          if (this.specularColor && this.specularColor.isColor) {
            i.specularColor = this.specularColor.getHex();
          }
          if (this.shininess !== undefined) {
            i.shininess = this.shininess;
          }
          if (this.clearcoat !== undefined) {
            i.clearcoat = this.clearcoat;
          }
          if (this.clearcoatRoughness !== undefined) {
            i.clearcoatRoughness = this.clearcoatRoughness;
          }
          if (this.clearcoatMap && this.clearcoatMap.isTexture) {
            i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid;
          }
          if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
            i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid;
          }
          if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
            i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid;
            i.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
          }
          if (this.iridescence !== undefined) {
            i.iridescence = this.iridescence;
          }
          if (this.iridescenceIOR !== undefined) {
            i.iridescenceIOR = this.iridescenceIOR;
          }
          if (this.iridescenceThicknessRange !== undefined) {
            i.iridescenceThicknessRange = this.iridescenceThicknessRange;
          }
          if (this.iridescenceMap && this.iridescenceMap.isTexture) {
            i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid;
          }
          if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
            i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid;
          }
          if (this.map && this.map.isTexture) {
            i.map = this.map.toJSON(e).uuid;
          }
          if (this.matcap && this.matcap.isTexture) {
            i.matcap = this.matcap.toJSON(e).uuid;
          }
          if (this.alphaMap && this.alphaMap.isTexture) {
            i.alphaMap = this.alphaMap.toJSON(e).uuid;
          }
          if (this.lightMap && this.lightMap.isTexture) {
            i.lightMap = this.lightMap.toJSON(e).uuid;
            i.lightMapIntensity = this.lightMapIntensity;
          }
          if (this.aoMap && this.aoMap.isTexture) {
            i.aoMap = this.aoMap.toJSON(e).uuid;
            i.aoMapIntensity = this.aoMapIntensity;
          }
          if (this.bumpMap && this.bumpMap.isTexture) {
            i.bumpMap = this.bumpMap.toJSON(e).uuid;
            i.bumpScale = this.bumpScale;
          }
          if (this.normalMap && this.normalMap.isTexture) {
            i.normalMap = this.normalMap.toJSON(e).uuid;
            i.normalMapType = this.normalMapType;
            i.normalScale = this.normalScale.toArray();
          }
          if (this.displacementMap && this.displacementMap.isTexture) {
            i.displacementMap = this.displacementMap.toJSON(e).uuid;
            i.displacementScale = this.displacementScale;
            i.displacementBias = this.displacementBias;
          }
          if (this.roughnessMap && this.roughnessMap.isTexture) {
            i.roughnessMap = this.roughnessMap.toJSON(e).uuid;
          }
          if (this.metalnessMap && this.metalnessMap.isTexture) {
            i.metalnessMap = this.metalnessMap.toJSON(e).uuid;
          }
          if (this.emissiveMap && this.emissiveMap.isTexture) {
            i.emissiveMap = this.emissiveMap.toJSON(e).uuid;
          }
          if (this.specularMap && this.specularMap.isTexture) {
            i.specularMap = this.specularMap.toJSON(e).uuid;
          }
          if (this.specularIntensityMap && this.specularIntensityMap.isTexture) {
            i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid;
          }
          if (this.specularColorMap && this.specularColorMap.isTexture) {
            i.specularColorMap = this.specularColorMap.toJSON(e).uuid;
          }
          if (this.envMap && this.envMap.isTexture) {
            i.envMap = this.envMap.toJSON(e).uuid;
            if (this.combine !== undefined) {
              i.combine = this.combine;
            }
          }
          if (this.envMapIntensity !== undefined) {
            i.envMapIntensity = this.envMapIntensity;
          }
          if (this.reflectivity !== undefined) {
            i.reflectivity = this.reflectivity;
          }
          if (this.refractionRatio !== undefined) {
            i.refractionRatio = this.refractionRatio;
          }
          if (this.gradientMap && this.gradientMap.isTexture) {
            i.gradientMap = this.gradientMap.toJSON(e).uuid;
          }
          if (this.transmission !== undefined) {
            i.transmission = this.transmission;
          }
          if (this.transmissionMap && this.transmissionMap.isTexture) {
            i.transmissionMap = this.transmissionMap.toJSON(e).uuid;
          }
          if (this.thickness !== undefined) {
            i.thickness = this.thickness;
          }
          if (this.thicknessMap && this.thicknessMap.isTexture) {
            i.thicknessMap = this.thicknessMap.toJSON(e).uuid;
          }
          if (this.attenuationDistance !== undefined) {
            i.attenuationDistance = this.attenuationDistance;
          }
          if (this.attenuationColor !== undefined) {
            i.attenuationColor = this.attenuationColor.getHex();
          }
          if (this.size !== undefined) {
            i.size = this.size;
          }
          if (this.shadowSide !== null) {
            i.shadowSide = this.shadowSide;
          }
          if (this.sizeAttenuation !== undefined) {
            i.sizeAttenuation = this.sizeAttenuation;
          }
          if (this.blending !== p) {
            i.blending = this.blending;
          }
          if (this.side !== c) {
            i.side = this.side;
          }
          if (this.vertexColors) {
            i.vertexColors = true;
          }
          if (this.opacity < 1) {
            i.opacity = this.opacity;
          }
          if (this.transparent === true) {
            i.transparent = this.transparent;
          }
          i.depthFunc = this.depthFunc;
          i.depthTest = this.depthTest;
          i.depthWrite = this.depthWrite;
          i.colorWrite = this.colorWrite;
          i.stencilWrite = this.stencilWrite;
          i.stencilWriteMask = this.stencilWriteMask;
          i.stencilFunc = this.stencilFunc;
          i.stencilRef = this.stencilRef;
          i.stencilFuncMask = this.stencilFuncMask;
          i.stencilFail = this.stencilFail;
          i.stencilZFail = this.stencilZFail;
          i.stencilZPass = this.stencilZPass;
          if (this.rotation !== undefined && this.rotation !== 0) {
            i.rotation = this.rotation;
          }
          if (this.polygonOffset === true) {
            i.polygonOffset = true;
          }
          if (this.polygonOffsetFactor !== 0) {
            i.polygonOffsetFactor = this.polygonOffsetFactor;
          }
          if (this.polygonOffsetUnits !== 0) {
            i.polygonOffsetUnits = this.polygonOffsetUnits;
          }
          if (this.linewidth !== undefined && this.linewidth !== 1) {
            i.linewidth = this.linewidth;
          }
          if (this.dashSize !== undefined) {
            i.dashSize = this.dashSize;
          }
          if (this.gapSize !== undefined) {
            i.gapSize = this.gapSize;
          }
          if (this.scale !== undefined) {
            i.scale = this.scale;
          }
          if (this.dithering === true) {
            i.dithering = true;
          }
          if (this.alphaTest > 0) {
            i.alphaTest = this.alphaTest;
          }
          if (this.alphaToCoverage === true) {
            i.alphaToCoverage = this.alphaToCoverage;
          }
          if (this.premultipliedAlpha === true) {
            i.premultipliedAlpha = this.premultipliedAlpha;
          }
          if (this.wireframe === true) {
            i.wireframe = this.wireframe;
          }
          if (this.wireframeLinewidth > 1) {
            i.wireframeLinewidth = this.wireframeLinewidth;
          }
          if (this.wireframeLinecap !== "round") {
            i.wireframeLinecap = this.wireframeLinecap;
          }
          if (this.wireframeLinejoin !== "round") {
            i.wireframeLinejoin = this.wireframeLinejoin;
          }
          if (this.flatShading === true) {
            i.flatShading = this.flatShading;
          }
          if (this.visible === false) {
            i.visible = false;
          }
          if (this.toneMapped === false) {
            i.toneMapped = false;
          }
          if (this.fog === false) {
            i.fog = false;
          }
          if (JSON.stringify(this.userData) !== "{}") {
            i.userData = this.userData;
          }
          if (t) {
            const t = n(e.textures);
            const a = n(e.images);
            if (t.length > 0) {
              i.textures = t;
            }
            if (a.length > 0) {
              i.images = a;
            }
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name;
          this.blending = e.blending;
          this.side = e.side;
          this.vertexColors = e.vertexColors;
          this.opacity = e.opacity;
          this.transparent = e.transparent;
          this.blendSrc = e.blendSrc;
          this.blendDst = e.blendDst;
          this.blendEquation = e.blendEquation;
          this.blendSrcAlpha = e.blendSrcAlpha;
          this.blendDstAlpha = e.blendDstAlpha;
          this.blendEquationAlpha = e.blendEquationAlpha;
          this.depthFunc = e.depthFunc;
          this.depthTest = e.depthTest;
          this.depthWrite = e.depthWrite;
          this.stencilWriteMask = e.stencilWriteMask;
          this.stencilFunc = e.stencilFunc;
          this.stencilRef = e.stencilRef;
          this.stencilFuncMask = e.stencilFuncMask;
          this.stencilFail = e.stencilFail;
          this.stencilZFail = e.stencilZFail;
          this.stencilZPass = e.stencilZPass;
          this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let i = null;
          if (t !== null) {
            const e = t.length;
            i = new Array(e);
            for (let n = 0; n !== e; ++n) {
              i[n] = t[n].clone();
            }
          }
          this.clippingPlanes = i;
          this.clipIntersection = e.clipIntersection;
          this.clipShadows = e.clipShadows;
          this.shadowSide = e.shadowSide;
          this.colorWrite = e.colorWrite;
          this.precision = e.precision;
          this.polygonOffset = e.polygonOffset;
          this.polygonOffsetFactor = e.polygonOffsetFactor;
          this.polygonOffsetUnits = e.polygonOffsetUnits;
          this.dithering = e.dithering;
          this.alphaTest = e.alphaTest;
          this.alphaToCoverage = e.alphaToCoverage;
          this.premultipliedAlpha = e.premultipliedAlpha;
          this.visible = e.visible;
          this.toneMapped = e.toneMapped;
          this.userData = JSON.parse(JSON.stringify(e.userData));
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(e) {
          if (e === true) {
            this.version++;
          }
        }
      }
      class yn extends bn {
        constructor(e) {
          super();
          this.isMeshBasicMaterial = true;
          this.type = "MeshBasicMaterial";
          this.color = new Wt(16777215);
          this.map = null;
          this.lightMap = null;
          this.lightMapIntensity = 1;
          this.aoMap = null;
          this.aoMapIntensity = 1;
          this.specularMap = null;
          this.alphaMap = null;
          this.envMap = null;
          this.combine = V;
          this.reflectivity = 1;
          this.refractionRatio = 0.98;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.wireframeLinecap = "round";
          this.wireframeLinejoin = "round";
          this.fog = true;
          this.setValues(e);
        }
        copy(e) {
          super.copy(e);
          this.color.copy(e.color);
          this.map = e.map;
          this.lightMap = e.lightMap;
          this.lightMapIntensity = e.lightMapIntensity;
          this.aoMap = e.aoMap;
          this.aoMapIntensity = e.aoMapIntensity;
          this.specularMap = e.specularMap;
          this.alphaMap = e.alphaMap;
          this.envMap = e.envMap;
          this.combine = e.combine;
          this.reflectivity = e.reflectivity;
          this.refractionRatio = e.refractionRatio;
          this.wireframe = e.wireframe;
          this.wireframeLinewidth = e.wireframeLinewidth;
          this.wireframeLinecap = e.wireframeLinecap;
          this.wireframeLinejoin = e.wireframeLinejoin;
          this.fog = e.fog;
          return this;
        }
      }
      const xn = new ni();
      const wn = new Rt();
      class Mn {
        constructor(e, t, i) {
          if (Array.isArray(e)) {
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          }
          this.isBufferAttribute = true;
          this.name = "";
          this.array = e;
          this.itemSize = t;
          this.count = e !== undefined ? e.length / t : 0;
          this.normalized = i === true;
          this.usage = 35044;
          this.updateRange = {
            offset: 0,
            count: -1
          };
          this.version = 0;
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          if (e === true) {
            this.version++;
          }
        }
        setUsage(e) {
          this.usage = e;
          return this;
        }
        copy(e) {
          this.name = e.name;
          this.array = new e.array.constructor(e.array);
          this.itemSize = e.itemSize;
          this.count = e.count;
          this.normalized = e.normalized;
          this.usage = e.usage;
          return this;
        }
        copyAt(e, t, i) {
          e *= this.itemSize;
          i *= t.itemSize;
          for (let n = 0, a = this.itemSize; n < a; n++) {
            this.array[e + n] = t.array[i + n];
          }
          return this;
        }
        copyArray(e) {
          this.array.set(e);
          return this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2) {
            for (let t = 0, i = this.count; t < i; t++) {
              wn.fromBufferAttribute(this, t);
              wn.applyMatrix3(e);
              this.setXY(t, wn.x, wn.y);
            }
          } else if (this.itemSize === 3) {
            for (let t = 0, i = this.count; t < i; t++) {
              xn.fromBufferAttribute(this, t);
              xn.applyMatrix3(e);
              this.setXYZ(t, xn.x, xn.y, xn.z);
            }
          }
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++) {
            xn.fromBufferAttribute(this, t);
            xn.applyMatrix4(e);
            this.setXYZ(t, xn.x, xn.y, xn.z);
          }
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) {
            xn.fromBufferAttribute(this, t);
            xn.applyNormalMatrix(e);
            this.setXYZ(t, xn.x, xn.y, xn.z);
          }
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) {
            xn.fromBufferAttribute(this, t);
            xn.transformDirection(e);
            this.setXYZ(t, xn.x, xn.y, xn.z);
          }
          return this;
        }
        set(e, t = 0) {
          this.array.set(e, t);
          return this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          if (this.normalized) {
            t = At(t, this.array);
          }
          return t;
        }
        setX(e, t) {
          if (this.normalized) {
            t = Lt(t, this.array);
          }
          this.array[e * this.itemSize] = t;
          return this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          if (this.normalized) {
            t = At(t, this.array);
          }
          return t;
        }
        setY(e, t) {
          if (this.normalized) {
            t = Lt(t, this.array);
          }
          this.array[e * this.itemSize + 1] = t;
          return this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          if (this.normalized) {
            t = At(t, this.array);
          }
          return t;
        }
        setZ(e, t) {
          if (this.normalized) {
            t = Lt(t, this.array);
          }
          this.array[e * this.itemSize + 2] = t;
          return this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          if (this.normalized) {
            t = At(t, this.array);
          }
          return t;
        }
        setW(e, t) {
          if (this.normalized) {
            t = Lt(t, this.array);
          }
          this.array[e * this.itemSize + 3] = t;
          return this;
        }
        setXY(e, t, i) {
          e *= this.itemSize;
          if (this.normalized) {
            t = Lt(t, this.array);
            i = Lt(i, this.array);
          }
          this.array[e + 0] = t;
          this.array[e + 1] = i;
          return this;
        }
        setXYZ(e, t, i, n) {
          e *= this.itemSize;
          if (this.normalized) {
            t = Lt(t, this.array);
            i = Lt(i, this.array);
            n = Lt(n, this.array);
          }
          this.array[e + 0] = t;
          this.array[e + 1] = i;
          this.array[e + 2] = n;
          return this;
        }
        setXYZW(e, t, i, n, a) {
          e *= this.itemSize;
          if (this.normalized) {
            t = Lt(t, this.array);
            i = Lt(i, this.array);
            n = Lt(n, this.array);
            a = Lt(a, this.array);
          }
          this.array[e + 0] = t;
          this.array[e + 1] = i;
          this.array[e + 2] = n;
          this.array[e + 3] = a;
          return this;
        }
        onUpload(e) {
          this.onUploadCallback = e;
          return this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          if (this.name !== "") {
            e.name = this.name;
          }
          if (this.usage !== 35044) {
            e.usage = this.usage;
          }
          if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) {
            e.updateRange = this.updateRange;
          }
          return e;
        }
        copyColorsArray() {
          console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
        }
        copyVector2sArray() {
          console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
        }
        copyVector3sArray() {
          console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
        }
        copyVector4sArray() {
          console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
        }
      }
      class Sn extends Mn {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class En extends Mn {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Tn extends Mn {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let Cn = 0;
      const kn = new Ii();
      const An = new sn();
      const Ln = new ni();
      const Rn = new si();
      const Pn = new si();
      const Dn = new ni();
      class In extends yt {
        constructor() {
          super();
          this.isBufferGeometry = true;
          Object.defineProperty(this, "id", {
            value: Cn++
          });
          this.uuid = St();
          this.name = "";
          this.type = "BufferGeometry";
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.morphTargetsRelative = false;
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          this.drawRange = {
            start: 0,
            count: Infinity
          };
          this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          if (Array.isArray(e)) {
            this.index = new (Dt(e) ? En : Sn)(e, 1);
          } else {
            this.index = e;
          }
          return this;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          this.attributes[e] = t;
          return this;
        }
        deleteAttribute(e) {
          delete this.attributes[e];
          return this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== undefined;
        }
        addGroup(e, t, i = 0) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          this.drawRange.start = e;
          this.drawRange.count = t;
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          if (t !== undefined) {
            t.applyMatrix4(e);
            t.needsUpdate = true;
          }
          const i = this.attributes.normal;
          if (i !== undefined) {
            const t = new Pt().getNormalMatrix(e);
            i.applyNormalMatrix(t);
            i.needsUpdate = true;
          }
          const n = this.attributes.tangent;
          if (n !== undefined) {
            n.transformDirection(e);
            n.needsUpdate = true;
          }
          if (this.boundingBox !== null) {
            this.computeBoundingBox();
          }
          if (this.boundingSphere !== null) {
            this.computeBoundingSphere();
          }
          return this;
        }
        applyQuaternion(e) {
          kn.makeRotationFromQuaternion(e);
          this.applyMatrix4(kn);
          return this;
        }
        rotateX(e) {
          kn.makeRotationX(e);
          this.applyMatrix4(kn);
          return this;
        }
        rotateY(e) {
          kn.makeRotationY(e);
          this.applyMatrix4(kn);
          return this;
        }
        rotateZ(e) {
          kn.makeRotationZ(e);
          this.applyMatrix4(kn);
          return this;
        }
        translate(e, t, i) {
          kn.makeTranslation(e, t, i);
          this.applyMatrix4(kn);
          return this;
        }
        scale(e, t, i) {
          kn.makeScale(e, t, i);
          this.applyMatrix4(kn);
          return this;
        }
        lookAt(e) {
          An.lookAt(e);
          An.updateMatrix();
          this.applyMatrix4(An.matrix);
          return this;
        }
        center() {
          this.computeBoundingBox();
          this.boundingBox.getCenter(Ln).negate();
          this.translate(Ln.x, Ln.y, Ln.z);
          return this;
        }
        setFromPoints(e) {
          const t = [];
          for (let i = 0, n = e.length; i < n; i++) {
            const n = e[i];
            t.push(n.x, n.y, n.z || 0);
          }
          this.setAttribute("position", new Tn(t, 3));
          return this;
        }
        computeBoundingBox() {
          if (this.boundingBox === null) {
            this.boundingBox = new si();
          }
          const e = this.attributes.position;
          const t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".", this);
            this.boundingBox.set(new ni(-Infinity, -Infinity, -Infinity), new ni(Infinity, Infinity, Infinity));
            return;
          }
          if (e !== undefined) {
            this.boundingBox.setFromBufferAttribute(e);
            if (t) {
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                Rn.setFromBufferAttribute(i);
                if (this.morphTargetsRelative) {
                  Dn.addVectors(this.boundingBox.min, Rn.min);
                  this.boundingBox.expandByPoint(Dn);
                  Dn.addVectors(this.boundingBox.max, Rn.max);
                  this.boundingBox.expandByPoint(Dn);
                } else {
                  this.boundingBox.expandByPoint(Rn.min);
                  this.boundingBox.expandByPoint(Rn.max);
                }
              }
            }
          } else {
            this.boundingBox.makeEmpty();
          }
          if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.", this);
          }
        }
        computeBoundingSphere() {
          if (this.boundingSphere === null) {
            this.boundingSphere = new Ei();
          }
          const e = this.attributes.position;
          const t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".", this);
            this.boundingSphere.set(new ni(), Infinity);
            return;
          }
          if (e) {
            const i = this.boundingSphere.center;
            Rn.setFromBufferAttribute(e);
            if (t) {
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e];
                Pn.setFromBufferAttribute(i);
                if (this.morphTargetsRelative) {
                  Dn.addVectors(Rn.min, Pn.min);
                  Rn.expandByPoint(Dn);
                  Dn.addVectors(Rn.max, Pn.max);
                  Rn.expandByPoint(Dn);
                } else {
                  Rn.expandByPoint(Pn.min);
                  Rn.expandByPoint(Pn.max);
                }
              }
            }
            Rn.getCenter(i);
            let n = 0;
            for (let t = 0, a = e.count; t < a; t++) {
              Dn.fromBufferAttribute(e, t);
              n = Math.max(n, i.distanceToSquared(Dn));
            }
            if (t) {
              for (let a = 0, r = t.length; a < r; a++) {
                const r = t[a];
                const s = this.morphTargetsRelative;
                for (let t = 0, a = r.count; t < a; t++) {
                  Dn.fromBufferAttribute(r, t);
                  if (s) {
                    Ln.fromBufferAttribute(e, t);
                    Dn.add(Ln);
                  }
                  n = Math.max(n, i.distanceToSquared(Dn));
                }
              }
            }
            this.boundingSphere.radius = Math.sqrt(n);
            if (isNaN(this.boundingSphere.radius)) {
              console.error("THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.", this);
            }
          }
        }
        computeTangents() {
          const e = this.index;
          const t = this.attributes;
          if (e === null || t.position === undefined || t.normal === undefined || t.uv === undefined) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = e.array;
          const n = t.position.array;
          const a = t.normal.array;
          const r = t.uv.array;
          const s = n.length / 3;
          if (this.hasAttribute("tangent") === false) {
            this.setAttribute("tangent", new Mn(new Float32Array(s * 4), 4));
          }
          const o = this.getAttribute("tangent").array;
          const l = [];
          const c = [];
          for (let e = 0; e < s; e++) {
            l[e] = new ni();
            c[e] = new ni();
          }
          const h = new ni();
          const d = new ni();
          const u = new ni();
          const p = new Rt();
          const m = new Rt();
          const f = new Rt();
          const g = new ni();
          const _ = new ni();
          function v(e, t, i) {
            h.fromArray(n, e * 3);
            d.fromArray(n, t * 3);
            u.fromArray(n, i * 3);
            p.fromArray(r, e * 2);
            m.fromArray(r, t * 2);
            f.fromArray(r, i * 2);
            d.sub(h);
            u.sub(h);
            m.sub(p);
            f.sub(p);
            const a = 1 / (m.x * f.y - f.x * m.y);
            if (isFinite(a)) {
              g.copy(d).multiplyScalar(f.y).addScaledVector(u, -m.y).multiplyScalar(a);
              _.copy(u).multiplyScalar(m.x).addScaledVector(d, -f.x).multiplyScalar(a);
              l[e].add(g);
              l[t].add(g);
              l[i].add(g);
              c[e].add(_);
              c[t].add(_);
              c[i].add(_);
            }
          }
          let b = this.groups;
          if (b.length === 0) {
            b = [{
              start: 0,
              count: i.length
            }];
          }
          for (let e = 0, t = b.length; e < t; ++e) {
            const t = b[e];
            const n = t.start;
            for (let e = n, a = n + t.count; e < a; e += 3) {
              v(i[e + 0], i[e + 1], i[e + 2]);
            }
          }
          const y = new ni();
          const x = new ni();
          const w = new ni();
          const M = new ni();
          function S(e) {
            w.fromArray(a, e * 3);
            M.copy(w);
            const t = l[e];
            y.copy(t);
            y.sub(w.multiplyScalar(w.dot(t))).normalize();
            x.crossVectors(M, t);
            const i = x.dot(c[e]) < 0 ? -1 : 1;
            o[e * 4] = y.x;
            o[e * 4 + 1] = y.y;
            o[e * 4 + 2] = y.z;
            o[e * 4 + 3] = i;
          }
          for (let e = 0, t = b.length; e < t; ++e) {
            const t = b[e];
            const n = t.start;
            for (let e = n, a = n + t.count; e < a; e += 3) {
              S(i[e + 0]);
              S(i[e + 1]);
              S(i[e + 2]);
            }
          }
        }
        computeVertexNormals() {
          const e = this.index;
          const t = this.getAttribute("position");
          if (t !== undefined) {
            let i = this.getAttribute("normal");
            if (i === undefined) {
              i = new Mn(new Float32Array(t.count * 3), 3);
              this.setAttribute("normal", i);
            } else {
              for (let e = 0, t = i.count; e < t; e++) {
                i.setXYZ(e, 0, 0, 0);
              }
            }
            const n = new ni();
            const a = new ni();
            const r = new ni();
            const s = new ni();
            const o = new ni();
            const l = new ni();
            const c = new ni();
            const h = new ni();
            if (e) {
              for (let d = 0, u = e.count; d < u; d += 3) {
                const u = e.getX(d + 0);
                const p = e.getX(d + 1);
                const m = e.getX(d + 2);
                n.fromBufferAttribute(t, u);
                a.fromBufferAttribute(t, p);
                r.fromBufferAttribute(t, m);
                c.subVectors(r, a);
                h.subVectors(n, a);
                c.cross(h);
                s.fromBufferAttribute(i, u);
                o.fromBufferAttribute(i, p);
                l.fromBufferAttribute(i, m);
                s.add(c);
                o.add(c);
                l.add(c);
                i.setXYZ(u, s.x, s.y, s.z);
                i.setXYZ(p, o.x, o.y, o.z);
                i.setXYZ(m, l.x, l.y, l.z);
              }
            } else {
              for (let e = 0, s = t.count; e < s; e += 3) {
                n.fromBufferAttribute(t, e + 0);
                a.fromBufferAttribute(t, e + 1);
                r.fromBufferAttribute(t, e + 2);
                c.subVectors(r, a);
                h.subVectors(n, a);
                c.cross(h);
                i.setXYZ(e + 0, c.x, c.y, c.z);
                i.setXYZ(e + 1, c.x, c.y, c.z);
                i.setXYZ(e + 2, c.x, c.y, c.z);
              }
            }
            this.normalizeNormals();
            i.needsUpdate = true;
          }
        }
        merge() {
          console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.");
          return this;
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++) {
            Dn.fromBufferAttribute(e, t);
            Dn.normalize();
            e.setXYZ(t, Dn.x, Dn.y, Dn.z);
          }
        }
        toNonIndexed() {
          function e(e, t) {
            const i = e.array;
            const n = e.itemSize;
            const a = e.normalized;
            const r = new i.constructor(t.length * n);
            let s = 0;
            let o = 0;
            for (let a = 0, l = t.length; a < l; a++) {
              s = e.isInterleavedBufferAttribute ? t[a] * e.data.stride + e.offset : t[a] * n;
              for (let e = 0; e < n; e++) {
                r[o++] = i[s++];
              }
            }
            return new Mn(r, n, a);
          }
          if (this.index === null) {
            console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
            return this;
          }
          const t = new In();
          const i = this.index.array;
          const n = this.attributes;
          for (const a in n) {
            const r = e(n[a], i);
            t.setAttribute(a, r);
          }
          const a = this.morphAttributes;
          for (const n in a) {
            const r = [];
            const s = a[n];
            for (let t = 0, n = s.length; t < n; t++) {
              const n = e(s[t], i);
              r.push(n);
            }
            t.morphAttributes[n] = r;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const r = this.groups;
          for (let e = 0, i = r.length; e < i; e++) {
            const i = r[e];
            t.addGroup(i.start, i.count, i.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.5,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          e.uuid = this.uuid;
          e.type = this.type;
          if (this.name !== "") {
            e.name = this.name;
          }
          if (Object.keys(this.userData).length > 0) {
            e.userData = this.userData;
          }
          if (this.parameters !== undefined) {
            const t = this.parameters;
            for (const i in t) {
              if (t[i] !== undefined) {
                e[i] = t[i];
              }
            }
            return e;
          }
          e.data = {
            attributes: {}
          };
          const t = this.index;
          if (t !== null) {
            e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array)
            };
          }
          const i = this.attributes;
          for (const t in i) {
            const n = i[t];
            e.data.attributes[t] = n.toJSON(e.data);
          }
          const n = {};
          let a = false;
          for (const t in this.morphAttributes) {
            const i = this.morphAttributes[t];
            const r = [];
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              r.push(n.toJSON(e.data));
            }
            if (r.length > 0) {
              n[t] = r;
              a = true;
            }
          }
          if (a) {
            e.data.morphAttributes = n;
            e.data.morphTargetsRelative = this.morphTargetsRelative;
          }
          const r = this.groups;
          if (r.length > 0) {
            e.data.groups = JSON.parse(JSON.stringify(r));
          }
          const s = this.boundingSphere;
          if (s !== null) {
            e.data.boundingSphere = {
              center: s.center.toArray(),
              radius: s.radius
            };
          }
          return e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.index = null;
          this.attributes = {};
          this.morphAttributes = {};
          this.groups = [];
          this.boundingBox = null;
          this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const i = e.index;
          if (i !== null) {
            this.setIndex(i.clone(t));
          }
          const n = e.attributes;
          for (const e in n) {
            const i = n[e];
            this.setAttribute(e, i.clone(t));
          }
          const a = e.morphAttributes;
          for (const e in a) {
            const i = [];
            const n = a[e];
            for (let e = 0, a = n.length; e < a; e++) {
              i.push(n[e].clone(t));
            }
            this.morphAttributes[e] = i;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const r = e.groups;
          for (let e = 0, t = r.length; e < t; e++) {
            const t = r[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const s = e.boundingBox;
          if (s !== null) {
            this.boundingBox = s.clone();
          }
          const o = e.boundingSphere;
          if (o !== null) {
            this.boundingSphere = o.clone();
          }
          this.drawRange.start = e.drawRange.start;
          this.drawRange.count = e.drawRange.count;
          this.userData = e.userData;
          if (e.parameters !== undefined) {
            this.parameters = Object.assign({}, e.parameters);
          }
          return this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const $n = new Ii();
      const zn = new Di();
      const Nn = new Ei();
      const On = new ni();
      const Un = new ni();
      const Fn = new ni();
      const Bn = new ni();
      const Hn = new ni();
      const Vn = new ni();
      const Gn = new ni();
      const Wn = new ni();
      const qn = new ni();
      const jn = new Rt();
      const Xn = new Rt();
      const Kn = new Rt();
      const Yn = new ni();
      const Jn = new ni();
      class Zn extends sn {
        constructor(e = new In(), t = new yn()) {
          super();
          this.isMesh = true;
          this.type = "Mesh";
          this.geometry = e;
          this.material = t;
          this.updateMorphTargets();
        }
        copy(e, t) {
          super.copy(e, t);
          if (e.morphTargetInfluences !== undefined) {
            this.morphTargetInfluences = e.morphTargetInfluences.slice();
          }
          if (e.morphTargetDictionary !== undefined) {
            this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary);
          }
          this.material = e.material;
          this.geometry = e.geometry;
          return this;
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes;
          const t = Object.keys(e);
          if (t.length > 0) {
            const i = e[t[0]];
            if (i !== undefined) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let e = 0, t = i.length; e < t; e++) {
                const t = i[e].name || String(e);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[t] = e;
              }
            }
          }
        }
        raycast(e, t) {
          const i = this.geometry;
          const n = this.material;
          const a = this.matrixWorld;
          if (n === undefined) {
            return;
          }
          if (i.boundingSphere === null) {
            i.computeBoundingSphere();
          }
          Nn.copy(i.boundingSphere);
          Nn.applyMatrix4(a);
          if (e.ray.intersectsSphere(Nn) === false) {
            return;
          }
          $n.copy(a).invert();
          zn.copy(e.ray).applyMatrix4($n);
          if (i.boundingBox !== null && zn.intersectsBox(i.boundingBox) === false) {
            return;
          }
          let r;
          const s = i.index;
          const o = i.attributes.position;
          const l = i.morphAttributes.position;
          const c = i.morphTargetsRelative;
          const h = i.attributes.uv;
          const d = i.attributes.uv2;
          const u = i.groups;
          const p = i.drawRange;
          if (s !== null) {
            if (Array.isArray(n)) {
              for (let i = 0, a = u.length; i < a; i++) {
                const a = u[i];
                const m = n[a.materialIndex];
                for (let i = Math.max(a.start, p.start), n = Math.min(s.count, Math.min(a.start + a.count, p.start + p.count)); i < n; i += 3) {
                  const n = s.getX(i);
                  const u = s.getX(i + 1);
                  const p = s.getX(i + 2);
                  r = Qn(this, m, e, zn, o, l, c, h, d, n, u, p);
                  if (r) {
                    r.faceIndex = Math.floor(i / 3);
                    r.face.materialIndex = a.materialIndex;
                    t.push(r);
                  }
                }
              }
            } else {
              for (let i = Math.max(0, p.start), a = Math.min(s.count, p.start + p.count); i < a; i += 3) {
                const a = s.getX(i);
                const u = s.getX(i + 1);
                const p = s.getX(i + 2);
                r = Qn(this, n, e, zn, o, l, c, h, d, a, u, p);
                if (r) {
                  r.faceIndex = Math.floor(i / 3);
                  t.push(r);
                }
              }
            }
          } else if (o !== undefined) {
            if (Array.isArray(n)) {
              for (let i = 0, a = u.length; i < a; i++) {
                const a = u[i];
                const s = n[a.materialIndex];
                for (let i = Math.max(a.start, p.start), n = Math.min(o.count, Math.min(a.start + a.count, p.start + p.count)); i < n; i += 3) {
                  r = Qn(this, s, e, zn, o, l, c, h, d, i, i + 1, i + 2);
                  if (r) {
                    r.faceIndex = Math.floor(i / 3);
                    r.face.materialIndex = a.materialIndex;
                    t.push(r);
                  }
                }
              }
            } else {
              for (let i = Math.max(0, p.start), a = Math.min(o.count, p.start + p.count); i < a; i += 3) {
                r = Qn(this, n, e, zn, o, l, c, h, d, i, i + 1, i + 2);
                if (r) {
                  r.faceIndex = Math.floor(i / 3);
                  t.push(r);
                }
              }
            }
          }
        }
      }
      function Qn(e, t, i, n, a, r, s, o, l, c, u, p) {
        On.fromBufferAttribute(a, c);
        Un.fromBufferAttribute(a, u);
        Fn.fromBufferAttribute(a, p);
        const m = e.morphTargetInfluences;
        if (r && m) {
          Gn.set(0, 0, 0);
          Wn.set(0, 0, 0);
          qn.set(0, 0, 0);
          for (let e = 0, t = r.length; e < t; e++) {
            const t = m[e];
            const i = r[e];
            if (t !== 0) {
              Bn.fromBufferAttribute(i, c);
              Hn.fromBufferAttribute(i, u);
              Vn.fromBufferAttribute(i, p);
              if (s) {
                Gn.addScaledVector(Bn, t);
                Wn.addScaledVector(Hn, t);
                qn.addScaledVector(Vn, t);
              } else {
                Gn.addScaledVector(Bn.sub(On), t);
                Wn.addScaledVector(Hn.sub(Un), t);
                qn.addScaledVector(Vn.sub(Fn), t);
              }
            }
          }
          On.add(Gn);
          Un.add(Wn);
          Fn.add(qn);
        }
        if (e.isSkinnedMesh) {
          e.boneTransform(c, On);
          e.boneTransform(u, Un);
          e.boneTransform(p, Fn);
        }
        const f = function (e, t, i, n, a, r, s, o) {
          let l;
          l = t.side === h ? n.intersectTriangle(s, r, a, true, o) : n.intersectTriangle(a, r, s, t.side !== d, o);
          if (l === null) {
            return null;
          }
          Jn.copy(o);
          Jn.applyMatrix4(e.matrixWorld);
          const c = i.ray.origin.distanceTo(Jn);
          if (c < i.near || c > i.far) {
            return null;
          } else {
            return {
              distance: c,
              point: Jn.clone(),
              object: e
            };
          }
        }(e, t, i, n, On, Un, Fn, Yn);
        if (f) {
          if (o) {
            jn.fromBufferAttribute(o, c);
            Xn.fromBufferAttribute(o, u);
            Kn.fromBufferAttribute(o, p);
            f.uv = _n.getUV(Yn, On, Un, Fn, jn, Xn, Kn, new Rt());
          }
          if (l) {
            jn.fromBufferAttribute(l, c);
            Xn.fromBufferAttribute(l, u);
            Kn.fromBufferAttribute(l, p);
            f.uv2 = _n.getUV(Yn, On, Un, Fn, jn, Xn, Kn, new Rt());
          }
          const e = {
            a: c,
            b: u,
            c: p,
            normal: new ni(),
            materialIndex: 0
          };
          _n.getNormal(On, Un, Fn, e.normal);
          f.face = e;
        }
        return f;
      }
      class ea extends In {
        constructor(e = 1, t = 1, i = 1, n = 1, a = 1, r = 1) {
          super();
          this.type = "BoxGeometry";
          this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: a,
            depthSegments: r
          };
          const s = this;
          n = Math.floor(n);
          a = Math.floor(a);
          r = Math.floor(r);
          const o = [];
          const l = [];
          const c = [];
          const h = [];
          let d = 0;
          let u = 0;
          function p(e, t, i, n, a, r, p, m, f, g, _) {
            const v = r / f;
            const b = p / g;
            const y = r / 2;
            const x = p / 2;
            const w = m / 2;
            const M = f + 1;
            const S = g + 1;
            let E = 0;
            let T = 0;
            const C = new ni();
            for (let r = 0; r < S; r++) {
              const s = r * b - x;
              for (let o = 0; o < M; o++) {
                const d = o * v - y;
                C[e] = d * n;
                C[t] = s * a;
                C[i] = w;
                l.push(C.x, C.y, C.z);
                C[e] = 0;
                C[t] = 0;
                C[i] = m > 0 ? 1 : -1;
                c.push(C.x, C.y, C.z);
                h.push(o / f);
                h.push(1 - r / g);
                E += 1;
              }
            }
            for (let e = 0; e < g; e++) {
              for (let t = 0; t < f; t++) {
                const i = d + t + M * e;
                const n = d + t + M * (e + 1);
                const a = d + (t + 1) + M * (e + 1);
                const r = d + (t + 1) + M * e;
                o.push(i, n, r);
                o.push(n, a, r);
                T += 6;
              }
            }
            s.addGroup(u, T, _);
            u += T;
            d += E;
          }
          p("z", "y", "x", -1, -1, i, t, e, r, a, 0);
          p("z", "y", "x", 1, -1, i, t, -e, r, a, 1);
          p("x", "z", "y", 1, 1, e, i, t, n, r, 2);
          p("x", "z", "y", 1, -1, e, i, -t, n, r, 3);
          p("x", "y", "z", 1, -1, e, t, i, n, a, 4);
          p("x", "y", "z", -1, -1, e, t, -i, n, a, 5);
          this.setIndex(o);
          this.setAttribute("position", new Tn(l, 3));
          this.setAttribute("normal", new Tn(c, 3));
          this.setAttribute("uv", new Tn(h, 2));
        }
        static fromJSON(e) {
          return new ea(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function ta(e) {
        const t = {};
        for (const i in e) {
          t[i] = {};
          for (const n in e[i]) {
            const a = e[i][n];
            if (a && (a.isColor || a.isMatrix3 || a.isMatrix4 || a.isVector2 || a.isVector3 || a.isVector4 || a.isTexture || a.isQuaternion)) {
              t[i][n] = a.clone();
            } else if (Array.isArray(a)) {
              t[i][n] = a.slice();
            } else {
              t[i][n] = a;
            }
          }
        }
        return t;
      }
      function ia(e) {
        const t = {};
        for (let i = 0; i < e.length; i++) {
          const n = ta(e[i]);
          for (const e in n) {
            t[e] = n[e];
          }
        }
        return t;
      }
      const na = {
        clone: ta,
        merge: ia
      };
      class aa extends bn {
        constructor(e) {
          super();
          this.isShaderMaterial = true;
          this.type = "ShaderMaterial";
          this.defines = {};
          this.uniforms = {};
          this.uniformsGroups = [];
          this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
          this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
          this.linewidth = 1;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.fog = false;
          this.lights = false;
          this.clipping = false;
          this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
          };
          this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
          };
          this.index0AttributeName = undefined;
          this.uniformsNeedUpdate = false;
          this.glslVersion = null;
          if (e !== undefined) {
            this.setValues(e);
          }
        }
        copy(e) {
          super.copy(e);
          this.fragmentShader = e.fragmentShader;
          this.vertexShader = e.vertexShader;
          this.uniforms = ta(e.uniforms);
          this.uniformsGroups = function (e) {
            const t = [];
            for (let i = 0; i < e.length; i++) {
              t.push(e[i].clone());
            }
            return t;
          }(e.uniformsGroups);
          this.defines = Object.assign({}, e.defines);
          this.wireframe = e.wireframe;
          this.wireframeLinewidth = e.wireframeLinewidth;
          this.fog = e.fog;
          this.lights = e.lights;
          this.clipping = e.clipping;
          this.extensions = Object.assign({}, e.extensions);
          this.glslVersion = e.glslVersion;
          return this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion;
          t.uniforms = {};
          for (const i in this.uniforms) {
            const n = this.uniforms[i].value;
            if (n && n.isTexture) {
              t.uniforms[i] = {
                type: "t",
                value: n.toJSON(e).uuid
              };
            } else if (n && n.isColor) {
              t.uniforms[i] = {
                type: "c",
                value: n.getHex()
              };
            } else if (n && n.isVector2) {
              t.uniforms[i] = {
                type: "v2",
                value: n.toArray()
              };
            } else if (n && n.isVector3) {
              t.uniforms[i] = {
                type: "v3",
                value: n.toArray()
              };
            } else if (n && n.isVector4) {
              t.uniforms[i] = {
                type: "v4",
                value: n.toArray()
              };
            } else if (n && n.isMatrix3) {
              t.uniforms[i] = {
                type: "m3",
                value: n.toArray()
              };
            } else if (n && n.isMatrix4) {
              t.uniforms[i] = {
                type: "m4",
                value: n.toArray()
              };
            } else {
              t.uniforms[i] = {
                value: n
              };
            }
          }
          if (Object.keys(this.defines).length > 0) {
            t.defines = this.defines;
          }
          t.vertexShader = this.vertexShader;
          t.fragmentShader = this.fragmentShader;
          const i = {};
          for (const e in this.extensions) {
            if (this.extensions[e] === true) {
              i[e] = true;
            }
          }
          if (Object.keys(i).length > 0) {
            t.extensions = i;
          }
          return t;
        }
      }
      class ra extends sn {
        constructor() {
          super();
          this.isCamera = true;
          this.type = "Camera";
          this.matrixWorldInverse = new Ii();
          this.projectionMatrix = new Ii();
          this.projectionMatrixInverse = new Ii();
        }
        copy(e, t) {
          super.copy(e, t);
          this.matrixWorldInverse.copy(e.matrixWorldInverse);
          this.projectionMatrix.copy(e.projectionMatrix);
          this.projectionMatrixInverse.copy(e.projectionMatrixInverse);
          return this;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(true, false);
          const t = this.matrixWorld.elements;
          return e.set(-t[8], -t[9], -t[10]).normalize();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t);
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class sa extends ra {
        constructor(e = 50, t = 1, i = 0.1, n = 2000) {
          super();
          this.isPerspectiveCamera = true;
          this.type = "PerspectiveCamera";
          this.fov = e;
          this.zoom = 1;
          this.near = i;
          this.far = n;
          this.focus = 10;
          this.aspect = t;
          this.view = null;
          this.filmGauge = 35;
          this.filmOffset = 0;
          this.updateProjectionMatrix();
        }
        copy(e, t) {
          super.copy(e, t);
          this.fov = e.fov;
          this.zoom = e.zoom;
          this.near = e.near;
          this.far = e.far;
          this.focus = e.focus;
          this.aspect = e.aspect;
          this.view = e.view === null ? null : Object.assign({}, e.view);
          this.filmGauge = e.filmGauge;
          this.filmOffset = e.filmOffset;
          return this;
        }
        setFocalLength(e) {
          const t = this.getFilmHeight() * 0.5 / e;
          this.fov = Mt * 2 * Math.atan(t);
          this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(wt * 0.5 * this.fov);
          return this.getFilmHeight() * 0.5 / e;
        }
        getEffectiveFOV() {
          return Mt * 2 * Math.atan(Math.tan(wt * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(e, t, i, n, a, r) {
          this.aspect = e / t;
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = e;
          this.view.fullHeight = t;
          this.view.offsetX = i;
          this.view.offsetY = n;
          this.view.width = a;
          this.view.height = r;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(wt * 0.5 * this.fov) / this.zoom;
          let i = t * 2;
          let n = this.aspect * i;
          let a = n * -0.5;
          const r = this.view;
          if (this.view !== null && this.view.enabled) {
            const e = r.fullWidth;
            const s = r.fullHeight;
            a += r.offsetX * n / e;
            t -= r.offsetY * i / s;
            n *= r.width / e;
            i *= r.height / s;
          }
          const s = this.filmOffset;
          if (s !== 0) {
            a += e * s / this.getFilmWidth();
          }
          this.projectionMatrix.makePerspective(a, a + n, t, t - i, e, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.object.fov = this.fov;
          t.object.zoom = this.zoom;
          t.object.near = this.near;
          t.object.far = this.far;
          t.object.focus = this.focus;
          t.object.aspect = this.aspect;
          if (this.view !== null) {
            t.object.view = Object.assign({}, this.view);
          }
          t.object.filmGauge = this.filmGauge;
          t.object.filmOffset = this.filmOffset;
          return t;
        }
      }
      const oa = 90;
      class la extends sn {
        constructor(e, t, i) {
          super();
          this.type = "CubeCamera";
          this.renderTarget = i;
          const n = new sa(oa, 1, e, t);
          n.layers = this.layers;
          n.up.set(0, -1, 0);
          n.lookAt(new ni(1, 0, 0));
          this.add(n);
          const a = new sa(oa, 1, e, t);
          a.layers = this.layers;
          a.up.set(0, -1, 0);
          a.lookAt(new ni(-1, 0, 0));
          this.add(a);
          const r = new sa(oa, 1, e, t);
          r.layers = this.layers;
          r.up.set(0, 0, 1);
          r.lookAt(new ni(0, 1, 0));
          this.add(r);
          const s = new sa(oa, 1, e, t);
          s.layers = this.layers;
          s.up.set(0, 0, -1);
          s.lookAt(new ni(0, -1, 0));
          this.add(s);
          const o = new sa(oa, 1, e, t);
          o.layers = this.layers;
          o.up.set(0, -1, 0);
          o.lookAt(new ni(0, 0, 1));
          this.add(o);
          const l = new sa(oa, 1, e, t);
          l.layers = this.layers;
          l.up.set(0, -1, 0);
          l.lookAt(new ni(0, 0, -1));
          this.add(l);
        }
        update(e, t) {
          if (this.parent === null) {
            this.updateMatrixWorld();
          }
          const i = this.renderTarget;
          const [n, a, r, s, o, l] = this.children;
          const c = e.getRenderTarget();
          const h = e.toneMapping;
          const d = e.xr.enabled;
          e.toneMapping = q;
          e.xr.enabled = false;
          const u = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false;
          e.setRenderTarget(i, 0);
          e.render(t, n);
          e.setRenderTarget(i, 1);
          e.render(t, a);
          e.setRenderTarget(i, 2);
          e.render(t, r);
          e.setRenderTarget(i, 3);
          e.render(t, s);
          e.setRenderTarget(i, 4);
          e.render(t, o);
          i.texture.generateMipmaps = u;
          e.setRenderTarget(i, 5);
          e.render(t, l);
          e.setRenderTarget(c);
          e.toneMapping = h;
          e.xr.enabled = d;
          i.texture.needsPMREMUpdate = true;
        }
      }
      class ca extends Jt {
        constructor(e, t, i, n, a, r, s, o, l, c) {
          super(e = e !== undefined ? e : [], t = t !== undefined ? t : Z, i, n, a, r, s, o, l, c);
          this.isCubeTexture = true;
          this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class ha extends Qt {
        constructor(e, t = {}) {
          super(e, e, t);
          this.isWebGLCubeRenderTarget = true;
          const i = {
            width: e,
            height: e,
            depth: 1
          };
          const n = [i, i, i, i, i, i];
          this.texture = new ca(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.encoding);
          this.texture.isRenderTargetTexture = true;
          this.texture.generateMipmaps = t.generateMipmaps !== undefined && t.generateMipmaps;
          this.texture.minFilter = t.minFilter !== undefined ? t.minFilter : ce;
        }
        fromEquirectangularTexture(e, t) {
          this.texture.type = t.type;
          this.texture.encoding = t.encoding;
          this.texture.generateMipmaps = t.generateMipmaps;
          this.texture.minFilter = t.minFilter;
          this.texture.magFilter = t.magFilter;
          const i = {
            tEquirect: {
              value: null
            }
          };
          const n = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t";
          const a = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t";
          const r = new ea(5, 5, 5);
          const s = new aa({
            name: "CubemapFromEquirect",
            uniforms: ta(i),
            vertexShader: n,
            fragmentShader: a,
            side: h,
            blending: u
          });
          s.uniforms.tEquirect.value = t;
          const o = new Zn(r, s);
          const l = t.minFilter;
          if (t.minFilter === de) {
            t.minFilter = ce;
          }
          new la(1, 10, this).update(e, o);
          t.minFilter = l;
          o.geometry.dispose();
          o.material.dispose();
          return this;
        }
        clear(e, t, i, n) {
          const a = e.getRenderTarget();
          for (let a = 0; a < 6; a++) {
            e.setRenderTarget(this, a);
            e.clear(t, i, n);
          }
          e.setRenderTarget(a);
        }
      }
      const da = new ni();
      const ua = new ni();
      const pa = new Pt();
      class ma {
        constructor(e = new ni(1, 0, 0), t = 0) {
          this.isPlane = true;
          this.normal = e;
          this.constant = t;
        }
        set(e, t) {
          this.normal.copy(e);
          this.constant = t;
          return this;
        }
        setComponents(e, t, i, n) {
          this.normal.set(e, t, i);
          this.constant = n;
          return this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          this.normal.copy(e);
          this.constant = -t.dot(this.normal);
          return this;
        }
        setFromCoplanarPoints(e, t, i) {
          const n = da.subVectors(i, t).cross(ua.subVectors(e, t)).normalize();
          this.setFromNormalAndCoplanarPoint(n, e);
          return this;
        }
        copy(e) {
          this.normal.copy(e.normal);
          this.constant = e.constant;
          return this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          this.normal.multiplyScalar(e);
          this.constant *= e;
          return this;
        }
        negate() {
          this.constant *= -1;
          this.normal.negate();
          return this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e);
        }
        intersectLine(e, t) {
          const i = e.delta(da);
          const n = this.normal.dot(i);
          if (n === 0) {
            if (this.distanceToPoint(e.start) === 0) {
              return t.copy(e.start);
            } else {
              return null;
            }
          }
          const a = -(e.start.dot(this.normal) + this.constant) / n;
          if (a < 0 || a > 1) {
            return null;
          } else {
            return t.copy(i).multiplyScalar(a).add(e.start);
          }
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start);
          const i = this.distanceToPoint(e.end);
          return t < 0 && i > 0 || i < 0 && t > 0;
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || pa.getNormalMatrix(e);
          const n = this.coplanarPoint(da).applyMatrix4(e);
          const a = this.normal.applyMatrix3(i).normalize();
          this.constant = -n.dot(a);
          return this;
        }
        translate(e) {
          this.constant -= e.dot(this.normal);
          return this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const fa = new Ei();
      const ga = new ni();
      class _a {
        constructor(e = new ma(), t = new ma(), i = new ma(), n = new ma(), a = new ma(), r = new ma()) {
          this.planes = [e, t, i, n, a, r];
        }
        set(e, t, i, n, a, r) {
          const s = this.planes;
          s[0].copy(e);
          s[1].copy(t);
          s[2].copy(i);
          s[3].copy(n);
          s[4].copy(a);
          s[5].copy(r);
          return this;
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            t[i].copy(e.planes[i]);
          }
          return this;
        }
        setFromProjectionMatrix(e) {
          const t = this.planes;
          const i = e.elements;
          const n = i[0];
          const a = i[1];
          const r = i[2];
          const s = i[3];
          const o = i[4];
          const l = i[5];
          const c = i[6];
          const h = i[7];
          const d = i[8];
          const u = i[9];
          const p = i[10];
          const m = i[11];
          const f = i[12];
          const g = i[13];
          const _ = i[14];
          const v = i[15];
          t[0].setComponents(s - n, h - o, m - d, v - f).normalize();
          t[1].setComponents(s + n, h + o, m + d, v + f).normalize();
          t[2].setComponents(s + a, h + l, m + u, v + g).normalize();
          t[3].setComponents(s - a, h - l, m - u, v - g).normalize();
          t[4].setComponents(s - r, h - c, m - p, v - _).normalize();
          t[5].setComponents(s + r, h + c, m + p, v + _).normalize();
          return this;
        }
        intersectsObject(e) {
          const t = e.geometry;
          if (t.boundingSphere === null) {
            t.computeBoundingSphere();
          }
          fa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          return this.intersectsSphere(fa);
        }
        intersectsSprite(e) {
          fa.center.set(0, 0, 0);
          fa.radius = 0.7071067811865476;
          fa.applyMatrix4(e.matrixWorld);
          return this.intersectsSphere(fa);
        }
        intersectsSphere(e) {
          const t = this.planes;
          const i = e.center;
          const n = -e.radius;
          for (let e = 0; e < 6; e++) {
            if (t[e].distanceToPoint(i) < n) {
              return false;
            }
          }
          return true;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const n = t[i];
            ga.x = n.normal.x > 0 ? e.max.x : e.min.x;
            ga.y = n.normal.y > 0 ? e.max.y : e.min.y;
            ga.z = n.normal.z > 0 ? e.max.z : e.min.z;
            if (n.distanceToPoint(ga) < 0) {
              return false;
            }
          }
          return true;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            if (t[i].distanceToPoint(e) < 0) {
              return false;
            }
          }
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function va() {
        let e = null;
        let t = false;
        let i = null;
        let n = null;
        function a(t, r) {
          i(t, r);
          n = e.requestAnimationFrame(a);
        }
        return {
          start: function () {
            if (t !== true && i !== null) {
              n = e.requestAnimationFrame(a);
              t = true;
            }
          },
          stop: function () {
            e.cancelAnimationFrame(n);
            t = false;
          },
          setAnimationLoop: function (e) {
            i = e;
          },
          setContext: function (t) {
            e = t;
          }
        };
      }
      function ba(e, t) {
        const i = t.isWebGL2;
        const n = new WeakMap();
        return {
          get: function (e) {
            if (e.isInterleavedBufferAttribute) {
              e = e.data;
            }
            return n.get(e);
          },
          remove: function (t) {
            if (t.isInterleavedBufferAttribute) {
              t = t.data;
            }
            const i = n.get(t);
            if (i) {
              e.deleteBuffer(i.buffer);
              n.delete(t);
            }
          },
          update: function (t, a) {
            if (t.isGLBufferAttribute) {
              const e = n.get(t);
              if (!e || e.version < t.version) {
                n.set(t, {
                  buffer: t.buffer,
                  type: t.type,
                  bytesPerElement: t.elementSize,
                  version: t.version
                });
              }
              return;
            }
            if (t.isInterleavedBufferAttribute) {
              t = t.data;
            }
            const r = n.get(t);
            if (r === undefined) {
              n.set(t, function (t, n) {
                const a = t.array;
                const r = t.usage;
                const s = e.createBuffer();
                let o;
                e.bindBuffer(n, s);
                e.bufferData(n, a, r);
                t.onUploadCallback();
                if (a instanceof Float32Array) {
                  o = 5126;
                } else if (a instanceof Uint16Array) {
                  if (t.isFloat16BufferAttribute) {
                    if (!i) {
                      throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                    }
                    o = 5131;
                  } else {
                    o = 5123;
                  }
                } else if (a instanceof Int16Array) {
                  o = 5122;
                } else if (a instanceof Uint32Array) {
                  o = 5125;
                } else if (a instanceof Int32Array) {
                  o = 5124;
                } else if (a instanceof Int8Array) {
                  o = 5120;
                } else if (a instanceof Uint8Array) {
                  o = 5121;
                } else {
                  if (!(a instanceof Uint8ClampedArray)) {
                    throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + a);
                  }
                  o = 5121;
                }
                return {
                  buffer: s,
                  type: o,
                  bytesPerElement: a.BYTES_PER_ELEMENT,
                  version: t.version
                };
              }(t, a));
            } else if (r.version < t.version) {
              (function (t, n, a) {
                const r = n.array;
                const s = n.updateRange;
                e.bindBuffer(a, t);
                if (s.count === -1) {
                  e.bufferSubData(a, 0, r);
                } else {
                  if (i) {
                    e.bufferSubData(a, s.offset * r.BYTES_PER_ELEMENT, r, s.offset, s.count);
                  } else {
                    e.bufferSubData(a, s.offset * r.BYTES_PER_ELEMENT, r.subarray(s.offset, s.offset + s.count));
                  }
                  s.count = -1;
                }
              })(r.buffer, t, a);
              r.version = t.version;
            }
          }
        };
      }
      class ya extends In {
        constructor(e = 1, t = 1, i = 1, n = 1) {
          super();
          this.type = "PlaneGeometry";
          this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
          };
          const a = e / 2;
          const r = t / 2;
          const s = Math.floor(i);
          const o = Math.floor(n);
          const l = s + 1;
          const c = o + 1;
          const h = e / s;
          const d = t / o;
          const u = [];
          const p = [];
          const m = [];
          const f = [];
          for (let e = 0; e < c; e++) {
            const t = e * d - r;
            for (let i = 0; i < l; i++) {
              const n = i * h - a;
              p.push(n, -t, 0);
              m.push(0, 0, 1);
              f.push(i / s);
              f.push(1 - e / o);
            }
          }
          for (let e = 0; e < o; e++) {
            for (let t = 0; t < s; t++) {
              const i = t + l * e;
              const n = t + l * (e + 1);
              const a = t + 1 + l * (e + 1);
              const r = t + 1 + l * e;
              u.push(i, n, r);
              u.push(n, a, r);
            }
          }
          this.setIndex(u);
          this.setAttribute("position", new Tn(p, 3));
          this.setAttribute("normal", new Tn(m, 3));
          this.setAttribute("uv", new Tn(f, 2));
        }
        static fromJSON(e) {
          return new ya(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const xa = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
        iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
        lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
        output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_COORDS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
        transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
      };
      const wa = {
        common: {
          diffuse: {
            value: new Wt(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          uvTransform: {
            value: new Pt()
          },
          uv2Transform: {
            value: new Pt()
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalScale: {
            value: new Rt(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 0.00025
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2000
          },
          fogColor: {
            value: new Wt(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Wt(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Pt()
          }
        },
        sprite: {
          diffuse: {
            value: new Wt(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new Rt(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new Pt()
          }
        }
      };
      const Ma = {
        basic: {
          uniforms: ia([wa.common, wa.specularmap, wa.envmap, wa.aomap, wa.lightmap, wa.fog]),
          vertexShader: xa.meshbasic_vert,
          fragmentShader: xa.meshbasic_frag
        },
        lambert: {
          uniforms: ia([wa.common, wa.specularmap, wa.envmap, wa.aomap, wa.lightmap, wa.emissivemap, wa.bumpmap, wa.normalmap, wa.displacementmap, wa.fog, wa.lights, {
            emissive: {
              value: new Wt(0)
            }
          }]),
          vertexShader: xa.meshlambert_vert,
          fragmentShader: xa.meshlambert_frag
        },
        phong: {
          uniforms: ia([wa.common, wa.specularmap, wa.envmap, wa.aomap, wa.lightmap, wa.emissivemap, wa.bumpmap, wa.normalmap, wa.displacementmap, wa.fog, wa.lights, {
            emissive: {
              value: new Wt(0)
            },
            specular: {
              value: new Wt(1118481)
            },
            shininess: {
              value: 30
            }
          }]),
          vertexShader: xa.meshphong_vert,
          fragmentShader: xa.meshphong_frag
        },
        standard: {
          uniforms: ia([wa.common, wa.envmap, wa.aomap, wa.lightmap, wa.emissivemap, wa.bumpmap, wa.normalmap, wa.displacementmap, wa.roughnessmap, wa.metalnessmap, wa.fog, wa.lights, {
            emissive: {
              value: new Wt(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }]),
          vertexShader: xa.meshphysical_vert,
          fragmentShader: xa.meshphysical_frag
        },
        toon: {
          uniforms: ia([wa.common, wa.aomap, wa.lightmap, wa.emissivemap, wa.bumpmap, wa.normalmap, wa.displacementmap, wa.gradientmap, wa.fog, wa.lights, {
            emissive: {
              value: new Wt(0)
            }
          }]),
          vertexShader: xa.meshtoon_vert,
          fragmentShader: xa.meshtoon_frag
        },
        matcap: {
          uniforms: ia([wa.common, wa.bumpmap, wa.normalmap, wa.displacementmap, wa.fog, {
            matcap: {
              value: null
            }
          }]),
          vertexShader: xa.meshmatcap_vert,
          fragmentShader: xa.meshmatcap_frag
        },
        points: {
          uniforms: ia([wa.points, wa.fog]),
          vertexShader: xa.points_vert,
          fragmentShader: xa.points_frag
        },
        dashed: {
          uniforms: ia([wa.common, wa.fog, {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }]),
          vertexShader: xa.linedashed_vert,
          fragmentShader: xa.linedashed_frag
        },
        depth: {
          uniforms: ia([wa.common, wa.displacementmap]),
          vertexShader: xa.depth_vert,
          fragmentShader: xa.depth_frag
        },
        normal: {
          uniforms: ia([wa.common, wa.bumpmap, wa.normalmap, wa.displacementmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: xa.meshnormal_vert,
          fragmentShader: xa.meshnormal_frag
        },
        sprite: {
          uniforms: ia([wa.sprite, wa.fog]),
          vertexShader: xa.sprite_vert,
          fragmentShader: xa.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Pt()
            },
            t2D: {
              value: null
            }
          },
          vertexShader: xa.background_vert,
          fragmentShader: xa.background_frag
        },
        cube: {
          uniforms: ia([wa.envmap, {
            opacity: {
              value: 1
            }
          }]),
          vertexShader: xa.cube_vert,
          fragmentShader: xa.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: xa.equirect_vert,
          fragmentShader: xa.equirect_frag
        },
        distanceRGBA: {
          uniforms: ia([wa.common, wa.displacementmap, {
            referencePosition: {
              value: new ni()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1000
            }
          }]),
          vertexShader: xa.distanceRGBA_vert,
          fragmentShader: xa.distanceRGBA_frag
        },
        shadow: {
          uniforms: ia([wa.lights, wa.fog, {
            color: {
              value: new Wt(0)
            },
            opacity: {
              value: 1
            }
          }]),
          vertexShader: xa.shadow_vert,
          fragmentShader: xa.shadow_frag
        }
      };
      function Sa(e, t, i, n, a, r) {
        const s = new Wt(0);
        let o;
        let l;
        let d = a === true ? 0 : 1;
        let u = null;
        let p = 0;
        let m = null;
        function f(e, t) {
          i.buffers.color.setClear(e.r, e.g, e.b, t, r);
        }
        return {
          getClearColor: function () {
            return s;
          },
          setClearColor: function (e, t = 1) {
            s.set(e);
            d = t;
            f(s, d);
          },
          getClearAlpha: function () {
            return d;
          },
          setClearAlpha: function (e) {
            d = e;
            f(s, d);
          },
          render: function (i, a) {
            let r = false;
            let g = a.isScene === true ? a.background : null;
            if (g && g.isTexture) {
              g = t.get(g);
            }
            const _ = e.xr;
            const v = _.getSession && _.getSession();
            if (v && v.environmentBlendMode === "additive") {
              g = null;
            }
            if (g === null) {
              f(s, d);
            } else if (g && g.isColor) {
              f(g, 1);
              r = true;
            }
            if (e.autoClear || r) {
              e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil);
            }
            if (g && (g.isCubeTexture || g.mapping === ie)) {
              if (l === undefined) {
                l = new Zn(new ea(1, 1, 1), new aa({
                  name: "BackgroundCubeMaterial",
                  uniforms: ta(Ma.cube.uniforms),
                  vertexShader: Ma.cube.vertexShader,
                  fragmentShader: Ma.cube.fragmentShader,
                  side: h,
                  depthTest: false,
                  depthWrite: false,
                  fog: false
                }));
                l.geometry.deleteAttribute("normal");
                l.geometry.deleteAttribute("uv");
                l.onBeforeRender = function (e, t, i) {
                  this.matrixWorld.copyPosition(i.matrixWorld);
                };
                Object.defineProperty(l.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  }
                });
                n.update(l);
              }
              l.material.uniforms.envMap.value = g;
              l.material.uniforms.flipEnvMap.value = g.isCubeTexture && g.isRenderTargetTexture === false ? -1 : 1;
              if (u !== g || p !== g.version || m !== e.toneMapping) {
                l.material.needsUpdate = true;
                u = g;
                p = g.version;
                m = e.toneMapping;
              }
              l.layers.enableAll();
              i.unshift(l, l.geometry, l.material, 0, 0, null);
            } else if (g && g.isTexture) {
              if (o === undefined) {
                o = new Zn(new ya(2, 2), new aa({
                  name: "BackgroundMaterial",
                  uniforms: ta(Ma.background.uniforms),
                  vertexShader: Ma.background.vertexShader,
                  fragmentShader: Ma.background.fragmentShader,
                  side: c,
                  depthTest: false,
                  depthWrite: false,
                  fog: false
                }));
                o.geometry.deleteAttribute("normal");
                Object.defineProperty(o.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  }
                });
                n.update(o);
              }
              o.material.uniforms.t2D.value = g;
              if (g.matrixAutoUpdate === true) {
                g.updateMatrix();
              }
              o.material.uniforms.uvTransform.value.copy(g.matrix);
              if (u !== g || p !== g.version || m !== e.toneMapping) {
                o.material.needsUpdate = true;
                u = g;
                p = g.version;
                m = e.toneMapping;
              }
              o.layers.enableAll();
              i.unshift(o, o.geometry, o.material, 0, 0, null);
            }
          }
        };
      }
      function Ea(e, t, i, n) {
        const a = e.getParameter(34921);
        const r = n.isWebGL2 ? null : t.get("OES_vertex_array_object");
        const s = n.isWebGL2 || r !== null;
        const o = {};
        const l = p(null);
        let c = l;
        let h = false;
        function d(t) {
          if (n.isWebGL2) {
            return e.bindVertexArray(t);
          } else {
            return r.bindVertexArrayOES(t);
          }
        }
        function u(t) {
          if (n.isWebGL2) {
            return e.deleteVertexArray(t);
          } else {
            return r.deleteVertexArrayOES(t);
          }
        }
        function p(e) {
          const t = [];
          const i = [];
          const n = [];
          for (let e = 0; e < a; e++) {
            t[e] = 0;
            i[e] = 0;
            n[e] = 0;
          }
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: t,
            enabledAttributes: i,
            attributeDivisors: n,
            object: e,
            attributes: {},
            index: null
          };
        }
        function m() {
          const e = c.newAttributes;
          for (let t = 0, i = e.length; t < i; t++) {
            e[t] = 0;
          }
        }
        function f(e) {
          g(e, 0);
        }
        function g(i, a) {
          const r = c.newAttributes;
          const s = c.enabledAttributes;
          const o = c.attributeDivisors;
          r[i] = 1;
          if (s[i] === 0) {
            e.enableVertexAttribArray(i);
            s[i] = 1;
          }
          if (o[i] !== a) {
            (n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, a);
            o[i] = a;
          }
        }
        function _() {
          const t = c.newAttributes;
          const i = c.enabledAttributes;
          for (let n = 0, a = i.length; n < a; n++) {
            if (i[n] !== t[n]) {
              e.disableVertexAttribArray(n);
              i[n] = 0;
            }
          }
        }
        function v(t, i, a, r, s, o) {
          if (n.isWebGL2 !== true || a !== 5124 && a !== 5125) {
            e.vertexAttribPointer(t, i, a, r, s, o);
          } else {
            e.vertexAttribIPointer(t, i, a, s, o);
          }
        }
        function b() {
          y();
          h = true;
          if (c !== l) {
            c = l;
            d(c.object);
          }
        }
        function y() {
          l.geometry = null;
          l.program = null;
          l.wireframe = false;
        }
        return {
          setup: function (a, l, u, b, y) {
            let x = false;
            if (s) {
              const t = function (t, i, a) {
                const s = a.wireframe === true;
                let l = o[t.id];
                if (l === undefined) {
                  l = {};
                  o[t.id] = l;
                }
                let c = l[i.id];
                if (c === undefined) {
                  c = {};
                  l[i.id] = c;
                }
                let h = c[s];
                if (h === undefined) {
                  h = p(n.isWebGL2 ? e.createVertexArray() : r.createVertexArrayOES());
                  c[s] = h;
                }
                return h;
              }(b, u, l);
              if (c !== t) {
                c = t;
                d(c.object);
              }
              x = function (e, t, i, n) {
                const a = c.attributes;
                const r = t.attributes;
                let s = 0;
                const o = i.getAttributes();
                for (const t in o) {
                  if (o[t].location >= 0) {
                    const i = a[t];
                    let n = r[t];
                    if (n === undefined) {
                      if (t === "instanceMatrix" && e.instanceMatrix) {
                        n = e.instanceMatrix;
                      }
                      if (t === "instanceColor" && e.instanceColor) {
                        n = e.instanceColor;
                      }
                    }
                    if (i === undefined) {
                      return true;
                    }
                    if (i.attribute !== n) {
                      return true;
                    }
                    if (n && i.data !== n.data) {
                      return true;
                    }
                    s++;
                  }
                }
                return c.attributesNum !== s || c.index !== n;
              }(a, b, u, y);
              if (x) {
                (function (e, t, i, n) {
                  const a = {};
                  const r = t.attributes;
                  let s = 0;
                  const o = i.getAttributes();
                  for (const t in o) {
                    if (o[t].location >= 0) {
                      let i = r[t];
                      if (i === undefined) {
                        if (t === "instanceMatrix" && e.instanceMatrix) {
                          i = e.instanceMatrix;
                        }
                        if (t === "instanceColor" && e.instanceColor) {
                          i = e.instanceColor;
                        }
                      }
                      const n = {
                        attribute: i
                      };
                      if (i && i.data) {
                        n.data = i.data;
                      }
                      a[t] = n;
                      s++;
                    }
                  }
                  c.attributes = a;
                  c.attributesNum = s;
                  c.index = n;
                })(a, b, u, y);
              }
            } else {
              const e = l.wireframe === true;
              if (c.geometry !== b.id || c.program !== u.id || c.wireframe !== e) {
                c.geometry = b.id;
                c.program = u.id;
                c.wireframe = e;
                x = true;
              }
            }
            if (y !== null) {
              i.update(y, 34963);
            }
            if (x || h) {
              h = false;
              (function (a, r, s, o) {
                if (n.isWebGL2 === false && (a.isInstancedMesh || o.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null) {
                  return;
                }
                m();
                const l = o.attributes;
                const c = s.getAttributes();
                const h = r.defaultAttributeValues;
                for (const t in c) {
                  const n = c[t];
                  if (n.location >= 0) {
                    let r = l[t];
                    if (r === undefined) {
                      if (t === "instanceMatrix" && a.instanceMatrix) {
                        r = a.instanceMatrix;
                      }
                      if (t === "instanceColor" && a.instanceColor) {
                        r = a.instanceColor;
                      }
                    }
                    if (r !== undefined) {
                      const t = r.normalized;
                      const s = r.itemSize;
                      const l = i.get(r);
                      if (l === undefined) {
                        continue;
                      }
                      const c = l.buffer;
                      const h = l.type;
                      const d = l.bytesPerElement;
                      if (r.isInterleavedBufferAttribute) {
                        const i = r.data;
                        const l = i.stride;
                        const u = r.offset;
                        if (i.isInstancedInterleavedBuffer) {
                          for (let e = 0; e < n.locationSize; e++) {
                            g(n.location + e, i.meshPerAttribute);
                          }
                          if (a.isInstancedMesh !== true && o._maxInstanceCount === undefined) {
                            o._maxInstanceCount = i.meshPerAttribute * i.count;
                          }
                        } else {
                          for (let e = 0; e < n.locationSize; e++) {
                            f(n.location + e);
                          }
                        }
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < n.locationSize; e++) {
                          v(n.location + e, s / n.locationSize, h, t, l * d, (u + s / n.locationSize * e) * d);
                        }
                      } else {
                        if (r.isInstancedBufferAttribute) {
                          for (let e = 0; e < n.locationSize; e++) {
                            g(n.location + e, r.meshPerAttribute);
                          }
                          if (a.isInstancedMesh !== true && o._maxInstanceCount === undefined) {
                            o._maxInstanceCount = r.meshPerAttribute * r.count;
                          }
                        } else {
                          for (let e = 0; e < n.locationSize; e++) {
                            f(n.location + e);
                          }
                        }
                        e.bindBuffer(34962, c);
                        for (let e = 0; e < n.locationSize; e++) {
                          v(n.location + e, s / n.locationSize, h, t, s * d, s / n.locationSize * e * d);
                        }
                      }
                    } else if (h !== undefined) {
                      const i = h[t];
                      if (i !== undefined) {
                        switch (i.length) {
                          case 2:
                            e.vertexAttrib2fv(n.location, i);
                            break;
                          case 3:
                            e.vertexAttrib3fv(n.location, i);
                            break;
                          case 4:
                            e.vertexAttrib4fv(n.location, i);
                            break;
                          default:
                            e.vertexAttrib1fv(n.location, i);
                        }
                      }
                    }
                  }
                }
                _();
              })(a, l, u, b);
              if (y !== null) {
                e.bindBuffer(34963, i.get(y).buffer);
              }
            }
          },
          reset: b,
          resetDefaultState: y,
          dispose: function () {
            b();
            for (const e in o) {
              const t = o[e];
              for (const e in t) {
                const i = t[e];
                for (const e in i) {
                  u(i[e].object);
                  delete i[e];
                }
                delete t[e];
              }
              delete o[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (o[e.id] === undefined) {
              return;
            }
            const t = o[e.id];
            for (const e in t) {
              const i = t[e];
              for (const e in i) {
                u(i[e].object);
                delete i[e];
              }
              delete t[e];
            }
            delete o[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in o) {
              const i = o[t];
              if (i[e.id] === undefined) {
                continue;
              }
              const n = i[e.id];
              for (const e in n) {
                u(n[e].object);
                delete n[e];
              }
              delete i[e.id];
            }
          },
          initAttributes: m,
          enableAttribute: f,
          disableUnusedAttributes: _
        };
      }
      function Ta(e, t, i, n) {
        const a = n.isWebGL2;
        let r;
        this.setMode = function (e) {
          r = e;
        };
        this.render = function (t, n) {
          e.drawArrays(r, t, n);
          i.update(n, r, 1);
        };
        this.renderInstances = function (n, s, o) {
          if (o === 0) {
            return;
          }
          let l;
          let c;
          if (a) {
            l = e;
            c = "drawArraysInstanced";
          } else {
            l = t.get("ANGLE_instanced_arrays");
            c = "drawArraysInstancedANGLE";
            if (l === null) {
              console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          l[c](r, n, s, o);
          i.update(s, r, o);
        };
      }
      function Ca(e, t, i) {
        let n;
        function a(t) {
          if (t === "highp") {
            if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0) {
              return "highp";
            }
            t = "mediump";
          }
          if (t === "mediump" && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0) {
            return "mediump";
          } else {
            return "lowp";
          }
        }
        const r = typeof WebGL2RenderingContext != "undefined" && e instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext != "undefined" && e instanceof WebGL2ComputeRenderingContext;
        let s = i.precision !== undefined ? i.precision : "highp";
        const o = a(s);
        if (o !== s) {
          console.warn("THREE.WebGLRenderer:", s, "not supported, using", o, "instead.");
          s = o;
        }
        const l = r || t.has("WEBGL_draw_buffers");
        const c = i.logarithmicDepthBuffer === true;
        const h = e.getParameter(34930);
        const d = e.getParameter(35660);
        const u = e.getParameter(3379);
        const p = e.getParameter(34076);
        const m = e.getParameter(34921);
        const f = e.getParameter(36347);
        const g = e.getParameter(36348);
        const _ = e.getParameter(36349);
        const v = d > 0;
        const b = r || t.has("OES_texture_float");
        return {
          isWebGL2: r,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (n !== undefined) {
              return n;
            }
            if (t.has("EXT_texture_filter_anisotropic") === true) {
              const i = t.get("EXT_texture_filter_anisotropic");
              n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else {
              n = 0;
            }
            return n;
          },
          getMaxPrecision: a,
          precision: s,
          logarithmicDepthBuffer: c,
          maxTextures: h,
          maxVertexTextures: d,
          maxTextureSize: u,
          maxCubemapSize: p,
          maxAttributes: m,
          maxVertexUniforms: f,
          maxVaryings: g,
          maxFragmentUniforms: _,
          vertexTextures: v,
          floatFragmentTextures: b,
          floatVertexTextures: v && b,
          maxSamples: r ? e.getParameter(36183) : 0
        };
      }
      function ka(e) {
        const t = this;
        let i = null;
        let n = 0;
        let a = false;
        let r = false;
        const s = new ma();
        const o = new Pt();
        const l = {
          value: null,
          needsUpdate: false
        };
        function c() {
          if (l.value !== i) {
            l.value = i;
            l.needsUpdate = n > 0;
          }
          t.numPlanes = n;
          t.numIntersection = 0;
        }
        function h(e, i, n, a) {
          const r = e !== null ? e.length : 0;
          let c = null;
          if (r !== 0) {
            c = l.value;
            if (a !== true || c === null) {
              const t = n + r * 4;
              const a = i.matrixWorldInverse;
              o.getNormalMatrix(a);
              if (c === null || c.length < t) {
                c = new Float32Array(t);
              }
              for (let t = 0, i = n; t !== r; ++t, i += 4) {
                s.copy(e[t]).applyMatrix4(a, o);
                s.normal.toArray(c, i);
                c[i + 3] = s.constant;
              }
            }
            l.value = c;
            l.needsUpdate = true;
          }
          t.numPlanes = r;
          t.numIntersection = 0;
          return c;
        }
        this.uniform = l;
        this.numPlanes = 0;
        this.numIntersection = 0;
        this.init = function (e, t, r) {
          const s = e.length !== 0 || t || n !== 0 || a;
          a = t;
          i = h(e, r, 0);
          n = e.length;
          return s;
        };
        this.beginShadows = function () {
          r = true;
          h(null);
        };
        this.endShadows = function () {
          r = false;
          c();
        };
        this.setState = function (t, s, o) {
          const d = t.clippingPlanes;
          const u = t.clipIntersection;
          const p = t.clipShadows;
          const m = e.get(t);
          if (!a || d === null || d.length === 0 || r && !p) {
            if (r) {
              h(null);
            } else {
              c();
            }
          } else {
            const e = r ? 0 : n;
            const t = e * 4;
            let a = m.clippingState || null;
            l.value = a;
            a = h(d, s, t, o);
            for (let e = 0; e !== t; ++e) {
              a[e] = i[e];
            }
            m.clippingState = a;
            this.numIntersection = u ? this.numPlanes : 0;
            this.numPlanes += e;
          }
        };
      }
      function Aa(e) {
        let t = new WeakMap();
        function i(e, t) {
          if (t === ee) {
            e.mapping = Z;
          } else if (t === te) {
            e.mapping = Q;
          }
          return e;
        }
        function n(e) {
          const i = e.target;
          i.removeEventListener("dispose", n);
          const a = t.get(i);
          if (a !== undefined) {
            t.delete(i);
            a.dispose();
          }
        }
        return {
          get: function (a) {
            if (a && a.isTexture && a.isRenderTargetTexture === false) {
              const r = a.mapping;
              if (r === ee || r === te) {
                if (t.has(a)) {
                  return i(t.get(a).texture, a.mapping);
                }
                {
                  const r = a.image;
                  if (r && r.height > 0) {
                    const s = new ha(r.height / 2);
                    s.fromEquirectangularTexture(e, a);
                    t.set(a, s);
                    a.addEventListener("dispose", n);
                    return i(s.texture, a.mapping);
                  }
                  return null;
                }
              }
            }
            return a;
          },
          dispose: function () {
            t = new WeakMap();
          }
        };
      }
      Ma.physical = {
        uniforms: ia([Ma.standard.uniforms, {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatNormalScale: {
            value: new Rt(1, 1)
          },
          clearcoatNormalMap: {
            value: null
          },
          iridescence: {
            value: 0
          },
          iridescenceMap: {
            value: null
          },
          iridescenceIOR: {
            value: 1.3
          },
          iridescenceThicknessMinimum: {
            value: 100
          },
          iridescenceThicknessMaximum: {
            value: 400
          },
          iridescenceThicknessMap: {
            value: null
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Wt(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenRoughness: {
            value: 1
          },
          sheenRoughnessMap: {
            value: null
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionSamplerSize: {
            value: new Rt()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Wt(0)
          },
          specularIntensity: {
            value: 1
          },
          specularIntensityMap: {
            value: null
          },
          specularColor: {
            value: new Wt(1, 1, 1)
          },
          specularColorMap: {
            value: null
          }
        }]),
        vertexShader: xa.meshphysical_vert,
        fragmentShader: xa.meshphysical_frag
      };
      class La extends ra {
        constructor(e = -1, t = 1, i = 1, n = -1, a = 0.1, r = 2000) {
          super();
          this.isOrthographicCamera = true;
          this.type = "OrthographicCamera";
          this.zoom = 1;
          this.view = null;
          this.left = e;
          this.right = t;
          this.top = i;
          this.bottom = n;
          this.near = a;
          this.far = r;
          this.updateProjectionMatrix();
        }
        copy(e, t) {
          super.copy(e, t);
          this.left = e.left;
          this.right = e.right;
          this.top = e.top;
          this.bottom = e.bottom;
          this.near = e.near;
          this.far = e.far;
          this.zoom = e.zoom;
          this.view = e.view === null ? null : Object.assign({}, e.view);
          return this;
        }
        setViewOffset(e, t, i, n, a, r) {
          if (this.view === null) {
            this.view = {
              enabled: true,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            };
          }
          this.view.enabled = true;
          this.view.fullWidth = e;
          this.view.fullHeight = t;
          this.view.offsetX = i;
          this.view.offsetY = n;
          this.view.width = a;
          this.view.height = r;
          this.updateProjectionMatrix();
        }
        clearViewOffset() {
          if (this.view !== null) {
            this.view.enabled = false;
          }
          this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (this.zoom * 2);
          const t = (this.top - this.bottom) / (this.zoom * 2);
          const i = (this.right + this.left) / 2;
          const n = (this.top + this.bottom) / 2;
          let a = i - e;
          let r = i + e;
          let s = n + t;
          let o = n - t;
          if (this.view !== null && this.view.enabled) {
            const e = (this.right - this.left) / this.view.fullWidth / this.zoom;
            const t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            a += e * this.view.offsetX;
            r = a + e * this.view.width;
            s -= t * this.view.offsetY;
            o = s - t * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(a, r, s, o, this.near, this.far);
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.object.zoom = this.zoom;
          t.object.left = this.left;
          t.object.right = this.right;
          t.object.top = this.top;
          t.object.bottom = this.bottom;
          t.object.near = this.near;
          t.object.far = this.far;
          if (this.view !== null) {
            t.object.view = Object.assign({}, this.view);
          }
          return t;
        }
      }
      const Ra = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
      const Pa = new La();
      const Da = new Wt();
      let Ia = null;
      const $a = (1 + Math.sqrt(5)) / 2;
      const za = 1 / $a;
      const Na = [new ni(1, 1, 1), new ni(-1, 1, 1), new ni(1, 1, -1), new ni(-1, 1, -1), new ni(0, $a, za), new ni(0, $a, -za), new ni(za, 0, $a), new ni(-za, 0, $a), new ni($a, za, 0), new ni(-$a, za, 0)];
      class Oa {
        constructor(e) {
          this._renderer = e;
          this._pingPongRenderTarget = null;
          this._lodMax = 0;
          this._cubeSize = 0;
          this._lodPlanes = [];
          this._sizeLods = [];
          this._sigmas = [];
          this._blurMaterial = null;
          this._cubemapMaterial = null;
          this._equirectMaterial = null;
          this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, n = 100) {
          Ia = this._renderer.getRenderTarget();
          this._setSize(256);
          const a = this._allocateTargets();
          a.depthBuffer = true;
          this._sceneToCubeUV(e, i, n, a);
          if (t > 0) {
            this._blur(a, 0, 0, t);
          }
          this._applyPMREM(a);
          this._cleanup(a);
          return a;
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = Ha();
            this._compileMaterial(this._cubemapMaterial);
          }
        }
        compileEquirectangularShader() {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = Ba();
            this._compileMaterial(this._equirectMaterial);
          }
        }
        dispose() {
          this._dispose();
          if (this._cubemapMaterial !== null) {
            this._cubemapMaterial.dispose();
          }
          if (this._equirectMaterial !== null) {
            this._equirectMaterial.dispose();
          }
        }
        _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e));
          this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          if (this._blurMaterial !== null) {
            this._blurMaterial.dispose();
          }
          if (this._pingPongRenderTarget !== null) {
            this._pingPongRenderTarget.dispose();
          }
          for (let e = 0; e < this._lodPlanes.length; e++) {
            this._lodPlanes[e].dispose();
          }
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(Ia);
          e.scissorTest = false;
          Fa(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          if (e.mapping === Z || e.mapping === Q) {
            this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width);
          } else {
            this._setSize(e.image.width / 4);
          }
          Ia = this._renderer.getRenderTarget();
          const i = t || this._allocateTargets();
          this._textureToCubeUV(e, i);
          this._applyPMREM(i);
          this._cleanup(i);
          return i;
        }
        _allocateTargets() {
          const e = Math.max(this._cubeSize, 112) * 3;
          const t = this._cubeSize * 4;
          const i = {
            magFilter: ce,
            minFilter: ce,
            generateMipmaps: false,
            type: be,
            format: Ee,
            encoding: ht,
            depthBuffer: false
          };
          const n = Ua(e, t, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e) {
            if (this._pingPongRenderTarget !== null) {
              this._dispose();
            }
            this._pingPongRenderTarget = Ua(e, t, i);
            const {
              _lodMax: n
            } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas
            } = function (e) {
              const t = [];
              const i = [];
              const n = [];
              let a = e;
              const r = e - 4 + 1 + Ra.length;
              for (let s = 0; s < r; s++) {
                const r = Math.pow(2, a);
                i.push(r);
                let o = 1 / r;
                if (s > e - 4) {
                  o = Ra[s - e + 4 - 1];
                } else if (s === 0) {
                  o = 0;
                }
                n.push(o);
                const l = 1 / (r - 2);
                const c = -l;
                const h = 1 + l;
                const d = [c, c, h, c, h, h, c, c, h, h, c, h];
                const u = 6;
                const p = 6;
                const m = 3;
                const f = 2;
                const g = 1;
                const _ = new Float32Array(m * p * u);
                const v = new Float32Array(f * p * u);
                const b = new Float32Array(g * p * u);
                for (let e = 0; e < u; e++) {
                  const t = e % 3 * 2 / 3 - 1;
                  const i = e > 2 ? 0 : -1;
                  const n = [t, i, 0, t + 2 / 3, i, 0, t + 2 / 3, i + 1, 0, t, i, 0, t + 2 / 3, i + 1, 0, t, i + 1, 0];
                  _.set(n, m * p * e);
                  v.set(d, f * p * e);
                  const a = [e, e, e, e, e, e];
                  b.set(a, g * p * e);
                }
                const y = new In();
                y.setAttribute("position", new Mn(_, m));
                y.setAttribute("uv", new Mn(v, f));
                y.setAttribute("faceIndex", new Mn(b, g));
                t.push(y);
                if (a > 4) {
                  a--;
                }
              }
              return {
                lodPlanes: t,
                sizeLods: i,
                sigmas: n
              };
            }(n));
            this._blurMaterial = function (e, t, i) {
              const n = new Float32Array(20);
              const a = new ni(0, 1, 0);
              return new aa({
                name: "SphericalGaussianBlur",
                defines: {
                  n: 20,
                  CUBEUV_TEXEL_WIDTH: 1 / t,
                  CUBEUV_TEXEL_HEIGHT: 1 / i,
                  CUBEUV_MAX_MIP: `${e}.0`
                },
                uniforms: {
                  envMap: {
                    value: null
                  },
                  samples: {
                    value: 1
                  },
                  weights: {
                    value: n
                  },
                  latitudinal: {
                    value: false
                  },
                  dTheta: {
                    value: 0
                  },
                  mipInt: {
                    value: 0
                  },
                  poleAxis: {
                    value: a
                  }
                },
                vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: u,
                depthTest: false,
                depthWrite: false
              });
            }(n, e, t);
          }
          return n;
        }
        _compileMaterial(e) {
          const t = new Zn(this._lodPlanes[0], e);
          this._renderer.compile(t, Pa);
        }
        _sceneToCubeUV(e, t, i, n) {
          const a = new sa(90, 1, t, i);
          const r = [1, -1, 1, 1, 1, 1];
          const s = [1, 1, 1, -1, -1, -1];
          const o = this._renderer;
          const l = o.autoClear;
          const c = o.toneMapping;
          o.getClearColor(Da);
          o.toneMapping = q;
          o.autoClear = false;
          const d = new yn({
            name: "PMREM.Background",
            side: h,
            depthWrite: false,
            depthTest: false
          });
          const u = new Zn(new ea(), d);
          let p = false;
          const m = e.background;
          if (m) {
            if (m.isColor) {
              d.color.copy(m);
              e.background = null;
              p = true;
            }
          } else {
            d.color.copy(Da);
            p = true;
          }
          for (let t = 0; t < 6; t++) {
            const i = t % 3;
            if (i === 0) {
              a.up.set(0, r[t], 0);
              a.lookAt(s[t], 0, 0);
            } else if (i === 1) {
              a.up.set(0, 0, r[t]);
              a.lookAt(0, s[t], 0);
            } else {
              a.up.set(0, r[t], 0);
              a.lookAt(0, 0, s[t]);
            }
            const l = this._cubeSize;
            Fa(n, i * l, t > 2 ? l : 0, l, l);
            o.setRenderTarget(n);
            if (p) {
              o.render(u, a);
            }
            o.render(e, a);
          }
          u.geometry.dispose();
          u.material.dispose();
          o.toneMapping = c;
          o.autoClear = l;
          e.background = m;
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer;
          const n = e.mapping === Z || e.mapping === Q;
          if (n) {
            if (this._cubemapMaterial === null) {
              this._cubemapMaterial = Ha();
            }
            this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1;
          } else if (this._equirectMaterial === null) {
            this._equirectMaterial = Ba();
          }
          const a = n ? this._cubemapMaterial : this._equirectMaterial;
          const r = new Zn(this._lodPlanes[0], a);
          a.uniforms.envMap.value = e;
          const s = this._cubeSize;
          Fa(t, 0, 0, s * 3, s * 2);
          i.setRenderTarget(t);
          i.render(r, Pa);
        }
        _applyPMREM(e) {
          const t = this._renderer;
          const i = t.autoClear;
          t.autoClear = false;
          for (let t = 1; t < this._lodPlanes.length; t++) {
            const i = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]);
            const n = Na[(t - 1) % Na.length];
            this._blur(e, t - 1, t, i, n);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, n, a) {
          const r = this._pingPongRenderTarget;
          this._halfBlur(e, r, t, i, n, "latitudinal", a);
          this._halfBlur(r, e, i, i, n, "longitudinal", a);
        }
        _halfBlur(e, t, i, n, a, r, s) {
          const o = this._renderer;
          const l = this._blurMaterial;
          if (r !== "latitudinal" && r !== "longitudinal") {
            console.error("blur direction must be either latitudinal or longitudinal!");
          }
          const c = new Zn(this._lodPlanes[n], l);
          const h = l.uniforms;
          const d = this._sizeLods[i] - 1;
          const u = isFinite(a) ? Math.PI / (d * 2) : Math.PI * 2 / 39;
          const p = a / u;
          const m = isFinite(a) ? 1 + Math.floor(p * 3) : 20;
          if (m > 20) {
            console.warn(`sigmaRadians, ${a}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`);
          }
          const f = [];
          let g = 0;
          for (let e = 0; e < 20; ++e) {
            const t = e / p;
            const i = Math.exp(-t * t / 2);
            f.push(i);
            if (e === 0) {
              g += i;
            } else if (e < m) {
              g += i * 2;
            }
          }
          for (let e = 0; e < f.length; e++) {
            f[e] = f[e] / g;
          }
          h.envMap.value = e.texture;
          h.samples.value = m;
          h.weights.value = f;
          h.latitudinal.value = r === "latitudinal";
          if (s) {
            h.poleAxis.value = s;
          }
          const {
            _lodMax: _
          } = this;
          h.dTheta.value = u;
          h.mipInt.value = _ - i;
          const v = this._sizeLods[n];
          Fa(t, v * 3 * (n > _ - 4 ? n - _ + 4 : 0), (this._cubeSize - v) * 4, v * 3, v * 2);
          o.setRenderTarget(t);
          o.render(c, Pa);
        }
      }
      function Ua(e, t, i) {
        const n = new Qt(e, t, i);
        n.texture.mapping = ie;
        n.texture.name = "PMREM.cubeUv";
        n.scissorTest = true;
        return n;
      }
      function Fa(e, t, i, n, a) {
        e.viewport.set(t, i, n, a);
        e.scissor.set(t, i, n, a);
      }
      function Ba() {
        return new aa({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: u,
          depthTest: false,
          depthWrite: false
        });
      }
      function Ha() {
        return new aa({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: u,
          depthTest: false,
          depthWrite: false
        });
      }
      function Va(e) {
        let t = new WeakMap();
        let i = null;
        function n(e) {
          const i = e.target;
          i.removeEventListener("dispose", n);
          const a = t.get(i);
          if (a !== undefined) {
            t.delete(i);
            a.dispose();
          }
        }
        return {
          get: function (a) {
            if (a && a.isTexture) {
              const r = a.mapping;
              const s = r === ee || r === te;
              const o = r === Z || r === Q;
              if (s || o) {
                if (a.isRenderTargetTexture && a.needsPMREMUpdate === true) {
                  a.needsPMREMUpdate = false;
                  let n = t.get(a);
                  if (i === null) {
                    i = new Oa(e);
                  }
                  n = s ? i.fromEquirectangular(a, n) : i.fromCubemap(a, n);
                  t.set(a, n);
                  return n.texture;
                }
                if (t.has(a)) {
                  return t.get(a).texture;
                }
                {
                  const r = a.image;
                  if (s && r && r.height > 0 || o && r && function (e) {
                    let t = 0;
                    for (let i = 0; i < 6; i++) {
                      if (e[i] !== undefined) {
                        t++;
                      }
                    }
                    return t === 6;
                  }(r)) {
                    if (i === null) {
                      i = new Oa(e);
                    }
                    const r = s ? i.fromEquirectangular(a) : i.fromCubemap(a);
                    t.set(a, r);
                    a.addEventListener("dispose", n);
                    return r.texture;
                  }
                  return null;
                }
              }
            }
            return a;
          },
          dispose: function () {
            t = new WeakMap();
            if (i !== null) {
              i.dispose();
              i = null;
            }
          }
        };
      }
      function Ga(e) {
        const t = {};
        function i(i) {
          if (t[i] !== undefined) {
            return t[i];
          }
          let n;
          switch (i) {
            case "WEBGL_depth_texture":
              n = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              n = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              n = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              n = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              n = e.getExtension(i);
          }
          t[i] = n;
          return n;
        }
        return {
          has: function (e) {
            return i(e) !== null;
          },
          init: function (e) {
            if (e.isWebGL2) {
              i("EXT_color_buffer_float");
            } else {
              i("WEBGL_depth_texture");
              i("OES_texture_float");
              i("OES_texture_half_float");
              i("OES_texture_half_float_linear");
              i("OES_standard_derivatives");
              i("OES_element_index_uint");
              i("OES_vertex_array_object");
              i("ANGLE_instanced_arrays");
            }
            i("OES_texture_float_linear");
            i("EXT_color_buffer_half_float");
            i("WEBGL_multisampled_render_to_texture");
          },
          get: function (e) {
            const t = i(e);
            if (t === null) {
              console.warn("THREE.WebGLRenderer: " + e + " extension not supported.");
            }
            return t;
          }
        };
      }
      function Wa(e, t, i, n) {
        const a = {};
        const r = new WeakMap();
        function s(e) {
          const o = e.target;
          if (o.index !== null) {
            t.remove(o.index);
          }
          for (const e in o.attributes) {
            t.remove(o.attributes[e]);
          }
          o.removeEventListener("dispose", s);
          delete a[o.id];
          const l = r.get(o);
          if (l) {
            t.remove(l);
            r.delete(o);
          }
          n.releaseStatesOfGeometry(o);
          if (o.isInstancedBufferGeometry === true) {
            delete o._maxInstanceCount;
          }
          i.memory.geometries--;
        }
        function o(e) {
          const i = [];
          const n = e.index;
          const a = e.attributes.position;
          let s = 0;
          if (n !== null) {
            const e = n.array;
            s = n.version;
            for (let t = 0, n = e.length; t < n; t += 3) {
              const n = e[t + 0];
              const a = e[t + 1];
              const r = e[t + 2];
              i.push(n, a, a, r, r, n);
            }
          } else {
            const e = a.array;
            s = a.version;
            for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
              const e = t + 0;
              const n = t + 1;
              const a = t + 2;
              i.push(e, n, n, a, a, e);
            }
          }
          const o = new (Dt(i) ? En : Sn)(i, 1);
          o.version = s;
          const l = r.get(e);
          if (l) {
            t.remove(l);
          }
          r.set(e, o);
        }
        return {
          get: function (e, t) {
            if (a[t.id] !== true) {
              t.addEventListener("dispose", s);
              a[t.id] = true;
              i.memory.geometries++;
            }
            return t;
          },
          update: function (e) {
            const i = e.attributes;
            for (const e in i) {
              t.update(i[e], 34962);
            }
            const n = e.morphAttributes;
            for (const e in n) {
              const i = n[e];
              for (let e = 0, n = i.length; e < n; e++) {
                t.update(i[e], 34962);
              }
            }
          },
          getWireframeAttribute: function (e) {
            const t = r.get(e);
            if (t) {
              const i = e.index;
              if (i !== null && t.version < i.version) {
                o(e);
              }
            } else {
              o(e);
            }
            return r.get(e);
          }
        };
      }
      function qa(e, t, i, n) {
        const a = n.isWebGL2;
        let r;
        let s;
        let o;
        this.setMode = function (e) {
          r = e;
        };
        this.setIndex = function (e) {
          s = e.type;
          o = e.bytesPerElement;
        };
        this.render = function (t, n) {
          e.drawElements(r, n, s, t * o);
          i.update(n, r, 1);
        };
        this.renderInstances = function (n, l, c) {
          if (c === 0) {
            return;
          }
          let h;
          let d;
          if (a) {
            h = e;
            d = "drawElementsInstanced";
          } else {
            h = t.get("ANGLE_instanced_arrays");
            d = "drawElementsInstancedANGLE";
            if (h === null) {
              console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
              return;
            }
          }
          h[d](r, l, s, n * o, c);
          i.update(l, r, c);
        };
      }
      function ja(e) {
        const t = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        return {
          memory: {
            geometries: 0,
            textures: 0
          },
          render: t,
          programs: null,
          autoReset: true,
          reset: function () {
            t.frame++;
            t.calls = 0;
            t.triangles = 0;
            t.points = 0;
            t.lines = 0;
          },
          update: function (e, i, n) {
            t.calls++;
            switch (i) {
              case 4:
                t.triangles += n * (e / 3);
                break;
              case 1:
                t.lines += n * (e / 2);
                break;
              case 3:
                t.lines += n * (e - 1);
                break;
              case 2:
                t.lines += n * e;
                break;
              case 0:
                t.points += n * e;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", i);
            }
          }
        };
      }
      function Xa(e, t) {
        return e[0] - t[0];
      }
      function Ka(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1]);
      }
      function Ya(e, t, i) {
        const n = {};
        const a = new Float32Array(8);
        const r = new WeakMap();
        const s = new Zt();
        const o = [];
        for (let e = 0; e < 8; e++) {
          o[e] = [e, 0];
        }
        return {
          update: function (l, c, h, d) {
            const u = l.morphTargetInfluences;
            if (t.isWebGL2 === true) {
              const p = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color;
              const m = p !== undefined ? p.length : 0;
              let f = r.get(c);
              if (f === undefined || f.count !== m) {
                if (f !== undefined) {
                  f.texture.dispose();
                }
                const v = c.morphAttributes.position !== undefined;
                const b = c.morphAttributes.normal !== undefined;
                const y = c.morphAttributes.color !== undefined;
                const x = c.morphAttributes.position || [];
                const w = c.morphAttributes.normal || [];
                const M = c.morphAttributes.color || [];
                let S = 0;
                if (v === true) {
                  S = 1;
                }
                if (b === true) {
                  S = 2;
                }
                if (y === true) {
                  S = 3;
                }
                let E = c.attributes.position.count * S;
                let T = 1;
                if (E > t.maxTextureSize) {
                  T = Math.ceil(E / t.maxTextureSize);
                  E = t.maxTextureSize;
                }
                const C = new Float32Array(E * T * 4 * m);
                const k = new ei(C, E, T, m);
                k.type = ve;
                k.needsUpdate = true;
                const A = S * 4;
                for (let R = 0; R < m; R++) {
                  const P = x[R];
                  const D = w[R];
                  const I = M[R];
                  const $ = E * T * 4 * R;
                  for (let z = 0; z < P.count; z++) {
                    const N = z * A;
                    if (v === true) {
                      s.fromBufferAttribute(P, z);
                      C[$ + N + 0] = s.x;
                      C[$ + N + 1] = s.y;
                      C[$ + N + 2] = s.z;
                      C[$ + N + 3] = 0;
                    }
                    if (b === true) {
                      s.fromBufferAttribute(D, z);
                      C[$ + N + 4] = s.x;
                      C[$ + N + 5] = s.y;
                      C[$ + N + 6] = s.z;
                      C[$ + N + 7] = 0;
                    }
                    if (y === true) {
                      s.fromBufferAttribute(I, z);
                      C[$ + N + 8] = s.x;
                      C[$ + N + 9] = s.y;
                      C[$ + N + 10] = s.z;
                      C[$ + N + 11] = I.itemSize === 4 ? s.w : 1;
                    }
                  }
                }
                function L() {
                  k.dispose();
                  r.delete(c);
                  c.removeEventListener("dispose", L);
                }
                f = {
                  count: m,
                  texture: k,
                  size: new Rt(E, T)
                };
                r.set(c, f);
                c.addEventListener("dispose", L);
              }
              let g = 0;
              for (let O = 0; O < u.length; O++) {
                g += u[O];
              }
              const _ = c.morphTargetsRelative ? 1 : 1 - g;
              d.getUniforms().setValue(e, "morphTargetBaseInfluence", _);
              d.getUniforms().setValue(e, "morphTargetInfluences", u);
              d.getUniforms().setValue(e, "morphTargetsTexture", f.texture, i);
              d.getUniforms().setValue(e, "morphTargetsTextureSize", f.size);
            } else {
              const U = u === undefined ? 0 : u.length;
              let F = n[c.id];
              if (F === undefined || F.length !== U) {
                F = [];
                for (let W = 0; W < U; W++) {
                  F[W] = [W, 0];
                }
                n[c.id] = F;
              }
              for (let q = 0; q < U; q++) {
                const j = F[q];
                j[0] = q;
                j[1] = u[q];
              }
              F.sort(Ka);
              for (let X = 0; X < 8; X++) {
                if (X < U && F[X][1]) {
                  o[X][0] = F[X][0];
                  o[X][1] = F[X][1];
                } else {
                  o[X][0] = Number.MAX_SAFE_INTEGER;
                  o[X][1] = 0;
                }
              }
              o.sort(Xa);
              const B = c.morphAttributes.position;
              const H = c.morphAttributes.normal;
              let V = 0;
              for (let K = 0; K < 8; K++) {
                const Y = o[K];
                const J = Y[0];
                const Z = Y[1];
                if (J !== Number.MAX_SAFE_INTEGER && Z) {
                  if (B && c.getAttribute("morphTarget" + K) !== B[J]) {
                    c.setAttribute("morphTarget" + K, B[J]);
                  }
                  if (H && c.getAttribute("morphNormal" + K) !== H[J]) {
                    c.setAttribute("morphNormal" + K, H[J]);
                  }
                  a[K] = Z;
                  V += Z;
                } else {
                  if (B && c.hasAttribute("morphTarget" + K) === true) {
                    c.deleteAttribute("morphTarget" + K);
                  }
                  if (H && c.hasAttribute("morphNormal" + K) === true) {
                    c.deleteAttribute("morphNormal" + K);
                  }
                  a[K] = 0;
                }
              }
              const G = c.morphTargetsRelative ? 1 : 1 - V;
              d.getUniforms().setValue(e, "morphTargetBaseInfluence", G);
              d.getUniforms().setValue(e, "morphTargetInfluences", a);
            }
          }
        };
      }
      function Ja(e, t, i, n) {
        let a = new WeakMap();
        function r(e) {
          const t = e.target;
          t.removeEventListener("dispose", r);
          i.remove(t.instanceMatrix);
          if (t.instanceColor !== null) {
            i.remove(t.instanceColor);
          }
        }
        return {
          update: function (e) {
            const s = n.render.frame;
            const o = e.geometry;
            const l = t.get(e, o);
            if (a.get(l) !== s) {
              t.update(l);
              a.set(l, s);
            }
            if (e.isInstancedMesh) {
              if (e.hasEventListener("dispose", r) === false) {
                e.addEventListener("dispose", r);
              }
              i.update(e.instanceMatrix, 34962);
              if (e.instanceColor !== null) {
                i.update(e.instanceColor, 34962);
              }
            }
            return l;
          },
          dispose: function () {
            a = new WeakMap();
          }
        };
      }
      const Za = new Jt();
      const Qa = new ei();
      const er = new ti();
      const tr = new ca();
      const ir = [];
      const nr = [];
      const ar = new Float32Array(16);
      const rr = new Float32Array(9);
      const sr = new Float32Array(4);
      function or(e, t, i) {
        const n = e[0];
        if (n <= 0 || n > 0) {
          return e;
        }
        const a = t * i;
        let r = ir[a];
        if (r === undefined) {
          r = new Float32Array(a);
          ir[a] = r;
        }
        if (t !== 0) {
          n.toArray(r, 0);
          for (let n = 1, a = 0; n !== t; ++n) {
            a += i;
            e[n].toArray(r, a);
          }
        }
        return r;
      }
      function lr(e, t) {
        if (e.length !== t.length) {
          return false;
        }
        for (let i = 0, n = e.length; i < n; i++) {
          if (e[i] !== t[i]) {
            return false;
          }
        }
        return true;
      }
      function cr(e, t) {
        for (let i = 0, n = t.length; i < n; i++) {
          e[i] = t[i];
        }
      }
      function hr(e, t) {
        let i = nr[t];
        if (i === undefined) {
          i = new Int32Array(t);
          nr[t] = i;
        }
        for (let n = 0; n !== t; ++n) {
          i[n] = e.allocateTextureUnit();
        }
        return i;
      }
      function dr(e, t) {
        const i = this.cache;
        if (i[0] !== t) {
          e.uniform1f(this.addr, t);
          i[0] = t;
        }
      }
      function ur(e, t) {
        const i = this.cache;
        if (t.x !== undefined) {
          if (i[0] !== t.x || i[1] !== t.y) {
            e.uniform2f(this.addr, t.x, t.y);
            i[0] = t.x;
            i[1] = t.y;
          }
        } else {
          if (lr(i, t)) {
            return;
          }
          e.uniform2fv(this.addr, t);
          cr(i, t);
        }
      }
      function pr(e, t) {
        const i = this.cache;
        if (t.x !== undefined) {
          if (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z) {
            e.uniform3f(this.addr, t.x, t.y, t.z);
            i[0] = t.x;
            i[1] = t.y;
            i[2] = t.z;
          }
        } else if (t.r !== undefined) {
          if (i[0] !== t.r || i[1] !== t.g || i[2] !== t.b) {
            e.uniform3f(this.addr, t.r, t.g, t.b);
            i[0] = t.r;
            i[1] = t.g;
            i[2] = t.b;
          }
        } else {
          if (lr(i, t)) {
            return;
          }
          e.uniform3fv(this.addr, t);
          cr(i, t);
        }
      }
      function mr(e, t) {
        const i = this.cache;
        if (t.x !== undefined) {
          if (i[0] !== t.x || i[1] !== t.y || i[2] !== t.z || i[3] !== t.w) {
            e.uniform4f(this.addr, t.x, t.y, t.z, t.w);
            i[0] = t.x;
            i[1] = t.y;
            i[2] = t.z;
            i[3] = t.w;
          }
        } else {
          if (lr(i, t)) {
            return;
          }
          e.uniform4fv(this.addr, t);
          cr(i, t);
        }
      }
      function fr(e, t) {
        const i = this.cache;
        const n = t.elements;
        if (n === undefined) {
          if (lr(i, t)) {
            return;
          }
          e.uniformMatrix2fv(this.addr, false, t);
          cr(i, t);
        } else {
          if (lr(i, n)) {
            return;
          }
          sr.set(n);
          e.uniformMatrix2fv(this.addr, false, sr);
          cr(i, n);
        }
      }
      function gr(e, t) {
        const i = this.cache;
        const n = t.elements;
        if (n === undefined) {
          if (lr(i, t)) {
            return;
          }
          e.uniformMatrix3fv(this.addr, false, t);
          cr(i, t);
        } else {
          if (lr(i, n)) {
            return;
          }
          rr.set(n);
          e.uniformMatrix3fv(this.addr, false, rr);
          cr(i, n);
        }
      }
      function _r(e, t) {
        const i = this.cache;
        const n = t.elements;
        if (n === undefined) {
          if (lr(i, t)) {
            return;
          }
          e.uniformMatrix4fv(this.addr, false, t);
          cr(i, t);
        } else {
          if (lr(i, n)) {
            return;
          }
          ar.set(n);
          e.uniformMatrix4fv(this.addr, false, ar);
          cr(i, n);
        }
      }
      function vr(e, t) {
        const i = this.cache;
        if (i[0] !== t) {
          e.uniform1i(this.addr, t);
          i[0] = t;
        }
      }
      function br(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform2iv(this.addr, t);
          cr(i, t);
        }
      }
      function yr(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform3iv(this.addr, t);
          cr(i, t);
        }
      }
      function xr(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform4iv(this.addr, t);
          cr(i, t);
        }
      }
      function wr(e, t) {
        const i = this.cache;
        if (i[0] !== t) {
          e.uniform1ui(this.addr, t);
          i[0] = t;
        }
      }
      function Mr(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform2uiv(this.addr, t);
          cr(i, t);
        }
      }
      function Sr(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform3uiv(this.addr, t);
          cr(i, t);
        }
      }
      function Er(e, t) {
        const i = this.cache;
        if (!lr(i, t)) {
          e.uniform4uiv(this.addr, t);
          cr(i, t);
        }
      }
      function Tr(e, t, i) {
        const n = this.cache;
        const a = i.allocateTextureUnit();
        if (n[0] !== a) {
          e.uniform1i(this.addr, a);
          n[0] = a;
        }
        i.setTexture2D(t || Za, a);
      }
      function Cr(e, t, i) {
        const n = this.cache;
        const a = i.allocateTextureUnit();
        if (n[0] !== a) {
          e.uniform1i(this.addr, a);
          n[0] = a;
        }
        i.setTexture3D(t || er, a);
      }
      function kr(e, t, i) {
        const n = this.cache;
        const a = i.allocateTextureUnit();
        if (n[0] !== a) {
          e.uniform1i(this.addr, a);
          n[0] = a;
        }
        i.setTextureCube(t || tr, a);
      }
      function Ar(e, t, i) {
        const n = this.cache;
        const a = i.allocateTextureUnit();
        if (n[0] !== a) {
          e.uniform1i(this.addr, a);
          n[0] = a;
        }
        i.setTexture2DArray(t || Qa, a);
      }
      function Lr(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function Rr(e, t) {
        const i = or(t, this.size, 2);
        e.uniform2fv(this.addr, i);
      }
      function Pr(e, t) {
        const i = or(t, this.size, 3);
        e.uniform3fv(this.addr, i);
      }
      function Dr(e, t) {
        const i = or(t, this.size, 4);
        e.uniform4fv(this.addr, i);
      }
      function Ir(e, t) {
        const i = or(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, false, i);
      }
      function $r(e, t) {
        const i = or(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, false, i);
      }
      function zr(e, t) {
        const i = or(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, false, i);
      }
      function Nr(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function Or(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function Ur(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function Fr(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function Br(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function Hr(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function Vr(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function Gr(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function Wr(e, t, i) {
        const n = t.length;
        const a = hr(i, n);
        e.uniform1iv(this.addr, a);
        for (let e = 0; e !== n; ++e) {
          i.setTexture2D(t[e] || Za, a[e]);
        }
      }
      function qr(e, t, i) {
        const n = t.length;
        const a = hr(i, n);
        e.uniform1iv(this.addr, a);
        for (let e = 0; e !== n; ++e) {
          i.setTexture3D(t[e] || er, a[e]);
        }
      }
      function jr(e, t, i) {
        const n = t.length;
        const a = hr(i, n);
        e.uniform1iv(this.addr, a);
        for (let e = 0; e !== n; ++e) {
          i.setTextureCube(t[e] || tr, a[e]);
        }
      }
      function Xr(e, t, i) {
        const n = t.length;
        const a = hr(i, n);
        e.uniform1iv(this.addr, a);
        for (let e = 0; e !== n; ++e) {
          i.setTexture2DArray(t[e] || Qa, a[e]);
        }
      }
      class Kr {
        constructor(e, t, i) {
          this.id = e;
          this.addr = i;
          this.cache = [];
          this.setValue = function (e) {
            switch (e) {
              case 5126:
                return dr;
              case 35664:
                return ur;
              case 35665:
                return pr;
              case 35666:
                return mr;
              case 35674:
                return fr;
              case 35675:
                return gr;
              case 35676:
                return _r;
              case 5124:
              case 35670:
                return vr;
              case 35667:
              case 35671:
                return br;
              case 35668:
              case 35672:
                return yr;
              case 35669:
              case 35673:
                return xr;
              case 5125:
                return wr;
              case 36294:
                return Mr;
              case 36295:
                return Sr;
              case 36296:
                return Er;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Tr;
              case 35679:
              case 36299:
              case 36307:
                return Cr;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return kr;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return Ar;
            }
          }(t.type);
        }
      }
      class Yr {
        constructor(e, t, i) {
          this.id = e;
          this.addr = i;
          this.cache = [];
          this.size = t.size;
          this.setValue = function (e) {
            switch (e) {
              case 5126:
                return Lr;
              case 35664:
                return Rr;
              case 35665:
                return Pr;
              case 35666:
                return Dr;
              case 35674:
                return Ir;
              case 35675:
                return $r;
              case 35676:
                return zr;
              case 5124:
              case 35670:
                return Nr;
              case 35667:
              case 35671:
                return Or;
              case 35668:
              case 35672:
                return Ur;
              case 35669:
              case 35673:
                return Fr;
              case 5125:
                return Br;
              case 36294:
                return Hr;
              case 36295:
                return Vr;
              case 36296:
                return Gr;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Wr;
              case 35679:
              case 36299:
              case 36307:
                return qr;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return jr;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return Xr;
            }
          }(t.type);
        }
      }
      class Jr {
        constructor(e) {
          this.id = e;
          this.seq = [];
          this.map = {};
        }
        setValue(e, t, i) {
          const n = this.seq;
          for (let a = 0, r = n.length; a !== r; ++a) {
            const r = n[a];
            r.setValue(e, t[r.id], i);
          }
        }
      }
      const Zr = /(\w+)(\])?(\[|\.)?/g;
      function Qr(e, t) {
        e.seq.push(t);
        e.map[t.id] = t;
      }
      function es(e, t, i) {
        const n = e.name;
        const a = n.length;
        for (Zr.lastIndex = 0;;) {
          const r = Zr.exec(n);
          const s = Zr.lastIndex;
          let o = r[1];
          const l = r[2] === "]";
          const c = r[3];
          if (l) {
            o |= 0;
          }
          if (c === undefined || c === "[" && s + 2 === a) {
            Qr(i, c === undefined ? new Kr(o, e, t) : new Yr(o, e, t));
            break;
          }
          {
            let e = i.map[o];
            if (e === undefined) {
              e = new Jr(o);
              Qr(i, e);
            }
            i = e;
          }
        }
      }
      class ts {
        constructor(e, t) {
          this.seq = [];
          this.map = {};
          const i = e.getProgramParameter(t, 35718);
          for (let n = 0; n < i; ++n) {
            const i = e.getActiveUniform(t, n);
            es(i, e.getUniformLocation(t, i.name), this);
          }
        }
        setValue(e, t, i, n) {
          const a = this.map[t];
          if (a !== undefined) {
            a.setValue(e, i, n);
          }
        }
        setOptional(e, t, i) {
          const n = t[i];
          if (n !== undefined) {
            this.setValue(e, i, n);
          }
        }
        static upload(e, t, i, n) {
          for (let a = 0, r = t.length; a !== r; ++a) {
            const r = t[a];
            const s = i[r.id];
            if (s.needsUpdate !== false) {
              r.setValue(e, s.value, n);
            }
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let n = 0, a = e.length; n !== a; ++n) {
            const a = e[n];
            if (a.id in t) {
              i.push(a);
            }
          }
          return i;
        }
      }
      function is(e, t, i) {
        const n = e.createShader(t);
        e.shaderSource(n, i);
        e.compileShader(n);
        return n;
      }
      let ns = 0;
      function as(e, t, i) {
        const n = e.getShaderParameter(t, 35713);
        const a = e.getShaderInfoLog(t).trim();
        if (n && a === "") {
          return "";
        }
        const r = /ERROR: 0:(\d+)/.exec(a);
        if (r) {
          const n = parseInt(r[1]);
          return i.toUpperCase() + "\n\n" + a + "\n\n" + function (e, t) {
            const i = e.split("\n");
            const n = [];
            const a = Math.max(t - 6, 0);
            const r = Math.min(t + 6, i.length);
            for (let e = a; e < r; e++) {
              const a = e + 1;
              n.push(`${a === t ? ">" : " "} ${a}: ${i[e]}`);
            }
            return n.join("\n");
          }(e.getShaderSource(t), n);
        }
        return a;
      }
      function rs(e, t) {
        const i = function (e) {
          switch (e) {
            case ht:
              return ["Linear", "( value )"];
            case dt:
              return ["sRGB", "( value )"];
            default:
              console.warn("THREE.WebGLProgram: Unsupported encoding:", e);
              return ["Linear", "( value )"];
          }
        }(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
      }
      function ss(e, t) {
        let i;
        switch (t) {
          case j:
            i = "Linear";
            break;
          case X:
            i = "Reinhard";
            break;
          case K:
            i = "OptimizedCineon";
            break;
          case Y:
            i = "ACESFilmic";
            break;
          case J:
            i = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t);
            i = "Linear";
        }
        return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }";
      }
      function os(e) {
        return e !== "";
      }
      function ls(e, t) {
        const i = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, i).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function cs(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
      }
      const hs = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function ds(e) {
        return e.replace(hs, us);
      }
      function us(e, t) {
        const i = xa[t];
        if (i === undefined) {
          throw new Error("Can not resolve #include <" + t + ">");
        }
        return ds(i);
      }
      const ps = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function ms(e) {
        return e.replace(ps, fs);
      }
      function fs(e, t, i, n) {
        let a = "";
        for (let e = parseInt(t); e < parseInt(i); e++) {
          a += n.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        }
        return a;
      }
      function gs(e) {
        let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        if (e.precision === "highp") {
          t += "\n#define HIGH_PRECISION";
        } else if (e.precision === "mediump") {
          t += "\n#define MEDIUM_PRECISION";
        } else if (e.precision === "lowp") {
          t += "\n#define LOW_PRECISION";
        }
        return t;
      }
      function _s(e, t, i, n) {
        const a = e.getContext();
        const r = i.defines;
        let c = i.vertexShader;
        let h = i.fragmentShader;
        const d = function (e) {
          let t = "SHADOWMAP_TYPE_BASIC";
          if (e.shadowMapType === s) {
            t = "SHADOWMAP_TYPE_PCF";
          } else if (e.shadowMapType === o) {
            t = "SHADOWMAP_TYPE_PCF_SOFT";
          } else if (e.shadowMapType === l) {
            t = "SHADOWMAP_TYPE_VSM";
          }
          return t;
        }(i);
        const u = function (e) {
          let t = "ENVMAP_TYPE_CUBE";
          if (e.envMap) {
            switch (e.envMapMode) {
              case Z:
              case Q:
                t = "ENVMAP_TYPE_CUBE";
                break;
              case ie:
                t = "ENVMAP_TYPE_CUBE_UV";
            }
          }
          return t;
        }(i);
        const p = function (e) {
          let t = "ENVMAP_MODE_REFLECTION";
          if (e.envMap && e.envMapMode === Q) {
            t = "ENVMAP_MODE_REFRACTION";
          }
          return t;
        }(i);
        const m = function (e) {
          let t = "ENVMAP_BLENDING_NONE";
          if (e.envMap) {
            switch (e.combine) {
              case V:
                t = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case G:
                t = "ENVMAP_BLENDING_MIX";
                break;
              case W:
                t = "ENVMAP_BLENDING_ADD";
            }
          }
          return t;
        }(i);
        const f = function (e) {
          const t = e.envMapCubeUVHeight;
          if (t === null) {
            return null;
          }
          const i = Math.log2(t) - 2;
          const n = 1 / t;
          return {
            texelWidth: 1 / (Math.max(Math.pow(2, i), 112) * 3),
            texelHeight: n,
            maxMip: i
          };
        }(i);
        const g = i.isWebGL2 ? "" : function (e) {
          return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || e.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(os).join("\n");
        }(i);
        const _ = function (e) {
          const t = [];
          for (const i in e) {
            const n = e[i];
            if (n !== false) {
              t.push("#define " + i + " " + n);
            }
          }
          return t.join("\n");
        }(r);
        const v = a.createProgram();
        let b;
        let y;
        let x = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
        if (i.isRawShaderMaterial) {
          b = [_].filter(os).join("\n");
          if (b.length > 0) {
            b += "\n";
          }
          y = [g, _].filter(os).join("\n");
          if (y.length > 0) {
            y += "\n";
          }
        } else {
          b = [gs(i), "#define SHADER_NAME " + i.shaderName, _, i.instancing ? "#define USE_INSTANCING" : "", i.instancingColor ? "#define USE_INSTANCING_COLOR" : "", i.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + p : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.displacementMap && i.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.skinning ? "#define USE_SKINNING" : "", i.morphTargets ? "#define USE_MORPHTARGETS" : "", i.morphNormals && i.flatShading === false ? "#define USE_MORPHNORMALS" : "", i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride : "", i.morphTargetsCount > 0 && i.isWebGL2 ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + d : "", i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(os).join("\n");
          y = [g, gs(i), "#define SHADER_NAME " + i.shaderName, _, i.useFog && i.fog ? "#define USE_FOG" : "", i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "", i.map ? "#define USE_MAP" : "", i.matcap ? "#define USE_MATCAP" : "", i.envMap ? "#define USE_ENVMAP" : "", i.envMap ? "#define " + u : "", i.envMap ? "#define " + p : "", i.envMap ? "#define " + m : "", f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "", f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "", f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "", i.lightMap ? "#define USE_LIGHTMAP" : "", i.aoMap ? "#define USE_AOMAP" : "", i.emissiveMap ? "#define USE_EMISSIVEMAP" : "", i.bumpMap ? "#define USE_BUMPMAP" : "", i.normalMap ? "#define USE_NORMALMAP" : "", i.normalMap && i.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", i.normalMap && i.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", i.clearcoat ? "#define USE_CLEARCOAT" : "", i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", i.iridescence ? "#define USE_IRIDESCENCE" : "", i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", i.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", i.specularMap ? "#define USE_SPECULARMAP" : "", i.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", i.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", i.metalnessMap ? "#define USE_METALNESSMAP" : "", i.alphaMap ? "#define USE_ALPHAMAP" : "", i.alphaTest ? "#define USE_ALPHATEST" : "", i.sheen ? "#define USE_SHEEN" : "", i.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", i.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", i.transmission ? "#define USE_TRANSMISSION" : "", i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", i.thicknessMap ? "#define USE_THICKNESSMAP" : "", i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", i.vertexTangents ? "#define USE_TANGENT" : "", i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "", i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", i.vertexUvs ? "#define USE_UV" : "", i.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", i.gradientMap ? "#define USE_GRADIENTMAP" : "", i.flatShading ? "#define FLAT_SHADED" : "", i.doubleSided ? "#define DOUBLE_SIDED" : "", i.flipSided ? "#define FLIP_SIDED" : "", i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", i.shadowMapEnabled ? "#define " + d : "", i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", i.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", i.logarithmicDepthBuffer && i.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", i.toneMapping !== q ? "#define TONE_MAPPING" : "", i.toneMapping !== q ? xa.tonemapping_pars_fragment : "", i.toneMapping !== q ? ss("toneMapping", i.toneMapping) : "", i.dithering ? "#define DITHERING" : "", i.opaque ? "#define OPAQUE" : "", xa.encodings_pars_fragment, rs("linearToOutputTexel", i.outputEncoding), i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "", "\n"].filter(os).join("\n");
        }
        c = ds(c);
        c = ls(c, i);
        c = cs(c, i);
        h = ds(h);
        h = ls(h, i);
        h = cs(h, i);
        c = ms(c);
        h = ms(h);
        if (i.isWebGL2 && i.isRawShaderMaterial !== true) {
          x = "#version 300 es\n";
          b = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + b;
          y = ["#define varying in", i.glslVersion === vt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", i.glslVersion === vt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y;
        }
        const w = x + y + h;
        const M = is(a, 35633, x + b + c);
        const S = is(a, 35632, w);
        a.attachShader(v, M);
        a.attachShader(v, S);
        if (i.index0AttributeName !== undefined) {
          a.bindAttribLocation(v, 0, i.index0AttributeName);
        } else if (i.morphTargets === true) {
          a.bindAttribLocation(v, 0, "position");
        }
        a.linkProgram(v);
        if (e.debug.checkShaderErrors) {
          const e = a.getProgramInfoLog(v).trim();
          const t = a.getShaderInfoLog(M).trim();
          const i = a.getShaderInfoLog(S).trim();
          let n = true;
          let r = true;
          if (a.getProgramParameter(v, 35714) === false) {
            n = false;
            const t = as(a, M, "vertex");
            const i = as(a, S, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + a.getError() + " - VALIDATE_STATUS " + a.getProgramParameter(v, 35715) + "\n\nProgram Info Log: " + e + "\n" + t + "\n" + i);
          } else if (e !== "") {
            console.warn("THREE.WebGLProgram: Program Info Log:", e);
          } else if (t === "" || i === "") {
            r = false;
          }
          if (r) {
            this.diagnostics = {
              runnable: n,
              programLog: e,
              vertexShader: {
                log: t,
                prefix: b
              },
              fragmentShader: {
                log: i,
                prefix: y
              }
            };
          }
        }
        let E;
        let T;
        a.deleteShader(M);
        a.deleteShader(S);
        this.getUniforms = function () {
          if (E === undefined) {
            E = new ts(a, v);
          }
          return E;
        };
        this.getAttributes = function () {
          if (T === undefined) {
            T = function (e, t) {
              const i = {};
              const n = e.getProgramParameter(t, 35721);
              for (let a = 0; a < n; a++) {
                const n = e.getActiveAttrib(t, a);
                const r = n.name;
                let s = 1;
                if (n.type === 35674) {
                  s = 2;
                }
                if (n.type === 35675) {
                  s = 3;
                }
                if (n.type === 35676) {
                  s = 4;
                }
                i[r] = {
                  type: n.type,
                  location: e.getAttribLocation(t, r),
                  locationSize: s
                };
              }
              return i;
            }(a, v);
          }
          return T;
        };
        this.destroy = function () {
          n.releaseStatesOfProgram(this);
          a.deleteProgram(v);
          this.program = undefined;
        };
        this.name = i.shaderName;
        this.id = ns++;
        this.cacheKey = t;
        this.usedTimes = 1;
        this.program = v;
        this.vertexShader = M;
        this.fragmentShader = S;
        return this;
      }
      let vs = 0;
      class bs {
        constructor() {
          this.shaderCache = new Map();
          this.materialCache = new Map();
        }
        update(e) {
          const t = e.vertexShader;
          const i = e.fragmentShader;
          const n = this._getShaderStage(t);
          const a = this._getShaderStage(i);
          const r = this._getShaderCacheForMaterial(e);
          if (r.has(n) === false) {
            r.add(n);
            n.usedTimes++;
          }
          if (r.has(a) === false) {
            r.add(a);
            a.usedTimes++;
          }
          return this;
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t) {
            e.usedTimes--;
            if (e.usedTimes === 0) {
              this.shaderCache.delete(e.code);
            }
          }
          this.materialCache.delete(e);
          return this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear();
          this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          if (i === undefined) {
            i = new Set();
            t.set(e, i);
          }
          return i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          if (i === undefined) {
            i = new ys(e);
            t.set(e, i);
          }
          return i;
        }
      }
      class ys {
        constructor(e) {
          this.id = vs++;
          this.code = e;
          this.usedTimes = 0;
        }
      }
      function xs(e, t, i, n, a, r, s) {
        const o = new Wi();
        const l = new bs();
        const c = [];
        const u = a.isWebGL2;
        const m = a.logarithmicDepthBuffer;
        const f = a.vertexTextures;
        let g = a.precision;
        const _ = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        return {
          getParameters: function (r, o, c, v, b) {
            const y = v.fog;
            const x = b.geometry;
            const w = r.isMeshStandardMaterial ? v.environment : null;
            const M = (r.isMeshStandardMaterial ? i : t).get(r.envMap || w);
            const S = M && M.mapping === ie ? M.image.height : null;
            const E = _[r.type];
            if (r.precision !== null) {
              g = a.getMaxPrecision(r.precision);
              if (g !== r.precision) {
                console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", g, "instead.");
              }
            }
            const T = x.morphAttributes.position || x.morphAttributes.normal || x.morphAttributes.color;
            const C = T !== undefined ? T.length : 0;
            let k;
            let A;
            let L;
            let R;
            let P = 0;
            if (x.morphAttributes.position !== undefined) {
              P = 1;
            }
            if (x.morphAttributes.normal !== undefined) {
              P = 2;
            }
            if (x.morphAttributes.color !== undefined) {
              P = 3;
            }
            if (E) {
              const e = Ma[E];
              k = e.vertexShader;
              A = e.fragmentShader;
            } else {
              k = r.vertexShader;
              A = r.fragmentShader;
              l.update(r);
              L = l.getVertexShaderID(r);
              R = l.getFragmentShaderID(r);
            }
            const D = e.getRenderTarget();
            const I = r.alphaTest > 0;
            const $ = r.clearcoat > 0;
            const z = r.iridescence > 0;
            return {
              isWebGL2: u,
              shaderID: E,
              shaderName: r.type,
              vertexShader: k,
              fragmentShader: A,
              defines: r.defines,
              customVertexShaderID: L,
              customFragmentShaderID: R,
              isRawShaderMaterial: r.isRawShaderMaterial === true,
              glslVersion: r.glslVersion,
              precision: g,
              instancing: b.isInstancedMesh === true,
              instancingColor: b.isInstancedMesh === true && b.instanceColor !== null,
              supportsVertexTextures: f,
              outputEncoding: D === null ? e.outputEncoding : D.isXRRenderTarget === true ? D.texture.encoding : ht,
              map: !!r.map,
              matcap: !!r.matcap,
              envMap: !!M,
              envMapMode: M && M.mapping,
              envMapCubeUVHeight: S,
              lightMap: !!r.lightMap,
              aoMap: !!r.aoMap,
              emissiveMap: !!r.emissiveMap,
              bumpMap: !!r.bumpMap,
              normalMap: !!r.normalMap,
              objectSpaceNormalMap: r.normalMapType === mt,
              tangentSpaceNormalMap: r.normalMapType === pt,
              decodeVideoTexture: !!r.map && r.map.isVideoTexture === true && r.map.encoding === dt,
              clearcoat: $,
              clearcoatMap: $ && !!r.clearcoatMap,
              clearcoatRoughnessMap: $ && !!r.clearcoatRoughnessMap,
              clearcoatNormalMap: $ && !!r.clearcoatNormalMap,
              iridescence: z,
              iridescenceMap: z && !!r.iridescenceMap,
              iridescenceThicknessMap: z && !!r.iridescenceThicknessMap,
              displacementMap: !!r.displacementMap,
              roughnessMap: !!r.roughnessMap,
              metalnessMap: !!r.metalnessMap,
              specularMap: !!r.specularMap,
              specularIntensityMap: !!r.specularIntensityMap,
              specularColorMap: !!r.specularColorMap,
              opaque: r.transparent === false && r.blending === p,
              alphaMap: !!r.alphaMap,
              alphaTest: I,
              gradientMap: !!r.gradientMap,
              sheen: r.sheen > 0,
              sheenColorMap: !!r.sheenColorMap,
              sheenRoughnessMap: !!r.sheenRoughnessMap,
              transmission: r.transmission > 0,
              transmissionMap: !!r.transmissionMap,
              thicknessMap: !!r.thicknessMap,
              combine: r.combine,
              vertexTangents: !!r.normalMap && !!x.attributes.tangent,
              vertexColors: r.vertexColors,
              vertexAlphas: r.vertexColors === true && !!x.attributes.color && x.attributes.color.itemSize === 4,
              vertexUvs: !!r.map || !!r.bumpMap || !!r.normalMap || !!r.specularMap || !!r.alphaMap || !!r.emissiveMap || !!r.roughnessMap || !!r.metalnessMap || !!r.clearcoatMap || !!r.clearcoatRoughnessMap || !!r.clearcoatNormalMap || !!r.iridescenceMap || !!r.iridescenceThicknessMap || !!r.displacementMap || !!r.transmissionMap || !!r.thicknessMap || !!r.specularIntensityMap || !!r.specularColorMap || !!r.sheenColorMap || !!r.sheenRoughnessMap,
              uvsVertexOnly: !r.map && !r.bumpMap && !r.normalMap && !r.specularMap && !r.alphaMap && !r.emissiveMap && !r.roughnessMap && !r.metalnessMap && !r.clearcoatNormalMap && !r.iridescenceMap && !r.iridescenceThicknessMap && !(r.transmission > 0) && !r.transmissionMap && !r.thicknessMap && !r.specularIntensityMap && !r.specularColorMap && !(r.sheen > 0) && !r.sheenColorMap && !r.sheenRoughnessMap && !!r.displacementMap,
              fog: !!y,
              useFog: r.fog === true,
              fogExp2: y && y.isFogExp2,
              flatShading: !!r.flatShading,
              sizeAttenuation: r.sizeAttenuation,
              logarithmicDepthBuffer: m,
              skinning: b.isSkinnedMesh === true,
              morphTargets: x.morphAttributes.position !== undefined,
              morphNormals: x.morphAttributes.normal !== undefined,
              morphColors: x.morphAttributes.color !== undefined,
              morphTargetsCount: C,
              morphTextureStride: P,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numSpotLightMaps: o.spotLightMap.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
              numClippingPlanes: s.numPlanes,
              numClipIntersection: s.numIntersection,
              dithering: r.dithering,
              shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: r.toneMapped ? e.toneMapping : q,
              physicallyCorrectLights: e.physicallyCorrectLights,
              premultipliedAlpha: r.premultipliedAlpha,
              doubleSided: r.side === d,
              flipSided: r.side === h,
              useDepthPacking: !!r.depthPacking,
              depthPacking: r.depthPacking || 0,
              index0AttributeName: r.index0AttributeName,
              extensionDerivatives: r.extensions && r.extensions.derivatives,
              extensionFragDepth: r.extensions && r.extensions.fragDepth,
              extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
              extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
              customProgramCacheKey: r.customProgramCacheKey()
            };
          },
          getProgramCacheKey: function (t) {
            const i = [];
            if (t.shaderID) {
              i.push(t.shaderID);
            } else {
              i.push(t.customVertexShaderID);
              i.push(t.customFragmentShaderID);
            }
            if (t.defines !== undefined) {
              for (const e in t.defines) {
                i.push(e);
                i.push(t.defines[e]);
              }
            }
            if (t.isRawShaderMaterial === false) {
              (function (e, t) {
                e.push(t.precision);
                e.push(t.outputEncoding);
                e.push(t.envMapMode);
                e.push(t.envMapCubeUVHeight);
                e.push(t.combine);
                e.push(t.vertexUvs);
                e.push(t.fogExp2);
                e.push(t.sizeAttenuation);
                e.push(t.morphTargetsCount);
                e.push(t.morphAttributeCount);
                e.push(t.numDirLights);
                e.push(t.numPointLights);
                e.push(t.numSpotLights);
                e.push(t.numSpotLightMaps);
                e.push(t.numHemiLights);
                e.push(t.numRectAreaLights);
                e.push(t.numDirLightShadows);
                e.push(t.numPointLightShadows);
                e.push(t.numSpotLightShadows);
                e.push(t.numSpotLightShadowsWithMaps);
                e.push(t.shadowMapType);
                e.push(t.toneMapping);
                e.push(t.numClippingPlanes);
                e.push(t.numClipIntersection);
                e.push(t.depthPacking);
              })(i, t);
              (function (e, t) {
                o.disableAll();
                if (t.isWebGL2) {
                  o.enable(0);
                }
                if (t.supportsVertexTextures) {
                  o.enable(1);
                }
                if (t.instancing) {
                  o.enable(2);
                }
                if (t.instancingColor) {
                  o.enable(3);
                }
                if (t.map) {
                  o.enable(4);
                }
                if (t.matcap) {
                  o.enable(5);
                }
                if (t.envMap) {
                  o.enable(6);
                }
                if (t.lightMap) {
                  o.enable(7);
                }
                if (t.aoMap) {
                  o.enable(8);
                }
                if (t.emissiveMap) {
                  o.enable(9);
                }
                if (t.bumpMap) {
                  o.enable(10);
                }
                if (t.normalMap) {
                  o.enable(11);
                }
                if (t.objectSpaceNormalMap) {
                  o.enable(12);
                }
                if (t.tangentSpaceNormalMap) {
                  o.enable(13);
                }
                if (t.clearcoat) {
                  o.enable(14);
                }
                if (t.clearcoatMap) {
                  o.enable(15);
                }
                if (t.clearcoatRoughnessMap) {
                  o.enable(16);
                }
                if (t.clearcoatNormalMap) {
                  o.enable(17);
                }
                if (t.iridescence) {
                  o.enable(18);
                }
                if (t.iridescenceMap) {
                  o.enable(19);
                }
                if (t.iridescenceThicknessMap) {
                  o.enable(20);
                }
                if (t.displacementMap) {
                  o.enable(21);
                }
                if (t.specularMap) {
                  o.enable(22);
                }
                if (t.roughnessMap) {
                  o.enable(23);
                }
                if (t.metalnessMap) {
                  o.enable(24);
                }
                if (t.gradientMap) {
                  o.enable(25);
                }
                if (t.alphaMap) {
                  o.enable(26);
                }
                if (t.alphaTest) {
                  o.enable(27);
                }
                if (t.vertexColors) {
                  o.enable(28);
                }
                if (t.vertexAlphas) {
                  o.enable(29);
                }
                if (t.vertexUvs) {
                  o.enable(30);
                }
                if (t.vertexTangents) {
                  o.enable(31);
                }
                if (t.uvsVertexOnly) {
                  o.enable(32);
                }
                e.push(o.mask);
                o.disableAll();
                if (t.fog) {
                  o.enable(0);
                }
                if (t.useFog) {
                  o.enable(1);
                }
                if (t.flatShading) {
                  o.enable(2);
                }
                if (t.logarithmicDepthBuffer) {
                  o.enable(3);
                }
                if (t.skinning) {
                  o.enable(4);
                }
                if (t.morphTargets) {
                  o.enable(5);
                }
                if (t.morphNormals) {
                  o.enable(6);
                }
                if (t.morphColors) {
                  o.enable(7);
                }
                if (t.premultipliedAlpha) {
                  o.enable(8);
                }
                if (t.shadowMapEnabled) {
                  o.enable(9);
                }
                if (t.physicallyCorrectLights) {
                  o.enable(10);
                }
                if (t.doubleSided) {
                  o.enable(11);
                }
                if (t.flipSided) {
                  o.enable(12);
                }
                if (t.useDepthPacking) {
                  o.enable(13);
                }
                if (t.dithering) {
                  o.enable(14);
                }
                if (t.specularIntensityMap) {
                  o.enable(15);
                }
                if (t.specularColorMap) {
                  o.enable(16);
                }
                if (t.transmission) {
                  o.enable(17);
                }
                if (t.transmissionMap) {
                  o.enable(18);
                }
                if (t.thicknessMap) {
                  o.enable(19);
                }
                if (t.sheen) {
                  o.enable(20);
                }
                if (t.sheenColorMap) {
                  o.enable(21);
                }
                if (t.sheenRoughnessMap) {
                  o.enable(22);
                }
                if (t.decodeVideoTexture) {
                  o.enable(23);
                }
                if (t.opaque) {
                  o.enable(24);
                }
                e.push(o.mask);
              })(i, t);
              i.push(e.outputEncoding);
            }
            i.push(t.customProgramCacheKey);
            return i.join();
          },
          getUniforms: function (e) {
            const t = _[e.type];
            let i;
            if (t) {
              const e = Ma[t];
              i = na.clone(e.uniforms);
            } else {
              i = e.uniforms;
            }
            return i;
          },
          acquireProgram: function (t, i) {
            let n;
            for (let e = 0, t = c.length; e < t; e++) {
              const t = c[e];
              if (t.cacheKey === i) {
                n = t;
                ++n.usedTimes;
                break;
              }
            }
            if (n === undefined) {
              n = new _s(e, i, t, r);
              c.push(n);
            }
            return n;
          },
          releaseProgram: function (e) {
            if (--e.usedTimes == 0) {
              const t = c.indexOf(e);
              c[t] = c[c.length - 1];
              c.pop();
              e.destroy();
            }
          },
          releaseShaderCache: function (e) {
            l.remove(e);
          },
          programs: c,
          dispose: function () {
            l.dispose();
          }
        };
      }
      function ws() {
        let e = new WeakMap();
        return {
          get: function (t) {
            let i = e.get(t);
            if (i === undefined) {
              i = {};
              e.set(t, i);
            }
            return i;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, i, n) {
            e.get(t)[i] = n;
          },
          dispose: function () {
            e = new WeakMap();
          }
        };
      }
      function Ms(e, t) {
        if (e.groupOrder !== t.groupOrder) {
          return e.groupOrder - t.groupOrder;
        } else if (e.renderOrder !== t.renderOrder) {
          return e.renderOrder - t.renderOrder;
        } else if (e.material.id !== t.material.id) {
          return e.material.id - t.material.id;
        } else if (e.z !== t.z) {
          return e.z - t.z;
        } else {
          return e.id - t.id;
        }
      }
      function Ss(e, t) {
        if (e.groupOrder !== t.groupOrder) {
          return e.groupOrder - t.groupOrder;
        } else if (e.renderOrder !== t.renderOrder) {
          return e.renderOrder - t.renderOrder;
        } else if (e.z !== t.z) {
          return t.z - e.z;
        } else {
          return e.id - t.id;
        }
      }
      function Es() {
        const e = [];
        let t = 0;
        const i = [];
        const n = [];
        const a = [];
        function r(i, n, a, r, s, o) {
          let l = e[t];
          if (l === undefined) {
            l = {
              id: i.id,
              object: i,
              geometry: n,
              material: a,
              groupOrder: r,
              renderOrder: i.renderOrder,
              z: s,
              group: o
            };
            e[t] = l;
          } else {
            l.id = i.id;
            l.object = i;
            l.geometry = n;
            l.material = a;
            l.groupOrder = r;
            l.renderOrder = i.renderOrder;
            l.z = s;
            l.group = o;
          }
          t++;
          return l;
        }
        return {
          opaque: i,
          transmissive: n,
          transparent: a,
          init: function () {
            t = 0;
            i.length = 0;
            n.length = 0;
            a.length = 0;
          },
          push: function (e, t, s, o, l, c) {
            const h = r(e, t, s, o, l, c);
            if (s.transmission > 0) {
              n.push(h);
            } else if (s.transparent === true) {
              a.push(h);
            } else {
              i.push(h);
            }
          },
          unshift: function (e, t, s, o, l, c) {
            const h = r(e, t, s, o, l, c);
            if (s.transmission > 0) {
              n.unshift(h);
            } else if (s.transparent === true) {
              a.unshift(h);
            } else {
              i.unshift(h);
            }
          },
          finish: function () {
            for (let i = t, n = e.length; i < n; i++) {
              const t = e[i];
              if (t.id === null) {
                break;
              }
              t.id = null;
              t.object = null;
              t.geometry = null;
              t.material = null;
              t.group = null;
            }
          },
          sort: function (e, t) {
            if (i.length > 1) {
              i.sort(e || Ms);
            }
            if (n.length > 1) {
              n.sort(t || Ss);
            }
            if (a.length > 1) {
              a.sort(t || Ss);
            }
          }
        };
      }
      function Ts() {
        let e = new WeakMap();
        return {
          get: function (t, i) {
            const n = e.get(t);
            let a;
            if (n === undefined) {
              a = new Es();
              e.set(t, [a]);
            } else if (i >= n.length) {
              a = new Es();
              n.push(a);
            } else {
              a = n[i];
            }
            return a;
          },
          dispose: function () {
            e = new WeakMap();
          }
        };
      }
      function Cs() {
        const e = {};
        return {
          get: function (t) {
            if (e[t.id] !== undefined) {
              return e[t.id];
            }
            let i;
            switch (t.type) {
              case "DirectionalLight":
                i = {
                  direction: new ni(),
                  color: new Wt()
                };
                break;
              case "SpotLight":
                i = {
                  position: new ni(),
                  direction: new ni(),
                  color: new Wt(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                i = {
                  position: new ni(),
                  color: new Wt(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                i = {
                  direction: new ni(),
                  skyColor: new Wt(),
                  groundColor: new Wt()
                };
                break;
              case "RectAreaLight":
                i = {
                  color: new Wt(),
                  position: new ni(),
                  halfWidth: new ni(),
                  halfHeight: new ni()
                };
            }
            e[t.id] = i;
            return i;
          }
        };
      }
      let ks = 0;
      function As(e, t) {
        return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0);
      }
      function Ls(e, t) {
        const i = new Cs();
        const n = function () {
          const e = {};
          return {
            get: function (t) {
              if (e[t.id] !== undefined) {
                return e[t.id];
              }
              let i;
              switch (t.type) {
                case "DirectionalLight":
                case "SpotLight":
                  i = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Rt()
                  };
                  break;
                case "PointLight":
                  i = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Rt(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1000
                  };
              }
              e[t.id] = i;
              return i;
            }
          };
        }();
        const a = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0
        };
        for (let e = 0; e < 9; e++) {
          a.probe.push(new ni());
        }
        const r = new ni();
        const s = new Ii();
        const o = new Ii();
        return {
          setup: function (r, s) {
            let o = 0;
            let l = 0;
            let c = 0;
            for (let e = 0; e < 9; e++) {
              a.probe[e].set(0, 0, 0);
            }
            let h = 0;
            let d = 0;
            let u = 0;
            let p = 0;
            let m = 0;
            let f = 0;
            let g = 0;
            let _ = 0;
            let v = 0;
            let b = 0;
            r.sort(As);
            const y = s !== true ? Math.PI : 1;
            for (let e = 0, t = r.length; e < t; e++) {
              const t = r[e];
              const s = t.color;
              const x = t.intensity;
              const w = t.distance;
              const M = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
              if (t.isAmbientLight) {
                o += s.r * x * y;
                l += s.g * x * y;
                c += s.b * x * y;
              } else if (t.isLightProbe) {
                for (let e = 0; e < 9; e++) {
                  a.probe[e].addScaledVector(t.sh.coefficients[e], x);
                }
              } else if (t.isDirectionalLight) {
                const e = i.get(t);
                e.color.copy(t.color).multiplyScalar(t.intensity * y);
                if (t.castShadow) {
                  const e = t.shadow;
                  const i = n.get(t);
                  i.shadowBias = e.bias;
                  i.shadowNormalBias = e.normalBias;
                  i.shadowRadius = e.radius;
                  i.shadowMapSize = e.mapSize;
                  a.directionalShadow[h] = i;
                  a.directionalShadowMap[h] = M;
                  a.directionalShadowMatrix[h] = t.shadow.matrix;
                  f++;
                }
                a.directional[h] = e;
                h++;
              } else if (t.isSpotLight) {
                const e = i.get(t);
                e.position.setFromMatrixPosition(t.matrixWorld);
                e.color.copy(s).multiplyScalar(x * y);
                e.distance = w;
                e.coneCos = Math.cos(t.angle);
                e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra));
                e.decay = t.decay;
                a.spot[u] = e;
                const r = t.shadow;
                if (t.map) {
                  a.spotLightMap[v] = t.map;
                  v++;
                  r.updateMatrices(t);
                  if (t.castShadow) {
                    b++;
                  }
                }
                a.spotLightMatrix[u] = r.matrix;
                if (t.castShadow) {
                  const e = n.get(t);
                  e.shadowBias = r.bias;
                  e.shadowNormalBias = r.normalBias;
                  e.shadowRadius = r.radius;
                  e.shadowMapSize = r.mapSize;
                  a.spotShadow[u] = e;
                  a.spotShadowMap[u] = M;
                  _++;
                }
                u++;
              } else if (t.isRectAreaLight) {
                const e = i.get(t);
                e.color.copy(s).multiplyScalar(x);
                e.halfWidth.set(t.width * 0.5, 0, 0);
                e.halfHeight.set(0, t.height * 0.5, 0);
                a.rectArea[p] = e;
                p++;
              } else if (t.isPointLight) {
                const e = i.get(t);
                e.color.copy(t.color).multiplyScalar(t.intensity * y);
                e.distance = t.distance;
                e.decay = t.decay;
                if (t.castShadow) {
                  const e = t.shadow;
                  const i = n.get(t);
                  i.shadowBias = e.bias;
                  i.shadowNormalBias = e.normalBias;
                  i.shadowRadius = e.radius;
                  i.shadowMapSize = e.mapSize;
                  i.shadowCameraNear = e.camera.near;
                  i.shadowCameraFar = e.camera.far;
                  a.pointShadow[d] = i;
                  a.pointShadowMap[d] = M;
                  a.pointShadowMatrix[d] = t.shadow.matrix;
                  g++;
                }
                a.point[d] = e;
                d++;
              } else if (t.isHemisphereLight) {
                const e = i.get(t);
                e.skyColor.copy(t.color).multiplyScalar(x * y);
                e.groundColor.copy(t.groundColor).multiplyScalar(x * y);
                a.hemi[m] = e;
                m++;
              }
            }
            if (p > 0) {
              if (t.isWebGL2 || e.has("OES_texture_float_linear") === true) {
                a.rectAreaLTC1 = wa.LTC_FLOAT_1;
                a.rectAreaLTC2 = wa.LTC_FLOAT_2;
              } else if (e.has("OES_texture_half_float_linear") === true) {
                a.rectAreaLTC1 = wa.LTC_HALF_1;
                a.rectAreaLTC2 = wa.LTC_HALF_2;
              } else {
                console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
              }
            }
            a.ambient[0] = o;
            a.ambient[1] = l;
            a.ambient[2] = c;
            const x = a.hash;
            if (x.directionalLength !== h || x.pointLength !== d || x.spotLength !== u || x.rectAreaLength !== p || x.hemiLength !== m || x.numDirectionalShadows !== f || x.numPointShadows !== g || x.numSpotShadows !== _ || x.numSpotMaps !== v) {
              a.directional.length = h;
              a.spot.length = u;
              a.rectArea.length = p;
              a.point.length = d;
              a.hemi.length = m;
              a.directionalShadow.length = f;
              a.directionalShadowMap.length = f;
              a.pointShadow.length = g;
              a.pointShadowMap.length = g;
              a.spotShadow.length = _;
              a.spotShadowMap.length = _;
              a.directionalShadowMatrix.length = f;
              a.pointShadowMatrix.length = g;
              a.spotLightMatrix.length = _ + v - b;
              a.spotLightMap.length = v;
              a.numSpotLightShadowsWithMaps = b;
              x.directionalLength = h;
              x.pointLength = d;
              x.spotLength = u;
              x.rectAreaLength = p;
              x.hemiLength = m;
              x.numDirectionalShadows = f;
              x.numPointShadows = g;
              x.numSpotShadows = _;
              x.numSpotMaps = v;
              a.version = ks++;
            }
          },
          setupView: function (e, t) {
            let i = 0;
            let n = 0;
            let l = 0;
            let c = 0;
            let h = 0;
            const d = t.matrixWorldInverse;
            for (let t = 0, u = e.length; t < u; t++) {
              const u = e[t];
              if (u.isDirectionalLight) {
                const e = a.directional[i];
                e.direction.setFromMatrixPosition(u.matrixWorld);
                r.setFromMatrixPosition(u.target.matrixWorld);
                e.direction.sub(r);
                e.direction.transformDirection(d);
                i++;
              } else if (u.isSpotLight) {
                const e = a.spot[l];
                e.position.setFromMatrixPosition(u.matrixWorld);
                e.position.applyMatrix4(d);
                e.direction.setFromMatrixPosition(u.matrixWorld);
                r.setFromMatrixPosition(u.target.matrixWorld);
                e.direction.sub(r);
                e.direction.transformDirection(d);
                l++;
              } else if (u.isRectAreaLight) {
                const e = a.rectArea[c];
                e.position.setFromMatrixPosition(u.matrixWorld);
                e.position.applyMatrix4(d);
                o.identity();
                s.copy(u.matrixWorld);
                s.premultiply(d);
                o.extractRotation(s);
                e.halfWidth.set(u.width * 0.5, 0, 0);
                e.halfHeight.set(0, u.height * 0.5, 0);
                e.halfWidth.applyMatrix4(o);
                e.halfHeight.applyMatrix4(o);
                c++;
              } else if (u.isPointLight) {
                const e = a.point[n];
                e.position.setFromMatrixPosition(u.matrixWorld);
                e.position.applyMatrix4(d);
                n++;
              } else if (u.isHemisphereLight) {
                const e = a.hemi[h];
                e.direction.setFromMatrixPosition(u.matrixWorld);
                e.direction.transformDirection(d);
                h++;
              }
            }
          },
          state: a
        };
      }
      function Rs(e, t) {
        const i = new Ls(e, t);
        const n = [];
        const a = [];
        return {
          init: function () {
            n.length = 0;
            a.length = 0;
          },
          state: {
            lightsArray: n,
            shadowsArray: a,
            lights: i
          },
          setupLights: function (e) {
            i.setup(n, e);
          },
          setupLightsView: function (e) {
            i.setupView(n, e);
          },
          pushLight: function (e) {
            n.push(e);
          },
          pushShadow: function (e) {
            a.push(e);
          }
        };
      }
      function Ps(e, t) {
        let i = new WeakMap();
        return {
          get: function (n, a = 0) {
            const r = i.get(n);
            let s;
            if (r === undefined) {
              s = new Rs(e, t);
              i.set(n, [s]);
            } else if (a >= r.length) {
              s = new Rs(e, t);
              r.push(s);
            } else {
              s = r[a];
            }
            return s;
          },
          dispose: function () {
            i = new WeakMap();
          }
        };
      }
      class Ds extends bn {
        constructor(e) {
          super();
          this.isMeshDepthMaterial = true;
          this.type = "MeshDepthMaterial";
          this.depthPacking = 3200;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.wireframe = false;
          this.wireframeLinewidth = 1;
          this.setValues(e);
        }
        copy(e) {
          super.copy(e);
          this.depthPacking = e.depthPacking;
          this.map = e.map;
          this.alphaMap = e.alphaMap;
          this.displacementMap = e.displacementMap;
          this.displacementScale = e.displacementScale;
          this.displacementBias = e.displacementBias;
          this.wireframe = e.wireframe;
          this.wireframeLinewidth = e.wireframeLinewidth;
          return this;
        }
      }
      class Is extends bn {
        constructor(e) {
          super();
          this.isMeshDistanceMaterial = true;
          this.type = "MeshDistanceMaterial";
          this.referencePosition = new ni();
          this.nearDistance = 1;
          this.farDistance = 1000;
          this.map = null;
          this.alphaMap = null;
          this.displacementMap = null;
          this.displacementScale = 1;
          this.displacementBias = 0;
          this.setValues(e);
        }
        copy(e) {
          super.copy(e);
          this.referencePosition.copy(e.referencePosition);
          this.nearDistance = e.nearDistance;
          this.farDistance = e.farDistance;
          this.map = e.map;
          this.alphaMap = e.alphaMap;
          this.displacementMap = e.displacementMap;
          this.displacementScale = e.displacementScale;
          this.displacementBias = e.displacementBias;
          return this;
        }
      }
      const $s = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
      const zs = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
      function Ns(e, t, i) {
        let n = new _a();
        const a = new Rt();
        const r = new Rt();
        const o = new Zt();
        const p = new Ds({
          depthPacking: ut
        });
        const m = new Is();
        const f = {};
        const g = i.maxTextureSize;
        const _ = {
          0: h,
          1: c,
          2: d
        };
        const v = new aa({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new Rt()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: $s,
          fragmentShader: zs
        });
        const b = v.clone();
        b.defines.HORIZONTAL_PASS = 1;
        const y = new In();
        y.setAttribute("position", new Mn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
        const x = new Zn(y, v);
        const w = this;
        function M(i, n) {
          const r = t.update(x);
          if (v.defines.VSM_SAMPLES !== i.blurSamples) {
            v.defines.VSM_SAMPLES = i.blurSamples;
            b.defines.VSM_SAMPLES = i.blurSamples;
            v.needsUpdate = true;
            b.needsUpdate = true;
          }
          if (i.mapPass === null) {
            i.mapPass = new Qt(a.x, a.y);
          }
          v.uniforms.shadow_pass.value = i.map.texture;
          v.uniforms.resolution.value = i.mapSize;
          v.uniforms.radius.value = i.radius;
          e.setRenderTarget(i.mapPass);
          e.clear();
          e.renderBufferDirect(n, null, r, v, x, null);
          b.uniforms.shadow_pass.value = i.mapPass.texture;
          b.uniforms.resolution.value = i.mapSize;
          b.uniforms.radius.value = i.radius;
          e.setRenderTarget(i.map);
          e.clear();
          e.renderBufferDirect(n, null, r, b, x, null);
        }
        function S(t, i, n, a, r, s) {
          let o = null;
          const c = n.isPointLight === true ? t.customDistanceMaterial : t.customDepthMaterial;
          o = c !== undefined ? c : n.isPointLight === true ? m : p;
          if (e.localClippingEnabled && i.clipShadows === true && Array.isArray(i.clippingPlanes) && i.clippingPlanes.length !== 0 || i.displacementMap && i.displacementScale !== 0 || i.alphaMap && i.alphaTest > 0) {
            const e = o.uuid;
            const t = i.uuid;
            let n = f[e];
            if (n === undefined) {
              n = {};
              f[e] = n;
            }
            let a = n[t];
            if (a === undefined) {
              a = o.clone();
              n[t] = a;
            }
            o = a;
          }
          o.visible = i.visible;
          o.wireframe = i.wireframe;
          o.side = s === l ? i.shadowSide !== null ? i.shadowSide : i.side : i.shadowSide !== null ? i.shadowSide : _[i.side];
          o.alphaMap = i.alphaMap;
          o.alphaTest = i.alphaTest;
          o.clipShadows = i.clipShadows;
          o.clippingPlanes = i.clippingPlanes;
          o.clipIntersection = i.clipIntersection;
          o.displacementMap = i.displacementMap;
          o.displacementScale = i.displacementScale;
          o.displacementBias = i.displacementBias;
          o.wireframeLinewidth = i.wireframeLinewidth;
          o.linewidth = i.linewidth;
          if (n.isPointLight === true && o.isMeshDistanceMaterial === true) {
            o.referencePosition.setFromMatrixPosition(n.matrixWorld);
            o.nearDistance = a;
            o.farDistance = r;
          }
          return o;
        }
        function E(i, a, r, s, o) {
          if (i.visible === false) {
            return;
          }
          if (i.layers.test(a.layers) && (i.isMesh || i.isLine || i.isPoints) && (i.castShadow || i.receiveShadow && o === l) && (!i.frustumCulled || n.intersectsObject(i))) {
            i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
            const n = t.update(i);
            const a = i.material;
            if (Array.isArray(a)) {
              const t = n.groups;
              for (let l = 0, c = t.length; l < c; l++) {
                const c = t[l];
                const h = a[c.materialIndex];
                if (h && h.visible) {
                  const t = S(i, h, s, r.near, r.far, o);
                  e.renderBufferDirect(r, null, n, t, i, c);
                }
              }
            } else if (a.visible) {
              const t = S(i, a, s, r.near, r.far, o);
              e.renderBufferDirect(r, null, n, t, i, null);
            }
          }
          const c = i.children;
          for (let e = 0, t = c.length; e < t; e++) {
            E(c[e], a, r, s, o);
          }
        }
        this.enabled = false;
        this.autoUpdate = true;
        this.needsUpdate = false;
        this.type = s;
        this.render = function (t, i, s) {
          if (w.enabled === false) {
            return;
          }
          if (w.autoUpdate === false && w.needsUpdate === false) {
            return;
          }
          if (t.length === 0) {
            return;
          }
          const c = e.getRenderTarget();
          const h = e.getActiveCubeFace();
          const d = e.getActiveMipmapLevel();
          const p = e.state;
          p.setBlending(u);
          p.buffers.color.setClear(1, 1, 1, 1);
          p.buffers.depth.setTest(true);
          p.setScissorTest(false);
          for (let c = 0, h = t.length; c < h; c++) {
            const h = t[c];
            const d = h.shadow;
            if (d === undefined) {
              console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
              continue;
            }
            if (d.autoUpdate === false && d.needsUpdate === false) {
              continue;
            }
            a.copy(d.mapSize);
            const u = d.getFrameExtents();
            a.multiply(u);
            r.copy(d.mapSize);
            if (a.x > g || a.y > g) {
              if (a.x > g) {
                r.x = Math.floor(g / u.x);
                a.x = r.x * u.x;
                d.mapSize.x = r.x;
              }
              if (a.y > g) {
                r.y = Math.floor(g / u.y);
                a.y = r.y * u.y;
                d.mapSize.y = r.y;
              }
            }
            if (d.map === null) {
              const e = this.type !== l ? {
                minFilter: se,
                magFilter: se
              } : {};
              d.map = new Qt(a.x, a.y, e);
              d.map.texture.name = h.name + ".shadowMap";
              d.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(d.map);
            e.clear();
            const m = d.getViewportCount();
            for (let e = 0; e < m; e++) {
              const t = d.getViewport(e);
              o.set(r.x * t.x, r.y * t.y, r.x * t.z, r.y * t.w);
              p.viewport(o);
              d.updateMatrices(h, e);
              n = d.getFrustum();
              E(i, s, d.camera, h, this.type);
            }
            if (d.isPointLightShadow !== true && this.type === l) {
              M(d, s);
            }
            d.needsUpdate = false;
          }
          w.needsUpdate = false;
          e.setRenderTarget(c, h, d);
        };
      }
      function Os(e, t, a) {
        const s = a.isWebGL2;
        const o = new function () {
          let t = false;
          const i = new Zt();
          let n = null;
          const a = new Zt(0, 0, 0, 0);
          return {
            setMask: function (i) {
              if (n !== i && !t) {
                e.colorMask(i, i, i, i);
                n = i;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t, n, r, s, o) {
              if (o === true) {
                t *= s;
                n *= s;
                r *= s;
              }
              i.set(t, n, r, s);
              if (a.equals(i) === false) {
                e.clearColor(t, n, r, s);
                a.copy(i);
              }
            },
            reset: function () {
              t = false;
              n = null;
              a.set(-1, 0, 0, 0);
            }
          };
        }();
        const l = new function () {
          let t = false;
          let i = null;
          let n = null;
          let a = null;
          return {
            setTest: function (e) {
              if (e) {
                xe(2929);
              } else {
                we(2929);
              }
            },
            setMask: function (n) {
              if (i !== n && !t) {
                e.depthMask(n);
                i = n;
              }
            },
            setFunc: function (t) {
              if (n !== t) {
                if (t) {
                  switch (t) {
                    case I:
                      e.depthFunc(512);
                      break;
                    case z:
                      e.depthFunc(519);
                      break;
                    case N:
                      e.depthFunc(513);
                      break;
                    case O:
                      e.depthFunc(515);
                      break;
                    case U:
                      e.depthFunc(514);
                      break;
                    case F:
                      e.depthFunc(518);
                      break;
                    case B:
                      e.depthFunc(516);
                      break;
                    case H:
                      e.depthFunc(517);
                      break;
                    default:
                      e.depthFunc(515);
                  }
                } else {
                  e.depthFunc(515);
                }
                n = t;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              if (a !== t) {
                e.clearDepth(t);
                a = t;
              }
            },
            reset: function () {
              t = false;
              i = null;
              n = null;
              a = null;
            }
          };
        }();
        const c = new function () {
          let t = false;
          let i = null;
          let n = null;
          let a = null;
          let r = null;
          let s = null;
          let o = null;
          let l = null;
          let c = null;
          return {
            setTest: function (e) {
              if (!t) {
                if (e) {
                  xe(2960);
                } else {
                  we(2960);
                }
              }
            },
            setMask: function (n) {
              if (i !== n && !t) {
                e.stencilMask(n);
                i = n;
              }
            },
            setFunc: function (t, i, s) {
              if (n !== t || a !== i || r !== s) {
                e.stencilFunc(t, i, s);
                n = t;
                a = i;
                r = s;
              }
            },
            setOp: function (t, i, n) {
              if (s !== t || o !== i || l !== n) {
                e.stencilOp(t, i, n);
                s = t;
                o = i;
                l = n;
              }
            },
            setLocked: function (e) {
              t = e;
            },
            setClear: function (t) {
              if (c !== t) {
                e.clearStencil(t);
                c = t;
              }
            },
            reset: function () {
              t = false;
              i = null;
              n = null;
              a = null;
              r = null;
              s = null;
              o = null;
              l = null;
              c = null;
            }
          };
        }();
        const $ = new WeakMap();
        const V = new WeakMap();
        let G = {};
        let W = {};
        let q = new WeakMap();
        let j = [];
        let X = null;
        let K = false;
        let Y = null;
        let J = null;
        let Z = null;
        let Q = null;
        let ee = null;
        let te = null;
        let ie = null;
        let ne = false;
        let ae = null;
        let re = null;
        let se = null;
        let oe = null;
        let le = null;
        const ce = e.getParameter(35661);
        let he = false;
        let de = 0;
        const ue = e.getParameter(7938);
        if (ue.indexOf("WebGL") !== -1) {
          de = parseFloat(/^WebGL (\d)/.exec(ue)[1]);
          he = de >= 1;
        } else if (ue.indexOf("OpenGL ES") !== -1) {
          de = parseFloat(/^OpenGL ES (\d)/.exec(ue)[1]);
          he = de >= 2;
        }
        let pe = null;
        let me = {};
        const fe = e.getParameter(3088);
        const ge = e.getParameter(2978);
        const _e = new Zt().fromArray(fe);
        const ve = new Zt().fromArray(ge);
        function be(t, i, n) {
          const a = new Uint8Array(4);
          const r = e.createTexture();
          e.bindTexture(t, r);
          e.texParameteri(t, 10241, 9728);
          e.texParameteri(t, 10240, 9728);
          for (let t = 0; t < n; t++) {
            e.texImage2D(i + t, 0, 6408, 1, 1, 0, 6408, 5121, a);
          }
          return r;
        }
        const ye = {};
        function xe(t) {
          if (G[t] !== true) {
            e.enable(t);
            G[t] = true;
          }
        }
        function we(t) {
          if (G[t] !== false) {
            e.disable(t);
            G[t] = false;
          }
        }
        ye[3553] = be(3553, 3553, 1);
        ye[34067] = be(34067, 34069, 6);
        o.setClear(0, 0, 0, 1);
        l.setClear(1);
        c.setClear(0);
        xe(2929);
        l.setFunc(O);
        Te(false);
        Ce(n);
        xe(2884);
        Ee(u);
        const Me = {
          [v]: 32774,
          [b]: 32778,
          [y]: 32779
        };
        if (s) {
          Me[x] = 32775;
          Me[w] = 32776;
        } else {
          const e = t.get("EXT_blend_minmax");
          if (e !== null) {
            Me[x] = e.MIN_EXT;
            Me[w] = e.MAX_EXT;
          }
        }
        const Se = {
          [M]: 0,
          [S]: 1,
          [E]: 768,
          [C]: 770,
          [D]: 776,
          [R]: 774,
          [A]: 772,
          [T]: 769,
          [k]: 771,
          [P]: 775,
          [L]: 773
        };
        function Ee(t, i, n, a, r, s, o, l) {
          if (t !== u) {
            if (K === false) {
              xe(3042);
              K = true;
            }
            if (t === _) {
              r = r || i;
              s = s || n;
              o = o || a;
              if (i !== J || r !== ee) {
                e.blendEquationSeparate(Me[i], Me[r]);
                J = i;
                ee = r;
              }
              if (n !== Z || a !== Q || s !== te || o !== ie) {
                e.blendFuncSeparate(Se[n], Se[a], Se[s], Se[o]);
                Z = n;
                Q = a;
                te = s;
                ie = o;
              }
              Y = t;
              ne = null;
            } else if (t !== Y || l !== ne) {
              if (J !== v || ee !== v) {
                e.blendEquation(32774);
                J = v;
                ee = v;
              }
              if (l) {
                switch (t) {
                  case p:
                    e.blendFuncSeparate(1, 771, 1, 771);
                    break;
                  case m:
                    e.blendFunc(1, 1);
                    break;
                  case f:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case g:
                    e.blendFuncSeparate(0, 768, 0, 770);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              } else {
                switch (t) {
                  case p:
                    e.blendFuncSeparate(770, 771, 1, 771);
                    break;
                  case m:
                    e.blendFunc(770, 1);
                    break;
                  case f:
                    e.blendFuncSeparate(0, 769, 0, 1);
                    break;
                  case g:
                    e.blendFunc(0, 768);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              }
              Z = null;
              Q = null;
              te = null;
              ie = null;
              Y = t;
              ne = l;
            }
          } else if (K === true) {
            we(3042);
            K = false;
          }
        }
        function Te(t) {
          if (ae !== t) {
            if (t) {
              e.frontFace(2304);
            } else {
              e.frontFace(2305);
            }
            ae = t;
          }
        }
        function Ce(t) {
          if (t !== i) {
            xe(2884);
            if (t !== re) {
              if (t === n) {
                e.cullFace(1029);
              } else if (t === r) {
                e.cullFace(1028);
              } else {
                e.cullFace(1032);
              }
            }
          } else {
            we(2884);
          }
          re = t;
        }
        function ke(t, i, n) {
          if (t) {
            xe(32823);
            if (oe !== i || le !== n) {
              e.polygonOffset(i, n);
              oe = i;
              le = n;
            }
          } else {
            we(32823);
          }
        }
        function Ae(t = 33984 + ce - 1) {
          if (pe !== t) {
            e.activeTexture(t);
            pe = t;
          }
        }
        return {
          buffers: {
            color: o,
            depth: l,
            stencil: c
          },
          enable: xe,
          disable: we,
          bindFramebuffer: function (t, i) {
            return W[t] !== i && (e.bindFramebuffer(t, i), W[t] = i, s && (t === 36009 && (W[36160] = i), t === 36160 && (W[36009] = i)), true);
          },
          drawBuffers: function (i, n) {
            let r = j;
            let s = false;
            if (i) {
              r = q.get(n);
              if (r === undefined) {
                r = [];
                q.set(n, r);
              }
              if (i.isWebGLMultipleRenderTargets) {
                const e = i.texture;
                if (r.length !== e.length || r[0] !== 36064) {
                  for (let t = 0, i = e.length; t < i; t++) {
                    r[t] = 36064 + t;
                  }
                  r.length = e.length;
                  s = true;
                }
              } else if (r[0] !== 36064) {
                r[0] = 36064;
                s = true;
              }
            } else if (r[0] !== 1029) {
              r[0] = 1029;
              s = true;
            }
            if (s) {
              if (a.isWebGL2) {
                e.drawBuffers(r);
              } else {
                t.get("WEBGL_draw_buffers").drawBuffersWEBGL(r);
              }
            }
          },
          useProgram: function (t) {
            return X !== t && (e.useProgram(t), X = t, true);
          },
          setBlending: Ee,
          setMaterial: function (e, t) {
            if (e.side === d) {
              we(2884);
            } else {
              xe(2884);
            }
            let i = e.side === h;
            if (t) {
              i = !i;
            }
            Te(i);
            if (e.blending === p && e.transparent === false) {
              Ee(u);
            } else {
              Ee(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha);
            }
            l.setFunc(e.depthFunc);
            l.setTest(e.depthTest);
            l.setMask(e.depthWrite);
            o.setMask(e.colorWrite);
            const n = e.stencilWrite;
            c.setTest(n);
            if (n) {
              c.setMask(e.stencilWriteMask);
              c.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask);
              c.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass);
            }
            ke(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits);
            if (e.alphaToCoverage === true) {
              xe(32926);
            } else {
              we(32926);
            }
          },
          setFlipSided: Te,
          setCullFace: Ce,
          setLineWidth: function (t) {
            if (t !== se) {
              if (he) {
                e.lineWidth(t);
              }
              se = t;
            }
          },
          setPolygonOffset: ke,
          setScissorTest: function (e) {
            if (e) {
              xe(3089);
            } else {
              we(3089);
            }
          },
          activeTexture: Ae,
          bindTexture: function (t, i) {
            if (pe === null) {
              Ae();
            }
            let n = me[pe];
            if (n === undefined) {
              n = {
                type: undefined,
                texture: undefined
              };
              me[pe] = n;
            }
            if (n.type !== t || n.texture !== i) {
              e.bindTexture(t, i || ye[t]);
              n.type = t;
              n.texture = i;
            }
          },
          unbindTexture: function () {
            const t = me[pe];
            if (t !== undefined && t.type !== undefined) {
              e.bindTexture(t.type, null);
              t.type = undefined;
              t.texture = undefined;
            }
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          updateUBOMapping: function (t, i) {
            let n = V.get(i);
            if (n === undefined) {
              n = new WeakMap();
              V.set(i, n);
            }
            let a = n.get(t);
            if (a === undefined) {
              a = e.getUniformBlockIndex(i, t.name);
              n.set(t, a);
            }
          },
          uniformBlockBinding: function (t, i) {
            const n = V.get(i).get(t);
            if ($.get(t) !== n) {
              e.uniformBlockBinding(i, n, t.__bindingPointIndex);
              $.set(t, n);
            }
          },
          texStorage2D: function () {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage3D: function () {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage2D: function () {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage3D: function () {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (t) {
            if (_e.equals(t) === false) {
              e.scissor(t.x, t.y, t.z, t.w);
              _e.copy(t);
            }
          },
          viewport: function (t) {
            if (ve.equals(t) === false) {
              e.viewport(t.x, t.y, t.z, t.w);
              ve.copy(t);
            }
          },
          reset: function () {
            e.disable(3042);
            e.disable(2884);
            e.disable(2929);
            e.disable(32823);
            e.disable(3089);
            e.disable(2960);
            e.disable(32926);
            e.blendEquation(32774);
            e.blendFunc(1, 0);
            e.blendFuncSeparate(1, 0, 1, 0);
            e.colorMask(true, true, true, true);
            e.clearColor(0, 0, 0, 0);
            e.depthMask(true);
            e.depthFunc(513);
            e.clearDepth(1);
            e.stencilMask(4294967295);
            e.stencilFunc(519, 0, 4294967295);
            e.stencilOp(7680, 7680, 7680);
            e.clearStencil(0);
            e.cullFace(1029);
            e.frontFace(2305);
            e.polygonOffset(0, 0);
            e.activeTexture(33984);
            e.bindFramebuffer(36160, null);
            if (s === true) {
              e.bindFramebuffer(36009, null);
              e.bindFramebuffer(36008, null);
            }
            e.useProgram(null);
            e.lineWidth(1);
            e.scissor(0, 0, e.canvas.width, e.canvas.height);
            e.viewport(0, 0, e.canvas.width, e.canvas.height);
            G = {};
            pe = null;
            me = {};
            W = {};
            q = new WeakMap();
            j = [];
            X = null;
            K = false;
            Y = null;
            J = null;
            Z = null;
            Q = null;
            ee = null;
            te = null;
            ie = null;
            ne = false;
            ae = null;
            re = null;
            se = null;
            oe = null;
            le = null;
            _e.set(0, 0, e.canvas.width, e.canvas.height);
            ve.set(0, 0, e.canvas.width, e.canvas.height);
            o.reset();
            l.reset();
            c.reset();
          }
        };
      }
      function Us(e, t, i, n, a, r, s) {
        const o = a.isWebGL2;
        const l = a.maxTextures;
        const c = a.maxCubemapSize;
        const h = a.maxTextureSize;
        const d = a.maxSamples;
        const u = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null;
        const p = /OculusBrowser/g.test(navigator.userAgent);
        const m = new WeakMap();
        let f;
        const g = new WeakMap();
        let _ = false;
        try {
          _ = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch (e) {}
        function v(e, t) {
          if (_) {
            return new OffscreenCanvas(e, t);
          } else {
            return It("canvas");
          }
        }
        function b(e, t, i, n) {
          let a = 1;
          if (e.width > n || e.height > n) {
            a = n / Math.max(e.width, e.height);
          }
          if (a < 1 || t === true) {
            if (typeof HTMLImageElement != "undefined" && e instanceof HTMLImageElement || typeof HTMLCanvasElement != "undefined" && e instanceof HTMLCanvasElement || typeof ImageBitmap != "undefined" && e instanceof ImageBitmap) {
              const n = t ? kt : Math.floor;
              const r = n(a * e.width);
              const s = n(a * e.height);
              if (f === undefined) {
                f = v(r, s);
              }
              const o = i ? v(r, s) : f;
              o.width = r;
              o.height = s;
              o.getContext("2d").drawImage(e, 0, 0, r, s);
              console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + r + "x" + s + ").");
              return o;
            }
            if ("data" in e) {
              console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").");
            }
            return e;
          }
          return e;
        }
        function y(e) {
          return Ct(e.width) && Ct(e.height);
        }
        function x(e, t) {
          return e.generateMipmaps && t && e.minFilter !== se && e.minFilter !== ce;
        }
        function w(t) {
          e.generateMipmap(t);
        }
        function M(i, n, a, r, s = false) {
          if (o === false) {
            return n;
          }
          if (i !== null) {
            if (e[i] !== undefined) {
              return e[i];
            }
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + i + "'");
          }
          let l = n;
          if (n === 6403) {
            if (a === 5126) {
              l = 33326;
            }
            if (a === 5131) {
              l = 33325;
            }
            if (a === 5121) {
              l = 33321;
            }
          }
          if (n === 33319) {
            if (a === 5126) {
              l = 33328;
            }
            if (a === 5131) {
              l = 33327;
            }
            if (a === 5121) {
              l = 33323;
            }
          }
          if (n === 6408) {
            if (a === 5126) {
              l = 34836;
            }
            if (a === 5131) {
              l = 34842;
            }
            if (a === 5121) {
              l = r === dt && s === false ? 35907 : 32856;
            }
            if (a === 32819) {
              l = 32854;
            }
            if (a === 32820) {
              l = 32855;
            }
          }
          if (l === 33325 || l === 33326 || l === 33327 || l === 33328 || l === 34842 || l === 34836) {
            t.get("EXT_color_buffer_float");
          }
          return l;
        }
        function S(e, t, i) {
          if (x(e, i) === true || e.isFramebufferTexture && e.minFilter !== se && e.minFilter !== ce) {
            return Math.log2(Math.max(t.width, t.height)) + 1;
          } else if (e.mipmaps !== undefined && e.mipmaps.length > 0) {
            return e.mipmaps.length;
          } else if (e.isCompressedTexture && Array.isArray(e.image)) {
            return t.mipmaps.length;
          } else {
            return 1;
          }
        }
        function E(e) {
          if (e === se || e === oe || e === le) {
            return 9728;
          } else {
            return 9729;
          }
        }
        function T(e) {
          const t = e.target;
          t.removeEventListener("dispose", T);
          (function (e) {
            const t = n.get(e);
            if (t.__webglInit === undefined) {
              return;
            }
            const i = e.source;
            const a = g.get(i);
            if (a) {
              const n = a[t.__cacheKey];
              n.usedTimes--;
              if (n.usedTimes === 0) {
                k(e);
              }
              if (Object.keys(a).length === 0) {
                g.delete(i);
              }
            }
            n.remove(e);
          })(t);
          if (t.isVideoTexture) {
            m.delete(t);
          }
        }
        function C(t) {
          const i = t.target;
          i.removeEventListener("dispose", C);
          (function (t) {
            const i = t.texture;
            const a = n.get(t);
            const r = n.get(i);
            if (r.__webglTexture !== undefined) {
              e.deleteTexture(r.__webglTexture);
              s.memory.textures--;
            }
            if (t.depthTexture) {
              t.depthTexture.dispose();
            }
            if (t.isWebGLCubeRenderTarget) {
              for (let t = 0; t < 6; t++) {
                e.deleteFramebuffer(a.__webglFramebuffer[t]);
                if (a.__webglDepthbuffer) {
                  e.deleteRenderbuffer(a.__webglDepthbuffer[t]);
                }
              }
            } else {
              e.deleteFramebuffer(a.__webglFramebuffer);
              if (a.__webglDepthbuffer) {
                e.deleteRenderbuffer(a.__webglDepthbuffer);
              }
              if (a.__webglMultisampledFramebuffer) {
                e.deleteFramebuffer(a.__webglMultisampledFramebuffer);
              }
              if (a.__webglColorRenderbuffer) {
                for (let t = 0; t < a.__webglColorRenderbuffer.length; t++) {
                  if (a.__webglColorRenderbuffer[t]) {
                    e.deleteRenderbuffer(a.__webglColorRenderbuffer[t]);
                  }
                }
              }
              if (a.__webglDepthRenderbuffer) {
                e.deleteRenderbuffer(a.__webglDepthRenderbuffer);
              }
            }
            if (t.isWebGLMultipleRenderTargets) {
              for (let t = 0, a = i.length; t < a; t++) {
                const a = n.get(i[t]);
                if (a.__webglTexture) {
                  e.deleteTexture(a.__webglTexture);
                  s.memory.textures--;
                }
                n.remove(i[t]);
              }
            }
            n.remove(i);
            n.remove(t);
          })(i);
        }
        function k(t) {
          const i = n.get(t);
          e.deleteTexture(i.__webglTexture);
          const a = t.source;
          delete g.get(a)[i.__cacheKey];
          s.memory.textures--;
        }
        let A = 0;
        function L(e, t) {
          const a = n.get(e);
          if (e.isVideoTexture) {
            (function (e) {
              const t = s.render.frame;
              if (m.get(e) !== t) {
                m.set(e, t);
                e.update();
              }
            })(e);
          }
          if (e.isRenderTargetTexture === false && e.version > 0 && a.__version !== e.version) {
            const i = e.image;
            if (i === null) {
              console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            } else {
              if (i.complete !== false) {
                $(a, e, t);
                return;
              }
              console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            }
          }
          i.activeTexture(33984 + t);
          i.bindTexture(3553, a.__webglTexture);
        }
        const R = {
          [ne]: 10497,
          [ae]: 33071,
          [re]: 33648
        };
        const P = {
          [se]: 9728,
          [oe]: 9984,
          [le]: 9986,
          [ce]: 9729,
          [he]: 9985,
          [de]: 9987
        };
        function D(i, r, s) {
          if (s) {
            e.texParameteri(i, 10242, R[r.wrapS]);
            e.texParameteri(i, 10243, R[r.wrapT]);
            if (i === 32879 || i === 35866) {
              e.texParameteri(i, 32882, R[r.wrapR]);
            }
            e.texParameteri(i, 10240, P[r.magFilter]);
            e.texParameteri(i, 10241, P[r.minFilter]);
          } else {
            e.texParameteri(i, 10242, 33071);
            e.texParameteri(i, 10243, 33071);
            if (i === 32879 || i === 35866) {
              e.texParameteri(i, 32882, 33071);
            }
            if (r.wrapS !== ae || r.wrapT !== ae) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
            }
            e.texParameteri(i, 10240, E(r.magFilter));
            e.texParameteri(i, 10241, E(r.minFilter));
            if (r.minFilter !== se && r.minFilter !== ce) {
              console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
            }
          }
          if (t.has("EXT_texture_filter_anisotropic") === true) {
            const s = t.get("EXT_texture_filter_anisotropic");
            if (r.type === ve && t.has("OES_texture_float_linear") === false) {
              return;
            }
            if (o === false && r.type === be && t.has("OES_texture_half_float_linear") === false) {
              return;
            }
            if (r.anisotropy > 1 || n.get(r).__currentAnisotropy) {
              e.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(r.anisotropy, a.getMaxAnisotropy()));
              n.get(r).__currentAnisotropy = r.anisotropy;
            }
          }
        }
        function I(t, i) {
          let n = false;
          if (t.__webglInit === undefined) {
            t.__webglInit = true;
            i.addEventListener("dispose", T);
          }
          const a = i.source;
          let r = g.get(a);
          if (r === undefined) {
            r = {};
            g.set(a, r);
          }
          const o = function (e) {
            const t = [];
            t.push(e.wrapS);
            t.push(e.wrapT);
            t.push(e.magFilter);
            t.push(e.minFilter);
            t.push(e.anisotropy);
            t.push(e.internalFormat);
            t.push(e.format);
            t.push(e.type);
            t.push(e.generateMipmaps);
            t.push(e.premultiplyAlpha);
            t.push(e.flipY);
            t.push(e.unpackAlignment);
            t.push(e.encoding);
            return t.join();
          }(i);
          if (o !== t.__cacheKey) {
            if (r[o] === undefined) {
              r[o] = {
                texture: e.createTexture(),
                usedTimes: 0
              };
              s.memory.textures++;
              n = true;
            }
            r[o].usedTimes++;
            const a = r[t.__cacheKey];
            if (a !== undefined) {
              r[t.__cacheKey].usedTimes--;
              if (a.usedTimes === 0) {
                k(i);
              }
            }
            t.__cacheKey = o;
            t.__webglTexture = r[o].texture;
          }
          return n;
        }
        function $(t, n, a) {
          let s = 3553;
          if (n.isDataArrayTexture) {
            s = 35866;
          }
          if (n.isData3DTexture) {
            s = 32879;
          }
          const l = I(t, n);
          const c = n.source;
          i.activeTexture(33984 + a);
          i.bindTexture(s, t.__webglTexture);
          if (c.version !== c.__currentVersion || l === true) {
            e.pixelStorei(37440, n.flipY);
            e.pixelStorei(37441, n.premultiplyAlpha);
            e.pixelStorei(3317, n.unpackAlignment);
            e.pixelStorei(37443, 0);
            const t = function (e) {
              return !o && (e.wrapS !== ae || e.wrapT !== ae || e.minFilter !== se && e.minFilter !== ce);
            }(n) && y(n.image) === false;
            let a = b(n.image, t, false, h);
            a = B(n, a);
            const d = y(a) || o;
            const u = r.convert(n.format, n.encoding);
            let p;
            let m = r.convert(n.type);
            let f = M(n.internalFormat, u, m, n.encoding, n.isVideoTexture);
            D(s, n, d);
            const g = n.mipmaps;
            const _ = o && n.isVideoTexture !== true;
            const v = c.__currentVersion === undefined || l === true;
            const E = S(n, a, d);
            if (n.isDepthTexture) {
              f = 6402;
              if (o) {
                f = n.type === ve ? 36012 : n.type === _e ? 33190 : n.type === we ? 35056 : 33189;
              } else if (n.type === ve) {
                console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
              }
              if (n.format === ke && f === 6402 && n.type !== fe && n.type !== _e) {
                console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
                n.type = _e;
                m = r.convert(n.type);
              }
              if (n.format === Ae && f === 6402) {
                f = 34041;
                if (n.type !== we) {
                  console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
                  n.type = we;
                  m = r.convert(n.type);
                }
              }
              if (v) {
                if (_) {
                  i.texStorage2D(3553, 1, f, a.width, a.height);
                } else {
                  i.texImage2D(3553, 0, f, a.width, a.height, 0, u, m, null);
                }
              }
            } else if (n.isDataTexture) {
              if (g.length > 0 && d) {
                if (_ && v) {
                  i.texStorage2D(3553, E, f, g[0].width, g[0].height);
                }
                for (let e = 0, t = g.length; e < t; e++) {
                  p = g[e];
                  if (_) {
                    i.texSubImage2D(3553, e, 0, 0, p.width, p.height, u, m, p.data);
                  } else {
                    i.texImage2D(3553, e, f, p.width, p.height, 0, u, m, p.data);
                  }
                }
                n.generateMipmaps = false;
              } else if (_) {
                if (v) {
                  i.texStorage2D(3553, E, f, a.width, a.height);
                }
                i.texSubImage2D(3553, 0, 0, 0, a.width, a.height, u, m, a.data);
              } else {
                i.texImage2D(3553, 0, f, a.width, a.height, 0, u, m, a.data);
              }
            } else if (n.isCompressedTexture) {
              if (_ && v) {
                i.texStorage2D(3553, E, f, g[0].width, g[0].height);
              }
              for (let e = 0, t = g.length; e < t; e++) {
                p = g[e];
                if (n.format !== Ee) {
                  if (u !== null) {
                    if (_) {
                      i.compressedTexSubImage2D(3553, e, 0, 0, p.width, p.height, u, p.data);
                    } else {
                      i.compressedTexImage2D(3553, e, f, p.width, p.height, 0, p.data);
                    }
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                  }
                } else if (_) {
                  i.texSubImage2D(3553, e, 0, 0, p.width, p.height, u, m, p.data);
                } else {
                  i.texImage2D(3553, e, f, p.width, p.height, 0, u, m, p.data);
                }
              }
            } else if (n.isDataArrayTexture) {
              if (_) {
                if (v) {
                  i.texStorage3D(35866, E, f, a.width, a.height, a.depth);
                }
                i.texSubImage3D(35866, 0, 0, 0, 0, a.width, a.height, a.depth, u, m, a.data);
              } else {
                i.texImage3D(35866, 0, f, a.width, a.height, a.depth, 0, u, m, a.data);
              }
            } else if (n.isData3DTexture) {
              if (_) {
                if (v) {
                  i.texStorage3D(32879, E, f, a.width, a.height, a.depth);
                }
                i.texSubImage3D(32879, 0, 0, 0, 0, a.width, a.height, a.depth, u, m, a.data);
              } else {
                i.texImage3D(32879, 0, f, a.width, a.height, a.depth, 0, u, m, a.data);
              }
            } else if (n.isFramebufferTexture) {
              if (v) {
                if (_) {
                  i.texStorage2D(3553, E, f, a.width, a.height);
                } else {
                  let e = a.width;
                  let t = a.height;
                  for (let n = 0; n < E; n++) {
                    i.texImage2D(3553, n, f, e, t, 0, u, m, null);
                    e >>= 1;
                    t >>= 1;
                  }
                }
              }
            } else if (g.length > 0 && d) {
              if (_ && v) {
                i.texStorage2D(3553, E, f, g[0].width, g[0].height);
              }
              for (let e = 0, t = g.length; e < t; e++) {
                p = g[e];
                if (_) {
                  i.texSubImage2D(3553, e, 0, 0, u, m, p);
                } else {
                  i.texImage2D(3553, e, f, u, m, p);
                }
              }
              n.generateMipmaps = false;
            } else if (_) {
              if (v) {
                i.texStorage2D(3553, E, f, a.width, a.height);
              }
              i.texSubImage2D(3553, 0, 0, 0, u, m, a);
            } else {
              i.texImage2D(3553, 0, f, u, m, a);
            }
            if (x(n, d)) {
              w(s);
            }
            c.__currentVersion = c.version;
            if (n.onUpdate) {
              n.onUpdate(n);
            }
          }
          t.__version = n.version;
        }
        function z(t, a, s, o, l) {
          const c = r.convert(s.format, s.encoding);
          const h = r.convert(s.type);
          const d = M(s.internalFormat, c, h, s.encoding);
          if (!n.get(a).__hasExternalTextures) {
            if (l === 32879 || l === 35866) {
              i.texImage3D(l, 0, d, a.width, a.height, a.depth, 0, c, h, null);
            } else {
              i.texImage2D(l, 0, d, a.width, a.height, 0, c, h, null);
            }
          }
          i.bindFramebuffer(36160, t);
          if (F(a)) {
            u.framebufferTexture2DMultisampleEXT(36160, o, l, n.get(s).__webglTexture, 0, U(a));
          } else {
            e.framebufferTexture2D(36160, o, l, n.get(s).__webglTexture, 0);
          }
          i.bindFramebuffer(36160, null);
        }
        function N(t, i, n) {
          e.bindRenderbuffer(36161, t);
          if (i.depthBuffer && !i.stencilBuffer) {
            let a = 33189;
            if (n || F(i)) {
              const t = i.depthTexture;
              if (t && t.isDepthTexture) {
                if (t.type === ve) {
                  a = 36012;
                } else if (t.type === _e) {
                  a = 33190;
                }
              }
              const n = U(i);
              if (F(i)) {
                u.renderbufferStorageMultisampleEXT(36161, n, a, i.width, i.height);
              } else {
                e.renderbufferStorageMultisample(36161, n, a, i.width, i.height);
              }
            } else {
              e.renderbufferStorage(36161, a, i.width, i.height);
            }
            e.framebufferRenderbuffer(36160, 36096, 36161, t);
          } else if (i.depthBuffer && i.stencilBuffer) {
            const a = U(i);
            if (n && F(i) === false) {
              e.renderbufferStorageMultisample(36161, a, 35056, i.width, i.height);
            } else if (F(i)) {
              u.renderbufferStorageMultisampleEXT(36161, a, 35056, i.width, i.height);
            } else {
              e.renderbufferStorage(36161, 34041, i.width, i.height);
            }
            e.framebufferRenderbuffer(36160, 33306, 36161, t);
          } else {
            const t = i.isWebGLMultipleRenderTargets === true ? i.texture : [i.texture];
            for (let a = 0; a < t.length; a++) {
              const s = t[a];
              const o = r.convert(s.format, s.encoding);
              const l = r.convert(s.type);
              const c = M(s.internalFormat, o, l, s.encoding);
              const h = U(i);
              if (n && F(i) === false) {
                e.renderbufferStorageMultisample(36161, h, c, i.width, i.height);
              } else if (F(i)) {
                u.renderbufferStorageMultisampleEXT(36161, h, c, i.width, i.height);
              } else {
                e.renderbufferStorage(36161, c, i.width, i.height);
              }
            }
          }
          e.bindRenderbuffer(36161, null);
        }
        function O(t) {
          const a = n.get(t);
          const r = t.isWebGLCubeRenderTarget === true;
          if (t.depthTexture && !a.__autoAllocateDepthBuffer) {
            if (r) {
              throw new Error("target.depthTexture not supported in Cube render targets");
            }
            (function (t, a) {
              if (a && a.isWebGLCubeRenderTarget) {
                throw new Error("Depth Texture with cube render targets is not supported");
              }
              i.bindFramebuffer(36160, t);
              if (!a.depthTexture || !a.depthTexture.isDepthTexture) {
                throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
              }
              if (!n.get(a.depthTexture).__webglTexture || a.depthTexture.image.width !== a.width || a.depthTexture.image.height !== a.height) {
                a.depthTexture.image.width = a.width;
                a.depthTexture.image.height = a.height;
                a.depthTexture.needsUpdate = true;
              }
              L(a.depthTexture, 0);
              const r = n.get(a.depthTexture).__webglTexture;
              const s = U(a);
              if (a.depthTexture.format === ke) {
                if (F(a)) {
                  u.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, r, 0, s);
                } else {
                  e.framebufferTexture2D(36160, 36096, 3553, r, 0);
                }
              } else {
                if (a.depthTexture.format !== Ae) {
                  throw new Error("Unknown depthTexture format");
                }
                if (F(a)) {
                  u.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, r, 0, s);
                } else {
                  e.framebufferTexture2D(36160, 33306, 3553, r, 0);
                }
              }
            })(a.__webglFramebuffer, t);
          } else if (r) {
            a.__webglDepthbuffer = [];
            for (let n = 0; n < 6; n++) {
              i.bindFramebuffer(36160, a.__webglFramebuffer[n]);
              a.__webglDepthbuffer[n] = e.createRenderbuffer();
              N(a.__webglDepthbuffer[n], t, false);
            }
          } else {
            i.bindFramebuffer(36160, a.__webglFramebuffer);
            a.__webglDepthbuffer = e.createRenderbuffer();
            N(a.__webglDepthbuffer, t, false);
          }
          i.bindFramebuffer(36160, null);
        }
        function U(e) {
          return Math.min(d, e.samples);
        }
        function F(e) {
          const i = n.get(e);
          return o && e.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === true && i.__useRenderToTexture !== false;
        }
        function B(e, i) {
          const n = e.encoding;
          const a = e.format;
          const r = e.type;
          if (e.isCompressedTexture !== true && e.isVideoTexture !== true && e.format !== bt) {
            if (n !== ht) {
              if (n === dt) {
                if (o === false) {
                  if (t.has("EXT_sRGB") === true && a === Ee) {
                    e.format = bt;
                    e.minFilter = ce;
                    e.generateMipmaps = false;
                  } else {
                    i = jt.sRGBToLinear(i);
                  }
                } else if (a !== Ee || r !== ue) {
                  console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
                }
              } else {
                console.error("THREE.WebGLTextures: Unsupported texture encoding:", n);
              }
            }
          }
          return i;
        }
        this.allocateTextureUnit = function () {
          const e = A;
          if (e >= l) {
            console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + l);
          }
          A += 1;
          return e;
        };
        this.resetTextureUnits = function () {
          A = 0;
        };
        this.setTexture2D = L;
        this.setTexture2DArray = function (e, t) {
          const a = n.get(e);
          if (e.version > 0 && a.__version !== e.version) {
            $(a, e, t);
          } else {
            i.activeTexture(33984 + t);
            i.bindTexture(35866, a.__webglTexture);
          }
        };
        this.setTexture3D = function (e, t) {
          const a = n.get(e);
          if (e.version > 0 && a.__version !== e.version) {
            $(a, e, t);
          } else {
            i.activeTexture(33984 + t);
            i.bindTexture(32879, a.__webglTexture);
          }
        };
        this.setTextureCube = function (t, a) {
          const s = n.get(t);
          if (t.version > 0 && s.__version !== t.version) {
            (function (t, n, a) {
              if (n.image.length !== 6) {
                return;
              }
              const s = I(t, n);
              const l = n.source;
              i.activeTexture(33984 + a);
              i.bindTexture(34067, t.__webglTexture);
              if (l.version !== l.__currentVersion || s === true) {
                e.pixelStorei(37440, n.flipY);
                e.pixelStorei(37441, n.premultiplyAlpha);
                e.pixelStorei(3317, n.unpackAlignment);
                e.pixelStorei(37443, 0);
                const t = n.isCompressedTexture || n.image[0].isCompressedTexture;
                const a = n.image[0] && n.image[0].isDataTexture;
                const h = [];
                for (let e = 0; e < 6; e++) {
                  h[e] = t || a ? a ? n.image[e].image : n.image[e] : b(n.image[e], false, true, c);
                  h[e] = B(n, h[e]);
                }
                const d = h[0];
                const u = y(d) || o;
                const p = r.convert(n.format, n.encoding);
                const m = r.convert(n.type);
                const f = M(n.internalFormat, p, m, n.encoding);
                const g = o && n.isVideoTexture !== true;
                const _ = l.__currentVersion === undefined || s === true;
                let v;
                let E = S(n, d, u);
                D(34067, n, u);
                if (t) {
                  if (g && _) {
                    i.texStorage2D(34067, E, f, d.width, d.height);
                  }
                  for (let e = 0; e < 6; e++) {
                    v = h[e].mipmaps;
                    for (let t = 0; t < v.length; t++) {
                      const a = v[t];
                      if (n.format !== Ee) {
                        if (p !== null) {
                          if (g) {
                            i.compressedTexSubImage2D(34069 + e, t, 0, 0, a.width, a.height, p, a.data);
                          } else {
                            i.compressedTexImage2D(34069 + e, t, f, a.width, a.height, 0, a.data);
                          }
                        } else {
                          console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                        }
                      } else if (g) {
                        i.texSubImage2D(34069 + e, t, 0, 0, a.width, a.height, p, m, a.data);
                      } else {
                        i.texImage2D(34069 + e, t, f, a.width, a.height, 0, p, m, a.data);
                      }
                    }
                  }
                } else {
                  v = n.mipmaps;
                  if (g && _) {
                    if (v.length > 0) {
                      E++;
                    }
                    i.texStorage2D(34067, E, f, h[0].width, h[0].height);
                  }
                  for (let e = 0; e < 6; e++) {
                    if (a) {
                      if (g) {
                        i.texSubImage2D(34069 + e, 0, 0, 0, h[e].width, h[e].height, p, m, h[e].data);
                      } else {
                        i.texImage2D(34069 + e, 0, f, h[e].width, h[e].height, 0, p, m, h[e].data);
                      }
                      for (let t = 0; t < v.length; t++) {
                        const n = v[t].image[e].image;
                        if (g) {
                          i.texSubImage2D(34069 + e, t + 1, 0, 0, n.width, n.height, p, m, n.data);
                        } else {
                          i.texImage2D(34069 + e, t + 1, f, n.width, n.height, 0, p, m, n.data);
                        }
                      }
                    } else {
                      if (g) {
                        i.texSubImage2D(34069 + e, 0, 0, 0, p, m, h[e]);
                      } else {
                        i.texImage2D(34069 + e, 0, f, p, m, h[e]);
                      }
                      for (let t = 0; t < v.length; t++) {
                        const n = v[t];
                        if (g) {
                          i.texSubImage2D(34069 + e, t + 1, 0, 0, p, m, n.image[e]);
                        } else {
                          i.texImage2D(34069 + e, t + 1, f, p, m, n.image[e]);
                        }
                      }
                    }
                  }
                }
                if (x(n, u)) {
                  w(34067);
                }
                l.__currentVersion = l.version;
                if (n.onUpdate) {
                  n.onUpdate(n);
                }
              }
              t.__version = n.version;
            })(s, t, a);
          } else {
            i.activeTexture(33984 + a);
            i.bindTexture(34067, s.__webglTexture);
          }
        };
        this.rebindTextures = function (e, t, i) {
          const a = n.get(e);
          if (t !== undefined) {
            z(a.__webglFramebuffer, e, e.texture, 36064, 3553);
          }
          if (i !== undefined) {
            O(e);
          }
        };
        this.setupRenderTarget = function (t) {
          const l = t.texture;
          const c = n.get(t);
          const h = n.get(l);
          t.addEventListener("dispose", C);
          if (t.isWebGLMultipleRenderTargets !== true) {
            if (h.__webglTexture === undefined) {
              h.__webglTexture = e.createTexture();
            }
            h.__version = l.version;
            s.memory.textures++;
          }
          const d = t.isWebGLCubeRenderTarget === true;
          const u = t.isWebGLMultipleRenderTargets === true;
          const p = y(t) || o;
          if (d) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < 6; t++) {
              c.__webglFramebuffer[t] = e.createFramebuffer();
            }
          } else {
            c.__webglFramebuffer = e.createFramebuffer();
            if (u) {
              if (a.drawBuffers) {
                const i = t.texture;
                for (let t = 0, a = i.length; t < a; t++) {
                  const a = n.get(i[t]);
                  if (a.__webglTexture === undefined) {
                    a.__webglTexture = e.createTexture();
                    s.memory.textures++;
                  }
                }
              } else {
                console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
              }
            }
            if (o && t.samples > 0 && F(t) === false) {
              const n = u ? l : [l];
              c.__webglMultisampledFramebuffer = e.createFramebuffer();
              c.__webglColorRenderbuffer = [];
              i.bindFramebuffer(36160, c.__webglMultisampledFramebuffer);
              for (let i = 0; i < n.length; i++) {
                const a = n[i];
                c.__webglColorRenderbuffer[i] = e.createRenderbuffer();
                e.bindRenderbuffer(36161, c.__webglColorRenderbuffer[i]);
                const s = r.convert(a.format, a.encoding);
                const o = r.convert(a.type);
                const l = M(a.internalFormat, s, o, a.encoding);
                const h = U(t);
                e.renderbufferStorageMultisample(36161, h, l, t.width, t.height);
                e.framebufferRenderbuffer(36160, 36064 + i, 36161, c.__webglColorRenderbuffer[i]);
              }
              e.bindRenderbuffer(36161, null);
              if (t.depthBuffer) {
                c.__webglDepthRenderbuffer = e.createRenderbuffer();
                N(c.__webglDepthRenderbuffer, t, true);
              }
              i.bindFramebuffer(36160, null);
            }
          }
          if (d) {
            i.bindTexture(34067, h.__webglTexture);
            D(34067, l, p);
            for (let e = 0; e < 6; e++) {
              z(c.__webglFramebuffer[e], t, l, 36064, 34069 + e);
            }
            if (x(l, p)) {
              w(34067);
            }
            i.unbindTexture();
          } else if (u) {
            const e = t.texture;
            for (let a = 0, r = e.length; a < r; a++) {
              const r = e[a];
              const s = n.get(r);
              i.bindTexture(3553, s.__webglTexture);
              D(3553, r, p);
              z(c.__webglFramebuffer, t, r, 36064 + a, 3553);
              if (x(r, p)) {
                w(3553);
              }
            }
            i.unbindTexture();
          } else {
            let e = 3553;
            if (t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) {
              if (o) {
                e = t.isWebGL3DRenderTarget ? 32879 : 35866;
              } else {
                console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
              }
            }
            i.bindTexture(e, h.__webglTexture);
            D(e, l, p);
            z(c.__webglFramebuffer, t, l, 36064, e);
            if (x(l, p)) {
              w(e);
            }
            i.unbindTexture();
          }
          if (t.depthBuffer) {
            O(t);
          }
        };
        this.updateRenderTargetMipmap = function (e) {
          const t = y(e) || o;
          const a = e.isWebGLMultipleRenderTargets === true ? e.texture : [e.texture];
          for (let r = 0, s = a.length; r < s; r++) {
            const s = a[r];
            if (x(s, t)) {
              const t = e.isWebGLCubeRenderTarget ? 34067 : 3553;
              const a = n.get(s).__webglTexture;
              i.bindTexture(t, a);
              w(t);
              i.unbindTexture();
            }
          }
        };
        this.updateMultisampleRenderTarget = function (t) {
          if (o && t.samples > 0 && F(t) === false) {
            const a = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
            const r = t.width;
            const s = t.height;
            let o = 16384;
            const l = [];
            const c = t.stencilBuffer ? 33306 : 36096;
            const h = n.get(t);
            const d = t.isWebGLMultipleRenderTargets === true;
            if (d) {
              for (let t = 0; t < a.length; t++) {
                i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
                e.framebufferRenderbuffer(36160, 36064 + t, 36161, null);
                i.bindFramebuffer(36160, h.__webglFramebuffer);
                e.framebufferTexture2D(36009, 36064 + t, 3553, null, 0);
              }
            }
            i.bindFramebuffer(36008, h.__webglMultisampledFramebuffer);
            i.bindFramebuffer(36009, h.__webglFramebuffer);
            for (let i = 0; i < a.length; i++) {
              l.push(36064 + i);
              if (t.depthBuffer) {
                l.push(c);
              }
              const u = h.__ignoreDepthValues !== undefined && h.__ignoreDepthValues;
              if (u === false) {
                if (t.depthBuffer) {
                  o |= 256;
                }
                if (t.stencilBuffer) {
                  o |= 1024;
                }
              }
              if (d) {
                e.framebufferRenderbuffer(36008, 36064, 36161, h.__webglColorRenderbuffer[i]);
              }
              if (u === true) {
                e.invalidateFramebuffer(36008, [c]);
                e.invalidateFramebuffer(36009, [c]);
              }
              if (d) {
                const t = n.get(a[i]).__webglTexture;
                e.framebufferTexture2D(36009, 36064, 3553, t, 0);
              }
              e.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728);
              if (p) {
                e.invalidateFramebuffer(36008, l);
              }
            }
            i.bindFramebuffer(36008, null);
            i.bindFramebuffer(36009, null);
            if (d) {
              for (let t = 0; t < a.length; t++) {
                i.bindFramebuffer(36160, h.__webglMultisampledFramebuffer);
                e.framebufferRenderbuffer(36160, 36064 + t, 36161, h.__webglColorRenderbuffer[t]);
                const r = n.get(a[t]).__webglTexture;
                i.bindFramebuffer(36160, h.__webglFramebuffer);
                e.framebufferTexture2D(36009, 36064 + t, 3553, r, 0);
              }
            }
            i.bindFramebuffer(36009, h.__webglMultisampledFramebuffer);
          }
        };
        this.setupDepthRenderbuffer = O;
        this.setupFrameBufferTexture = z;
        this.useMultisampledRTT = F;
      }
      function Fs(e, t, i) {
        const n = i.isWebGL2;
        return {
          convert: function (i, a = null) {
            let r;
            if (i === ue) {
              return 5121;
            }
            if (i === ye) {
              return 32819;
            }
            if (i === xe) {
              return 32820;
            }
            if (i === pe) {
              return 5120;
            }
            if (i === me) {
              return 5122;
            }
            if (i === fe) {
              return 5123;
            }
            if (i === ge) {
              return 5124;
            }
            if (i === _e) {
              return 5125;
            }
            if (i === ve) {
              return 5126;
            }
            if (i === be) {
              if (n) {
                return 5131;
              } else {
                r = t.get("OES_texture_half_float");
                if (r !== null) {
                  return r.HALF_FLOAT_OES;
                } else {
                  return null;
                }
              }
            }
            if (i === Me) {
              return 6406;
            }
            if (i === Ee) {
              return 6408;
            }
            if (i === Te) {
              return 6409;
            }
            if (i === Ce) {
              return 6410;
            }
            if (i === ke) {
              return 6402;
            }
            if (i === Ae) {
              return 34041;
            }
            if (i === Le) {
              return 6403;
            }
            if (i === Se) {
              console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
              return 6408;
            }
            if (i === bt) {
              r = t.get("EXT_sRGB");
              if (r !== null) {
                return r.SRGB_ALPHA_EXT;
              } else {
                return null;
              }
            }
            if (i === Re) {
              return 36244;
            }
            if (i === Pe) {
              return 33319;
            }
            if (i === De) {
              return 33320;
            }
            if (i === Ie) {
              return 36249;
            }
            if (i === $e || i === ze || i === Ne || i === Oe) {
              if (a === dt) {
                r = t.get("WEBGL_compressed_texture_s3tc_srgb");
                if (r === null) {
                  return null;
                }
                if (i === $e) {
                  return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                }
                if (i === ze) {
                  return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                }
                if (i === Ne) {
                  return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                }
                if (i === Oe) {
                  return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                }
              } else {
                r = t.get("WEBGL_compressed_texture_s3tc");
                if (r === null) {
                  return null;
                }
                if (i === $e) {
                  return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                }
                if (i === ze) {
                  return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                }
                if (i === Ne) {
                  return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                }
                if (i === Oe) {
                  return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                }
              }
            }
            if (i === Ue || i === Fe || i === Be || i === He) {
              r = t.get("WEBGL_compressed_texture_pvrtc");
              if (r === null) {
                return null;
              }
              if (i === Ue) {
                return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              }
              if (i === Fe) {
                return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              }
              if (i === Be) {
                return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              }
              if (i === He) {
                return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
            }
            if (i === Ve) {
              r = t.get("WEBGL_compressed_texture_etc1");
              if (r !== null) {
                return r.COMPRESSED_RGB_ETC1_WEBGL;
              } else {
                return null;
              }
            }
            if (i === Ge || i === We) {
              r = t.get("WEBGL_compressed_texture_etc");
              if (r === null) {
                return null;
              }
              if (i === Ge) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ETC2;
                } else {
                  return r.COMPRESSED_RGB8_ETC2;
                }
              }
              if (i === We) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
                } else {
                  return r.COMPRESSED_RGBA8_ETC2_EAC;
                }
              }
            }
            if (i === qe || i === je || i === Xe || i === Ke || i === Ye || i === Je || i === Ze || i === Qe || i === et || i === tt || i === it || i === nt || i === at || i === rt) {
              r = t.get("WEBGL_compressed_texture_astc");
              if (r === null) {
                return null;
              }
              if (i === qe) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                }
              }
              if (i === je) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                }
              }
              if (i === Xe) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                }
              }
              if (i === Ke) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                }
              }
              if (i === Ye) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                }
              }
              if (i === Je) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                }
              }
              if (i === Ze) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                }
              }
              if (i === Qe) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                }
              }
              if (i === et) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                }
              }
              if (i === tt) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                }
              }
              if (i === it) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                }
              }
              if (i === nt) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                }
              }
              if (i === at) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                }
              }
              if (i === rt) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;
                } else {
                  return r.COMPRESSED_RGBA_ASTC_12x12_KHR;
                }
              }
            }
            if (i === st) {
              r = t.get("EXT_texture_compression_bptc");
              if (r === null) {
                return null;
              }
              if (i === st) {
                if (a === dt) {
                  return r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
                } else {
                  return r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                }
              }
            }
            if (i === we) {
              if (n) {
                return 34042;
              } else {
                r = t.get("WEBGL_depth_texture");
                if (r !== null) {
                  return r.UNSIGNED_INT_24_8_WEBGL;
                } else {
                  return null;
                }
              }
            } else if (e[i] !== undefined) {
              return e[i];
            } else {
              return null;
            }
          }
        };
      }
      class Bs extends sa {
        constructor(e = []) {
          super();
          this.isArrayCamera = true;
          this.cameras = e;
        }
      }
      class Hs extends sn {
        constructor() {
          super();
          this.isGroup = true;
          this.type = "Group";
        }
      }
      const Vs = {
        type: "move"
      };
      class Gs {
        constructor() {
          this._targetRay = null;
          this._grip = null;
          this._hand = null;
        }
        getHandSpace() {
          if (this._hand === null) {
            this._hand = new Hs();
            this._hand.matrixAutoUpdate = false;
            this._hand.visible = false;
            this._hand.joints = {};
            this._hand.inputState = {
              pinching: false
            };
          }
          return this._hand;
        }
        getTargetRaySpace() {
          if (this._targetRay === null) {
            this._targetRay = new Hs();
            this._targetRay.matrixAutoUpdate = false;
            this._targetRay.visible = false;
            this._targetRay.hasLinearVelocity = false;
            this._targetRay.linearVelocity = new ni();
            this._targetRay.hasAngularVelocity = false;
            this._targetRay.angularVelocity = new ni();
          }
          return this._targetRay;
        }
        getGripSpace() {
          if (this._grip === null) {
            this._grip = new Hs();
            this._grip.matrixAutoUpdate = false;
            this._grip.visible = false;
            this._grip.hasLinearVelocity = false;
            this._grip.linearVelocity = new ni();
            this._grip.hasAngularVelocity = false;
            this._grip.angularVelocity = new ni();
          }
          return this._grip;
        }
        dispatchEvent(e) {
          if (this._targetRay !== null) {
            this._targetRay.dispatchEvent(e);
          }
          if (this._grip !== null) {
            this._grip.dispatchEvent(e);
          }
          if (this._hand !== null) {
            this._hand.dispatchEvent(e);
          }
          return this;
        }
        disconnect(e) {
          this.dispatchEvent({
            type: "disconnected",
            data: e
          });
          if (this._targetRay !== null) {
            this._targetRay.visible = false;
          }
          if (this._grip !== null) {
            this._grip.visible = false;
          }
          if (this._hand !== null) {
            this._hand.visible = false;
          }
          return this;
        }
        update(e, t, i) {
          let n = null;
          let a = null;
          let r = null;
          const s = this._targetRay;
          const o = this._grip;
          const l = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred") {
            if (l && e.hand) {
              r = true;
              for (const n of e.hand.values()) {
                const e = t.getJointPose(n, i);
                if (l.joints[n.jointName] === undefined) {
                  const e = new Hs();
                  e.matrixAutoUpdate = false;
                  e.visible = false;
                  l.joints[n.jointName] = e;
                  l.add(e);
                }
                const a = l.joints[n.jointName];
                if (e !== null) {
                  a.matrix.fromArray(e.transform.matrix);
                  a.matrix.decompose(a.position, a.rotation, a.scale);
                  a.jointRadius = e.radius;
                }
                a.visible = e !== null;
              }
              const n = l.joints["index-finger-tip"];
              const a = l.joints["thumb-tip"];
              const s = n.position.distanceTo(a.position);
              const o = 0.02;
              const c = 0.005;
              if (l.inputState.pinching && s > o + c) {
                l.inputState.pinching = false;
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: e.handedness,
                  target: this
                });
              } else if (!l.inputState.pinching && s <= o - c) {
                l.inputState.pinching = true;
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: e.handedness,
                  target: this
                });
              }
            } else if (o !== null && e.gripSpace) {
              a = t.getPose(e.gripSpace, i);
              if (a !== null) {
                o.matrix.fromArray(a.transform.matrix);
                o.matrix.decompose(o.position, o.rotation, o.scale);
                if (a.linearVelocity) {
                  o.hasLinearVelocity = true;
                  o.linearVelocity.copy(a.linearVelocity);
                } else {
                  o.hasLinearVelocity = false;
                }
                if (a.angularVelocity) {
                  o.hasAngularVelocity = true;
                  o.angularVelocity.copy(a.angularVelocity);
                } else {
                  o.hasAngularVelocity = false;
                }
              }
            }
            if (s !== null) {
              n = t.getPose(e.targetRaySpace, i);
              if (n === null && a !== null) {
                n = a;
              }
              if (n !== null) {
                s.matrix.fromArray(n.transform.matrix);
                s.matrix.decompose(s.position, s.rotation, s.scale);
                if (n.linearVelocity) {
                  s.hasLinearVelocity = true;
                  s.linearVelocity.copy(n.linearVelocity);
                } else {
                  s.hasLinearVelocity = false;
                }
                if (n.angularVelocity) {
                  s.hasAngularVelocity = true;
                  s.angularVelocity.copy(n.angularVelocity);
                } else {
                  s.hasAngularVelocity = false;
                }
                this.dispatchEvent(Vs);
              }
            }
          }
          if (s !== null) {
            s.visible = n !== null;
          }
          if (o !== null) {
            o.visible = a !== null;
          }
          if (l !== null) {
            l.visible = r !== null;
          }
          return this;
        }
      }
      class Ws extends Jt {
        constructor(e, t, i, n, a, r, s, o, l, c) {
          if ((c = c !== undefined ? c : ke) !== ke && c !== Ae) {
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          }
          if (i === undefined && c === ke) {
            i = _e;
          }
          if (i === undefined && c === Ae) {
            i = we;
          }
          super(null, n, a, r, s, o, c, i, l);
          this.isDepthTexture = true;
          this.image = {
            width: e,
            height: t
          };
          this.magFilter = s !== undefined ? s : se;
          this.minFilter = o !== undefined ? o : se;
          this.flipY = false;
          this.generateMipmaps = false;
        }
      }
      class qs extends yt {
        constructor(e, t) {
          super();
          const i = this;
          let n = null;
          let a = 1;
          let r = null;
          let s = "local-floor";
          let o = null;
          let l = null;
          let c = null;
          let h = null;
          let d = null;
          let u = null;
          const p = t.getContextAttributes();
          let m = null;
          let f = null;
          const g = [];
          const _ = [];
          const v = new sa();
          v.layers.enable(1);
          v.viewport = new Zt();
          const b = new sa();
          b.layers.enable(2);
          b.viewport = new Zt();
          const y = [v, b];
          const x = new Bs();
          x.layers.enable(1);
          x.layers.enable(2);
          let w = null;
          let M = null;
          function S(e) {
            const t = _.indexOf(e.inputSource);
            if (t === -1) {
              return;
            }
            const i = g[t];
            if (i !== undefined) {
              i.dispatchEvent({
                type: e.type,
                data: e.inputSource
              });
            }
          }
          function E() {
            n.removeEventListener("select", S);
            n.removeEventListener("selectstart", S);
            n.removeEventListener("selectend", S);
            n.removeEventListener("squeeze", S);
            n.removeEventListener("squeezestart", S);
            n.removeEventListener("squeezeend", S);
            n.removeEventListener("end", E);
            n.removeEventListener("inputsourceschange", T);
            for (let e = 0; e < g.length; e++) {
              const t = _[e];
              if (t !== null) {
                _[e] = null;
                g[e].disconnect(t);
              }
            }
            w = null;
            M = null;
            e.setRenderTarget(m);
            d = null;
            h = null;
            c = null;
            n = null;
            f = null;
            R.stop();
            i.isPresenting = false;
            i.dispatchEvent({
              type: "sessionend"
            });
          }
          function T(e) {
            for (let t = 0; t < e.removed.length; t++) {
              const i = e.removed[t];
              const n = _.indexOf(i);
              if (n >= 0) {
                _[n] = null;
                g[n].dispatchEvent({
                  type: "disconnected",
                  data: i
                });
              }
            }
            for (let t = 0; t < e.added.length; t++) {
              const i = e.added[t];
              let n = _.indexOf(i);
              if (n === -1) {
                for (let e = 0; e < g.length; e++) {
                  if (e >= _.length) {
                    _.push(i);
                    n = e;
                    break;
                  }
                  if (_[e] === null) {
                    _[e] = i;
                    n = e;
                    break;
                  }
                }
                if (n === -1) {
                  break;
                }
              }
              const a = g[n];
              if (a) {
                a.dispatchEvent({
                  type: "connected",
                  data: i
                });
              }
            }
          }
          this.cameraAutoUpdate = true;
          this.enabled = false;
          this.isPresenting = false;
          this.getController = function (e) {
            let t = g[e];
            if (t === undefined) {
              t = new Gs();
              g[e] = t;
            }
            return t.getTargetRaySpace();
          };
          this.getControllerGrip = function (e) {
            let t = g[e];
            if (t === undefined) {
              t = new Gs();
              g[e] = t;
            }
            return t.getGripSpace();
          };
          this.getHand = function (e) {
            let t = g[e];
            if (t === undefined) {
              t = new Gs();
              g[e] = t;
            }
            return t.getHandSpace();
          };
          this.setFramebufferScaleFactor = function (e) {
            a = e;
            if (i.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
            }
          };
          this.setReferenceSpaceType = function (e) {
            s = e;
            if (i.isPresenting === true) {
              console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
            }
          };
          this.getReferenceSpace = function () {
            return o || r;
          };
          this.setReferenceSpace = function (e) {
            o = e;
          };
          this.getBaseLayer = function () {
            if (h !== null) {
              return h;
            } else {
              return d;
            }
          };
          this.getBinding = function () {
            return c;
          };
          this.getFrame = function () {
            return u;
          };
          this.getSession = function () {
            return n;
          };
          this.setSession = async function (l) {
            n = l;
            if (n !== null) {
              m = e.getRenderTarget();
              n.addEventListener("select", S);
              n.addEventListener("selectstart", S);
              n.addEventListener("selectend", S);
              n.addEventListener("squeeze", S);
              n.addEventListener("squeezestart", S);
              n.addEventListener("squeezeend", S);
              n.addEventListener("end", E);
              n.addEventListener("inputsourceschange", T);
              if (p.xrCompatible !== true) {
                await t.makeXRCompatible();
              }
              if (n.renderState.layers === undefined || e.capabilities.isWebGL2 === false) {
                const i = {
                  antialias: n.renderState.layers !== undefined || p.antialias,
                  alpha: p.alpha,
                  depth: p.depth,
                  stencil: p.stencil,
                  framebufferScaleFactor: a
                };
                d = new XRWebGLLayer(n, t, i);
                n.updateRenderState({
                  baseLayer: d
                });
                f = new Qt(d.framebufferWidth, d.framebufferHeight, {
                  format: Ee,
                  type: ue,
                  encoding: e.outputEncoding,
                  stencilBuffer: p.stencil
                });
              } else {
                let i = null;
                let r = null;
                let s = null;
                if (p.depth) {
                  s = p.stencil ? 35056 : 33190;
                  i = p.stencil ? Ae : ke;
                  r = p.stencil ? we : _e;
                }
                const o = {
                  colorFormat: 32856,
                  depthFormat: s,
                  scaleFactor: a
                };
                c = new XRWebGLBinding(n, t);
                h = c.createProjectionLayer(o);
                n.updateRenderState({
                  layers: [h]
                });
                f = new Qt(h.textureWidth, h.textureHeight, {
                  format: Ee,
                  type: ue,
                  depthTexture: new Ws(h.textureWidth, h.textureHeight, r, undefined, undefined, undefined, undefined, undefined, undefined, i),
                  stencilBuffer: p.stencil,
                  encoding: e.outputEncoding,
                  samples: p.antialias ? 4 : 0
                });
                e.properties.get(f).__ignoreDepthValues = h.ignoreDepthValues;
              }
              f.isXRRenderTarget = true;
              this.setFoveation(1);
              o = null;
              r = await n.requestReferenceSpace(s);
              R.setContext(n);
              R.start();
              i.isPresenting = true;
              i.dispatchEvent({
                type: "sessionstart"
              });
            }
          };
          const C = new ni();
          const k = new ni();
          function A(e, t) {
            if (t === null) {
              e.matrixWorld.copy(e.matrix);
            } else {
              e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix);
            }
            e.matrixWorldInverse.copy(e.matrixWorld).invert();
          }
          this.updateCamera = function (e) {
            if (n === null) {
              return;
            }
            x.near = b.near = v.near = e.near;
            x.far = b.far = v.far = e.far;
            if (w !== x.near || M !== x.far) {
              n.updateRenderState({
                depthNear: x.near,
                depthFar: x.far
              });
              w = x.near;
              M = x.far;
            }
            const t = e.parent;
            const i = x.cameras;
            A(x, t);
            for (let e = 0; e < i.length; e++) {
              A(i[e], t);
            }
            x.matrixWorld.decompose(x.position, x.quaternion, x.scale);
            e.matrix.copy(x.matrix);
            e.matrix.decompose(e.position, e.quaternion, e.scale);
            const a = e.children;
            for (let e = 0, t = a.length; e < t; e++) {
              a[e].updateMatrixWorld(true);
            }
            if (i.length === 2) {
              (function (e, t, i) {
                C.setFromMatrixPosition(t.matrixWorld);
                k.setFromMatrixPosition(i.matrixWorld);
                const n = C.distanceTo(k);
                const a = t.projectionMatrix.elements;
                const r = i.projectionMatrix.elements;
                const s = a[14] / (a[10] - 1);
                const o = a[14] / (a[10] + 1);
                const l = (a[9] + 1) / a[5];
                const c = (a[9] - 1) / a[5];
                const h = (a[8] - 1) / a[0];
                const d = (r[8] + 1) / r[0];
                const u = s * h;
                const p = s * d;
                const m = n / (-h + d);
                const f = m * -h;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale);
                e.translateX(f);
                e.translateZ(m);
                e.matrixWorld.compose(e.position, e.quaternion, e.scale);
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = s + m;
                const _ = o + m;
                const v = u - f;
                const b = p + (n - f);
                const y = l * o / _ * g;
                const x = c * o / _ * g;
                e.projectionMatrix.makePerspective(v, b, y, x, g, _);
              })(x, v, b);
            } else {
              x.projectionMatrix.copy(v.projectionMatrix);
            }
          };
          this.getCamera = function () {
            return x;
          };
          this.getFoveation = function () {
            if (h !== null) {
              return h.fixedFoveation;
            } else if (d !== null) {
              return d.fixedFoveation;
            } else {
              return undefined;
            }
          };
          this.setFoveation = function (e) {
            if (h !== null) {
              h.fixedFoveation = e;
            }
            if (d !== null && d.fixedFoveation !== undefined) {
              d.fixedFoveation = e;
            }
          };
          let L = null;
          const R = new va();
          R.setAnimationLoop(function (t, i) {
            l = i.getViewerPose(o || r);
            u = i;
            if (l !== null) {
              const t = l.views;
              if (d !== null) {
                e.setRenderTargetFramebuffer(f, d.framebuffer);
                e.setRenderTarget(f);
              }
              let i = false;
              if (t.length !== x.cameras.length) {
                x.cameras.length = 0;
                i = true;
              }
              for (let n = 0; n < t.length; n++) {
                const a = t[n];
                let r = null;
                if (d !== null) {
                  r = d.getViewport(a);
                } else {
                  const t = c.getViewSubImage(h, a);
                  r = t.viewport;
                  if (n === 0) {
                    e.setRenderTargetTextures(f, t.colorTexture, h.ignoreDepthValues ? undefined : t.depthStencilTexture);
                    e.setRenderTarget(f);
                  }
                }
                let s = y[n];
                if (s === undefined) {
                  s = new sa();
                  s.layers.enable(n);
                  s.viewport = new Zt();
                  y[n] = s;
                }
                s.matrix.fromArray(a.transform.matrix);
                s.projectionMatrix.fromArray(a.projectionMatrix);
                s.viewport.set(r.x, r.y, r.width, r.height);
                if (n === 0) {
                  x.matrix.copy(s.matrix);
                }
                if (i === true) {
                  x.cameras.push(s);
                }
              }
            }
            for (let e = 0; e < g.length; e++) {
              const t = _[e];
              const n = g[e];
              if (t !== null && n !== undefined) {
                n.update(t, i, o || r);
              }
            }
            if (L) {
              L(t, i);
            }
            u = null;
          });
          this.setAnimationLoop = function (e) {
            L = e;
          };
          this.dispose = function () {};
        }
      }
      function js(e, t) {
        function i(i, n) {
          i.opacity.value = n.opacity;
          if (n.color) {
            i.diffuse.value.copy(n.color);
          }
          if (n.emissive) {
            i.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity);
          }
          if (n.map) {
            i.map.value = n.map;
          }
          if (n.alphaMap) {
            i.alphaMap.value = n.alphaMap;
          }
          if (n.bumpMap) {
            i.bumpMap.value = n.bumpMap;
            i.bumpScale.value = n.bumpScale;
            if (n.side === h) {
              i.bumpScale.value *= -1;
            }
          }
          if (n.displacementMap) {
            i.displacementMap.value = n.displacementMap;
            i.displacementScale.value = n.displacementScale;
            i.displacementBias.value = n.displacementBias;
          }
          if (n.emissiveMap) {
            i.emissiveMap.value = n.emissiveMap;
          }
          if (n.normalMap) {
            i.normalMap.value = n.normalMap;
            i.normalScale.value.copy(n.normalScale);
            if (n.side === h) {
              i.normalScale.value.negate();
            }
          }
          if (n.specularMap) {
            i.specularMap.value = n.specularMap;
          }
          if (n.alphaTest > 0) {
            i.alphaTest.value = n.alphaTest;
          }
          const a = t.get(n).envMap;
          if (a) {
            i.envMap.value = a;
            i.flipEnvMap.value = a.isCubeTexture && a.isRenderTargetTexture === false ? -1 : 1;
            i.reflectivity.value = n.reflectivity;
            i.ior.value = n.ior;
            i.refractionRatio.value = n.refractionRatio;
          }
          if (n.lightMap) {
            i.lightMap.value = n.lightMap;
            const t = e.physicallyCorrectLights !== true ? Math.PI : 1;
            i.lightMapIntensity.value = n.lightMapIntensity * t;
          }
          let r;
          let s;
          if (n.aoMap) {
            i.aoMap.value = n.aoMap;
            i.aoMapIntensity.value = n.aoMapIntensity;
          }
          if (n.map) {
            r = n.map;
          } else if (n.specularMap) {
            r = n.specularMap;
          } else if (n.displacementMap) {
            r = n.displacementMap;
          } else if (n.normalMap) {
            r = n.normalMap;
          } else if (n.bumpMap) {
            r = n.bumpMap;
          } else if (n.roughnessMap) {
            r = n.roughnessMap;
          } else if (n.metalnessMap) {
            r = n.metalnessMap;
          } else if (n.alphaMap) {
            r = n.alphaMap;
          } else if (n.emissiveMap) {
            r = n.emissiveMap;
          } else if (n.clearcoatMap) {
            r = n.clearcoatMap;
          } else if (n.clearcoatNormalMap) {
            r = n.clearcoatNormalMap;
          } else if (n.clearcoatRoughnessMap) {
            r = n.clearcoatRoughnessMap;
          } else if (n.iridescenceMap) {
            r = n.iridescenceMap;
          } else if (n.iridescenceThicknessMap) {
            r = n.iridescenceThicknessMap;
          } else if (n.specularIntensityMap) {
            r = n.specularIntensityMap;
          } else if (n.specularColorMap) {
            r = n.specularColorMap;
          } else if (n.transmissionMap) {
            r = n.transmissionMap;
          } else if (n.thicknessMap) {
            r = n.thicknessMap;
          } else if (n.sheenColorMap) {
            r = n.sheenColorMap;
          } else if (n.sheenRoughnessMap) {
            r = n.sheenRoughnessMap;
          }
          if (r !== undefined) {
            if (r.isWebGLRenderTarget) {
              r = r.texture;
            }
            if (r.matrixAutoUpdate === true) {
              r.updateMatrix();
            }
            i.uvTransform.value.copy(r.matrix);
          }
          if (n.aoMap) {
            s = n.aoMap;
          } else if (n.lightMap) {
            s = n.lightMap;
          }
          if (s !== undefined) {
            if (s.isWebGLRenderTarget) {
              s = s.texture;
            }
            if (s.matrixAutoUpdate === true) {
              s.updateMatrix();
            }
            i.uv2Transform.value.copy(s.matrix);
          }
        }
        return {
          refreshFogUniforms: function (e, t) {
            e.fogColor.value.copy(t.color);
            if (t.isFog) {
              e.fogNear.value = t.near;
              e.fogFar.value = t.far;
            } else if (t.isFogExp2) {
              e.fogDensity.value = t.density;
            }
          },
          refreshMaterialUniforms: function (e, n, a, r, s) {
            if (n.isMeshBasicMaterial || n.isMeshLambertMaterial) {
              i(e, n);
            } else if (n.isMeshToonMaterial) {
              i(e, n);
              (function (e, t) {
                if (t.gradientMap) {
                  e.gradientMap.value = t.gradientMap;
                }
              })(e, n);
            } else if (n.isMeshPhongMaterial) {
              i(e, n);
              (function (e, t) {
                e.specular.value.copy(t.specular);
                e.shininess.value = Math.max(t.shininess, 0.0001);
              })(e, n);
            } else if (n.isMeshStandardMaterial) {
              i(e, n);
              (function (e, i) {
                e.roughness.value = i.roughness;
                e.metalness.value = i.metalness;
                if (i.roughnessMap) {
                  e.roughnessMap.value = i.roughnessMap;
                }
                if (i.metalnessMap) {
                  e.metalnessMap.value = i.metalnessMap;
                }
                if (t.get(i).envMap) {
                  e.envMapIntensity.value = i.envMapIntensity;
                }
              })(e, n);
              if (n.isMeshPhysicalMaterial) {
                (function (e, t, i) {
                  e.ior.value = t.ior;
                  if (t.sheen > 0) {
                    e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen);
                    e.sheenRoughness.value = t.sheenRoughness;
                    if (t.sheenColorMap) {
                      e.sheenColorMap.value = t.sheenColorMap;
                    }
                    if (t.sheenRoughnessMap) {
                      e.sheenRoughnessMap.value = t.sheenRoughnessMap;
                    }
                  }
                  if (t.clearcoat > 0) {
                    e.clearcoat.value = t.clearcoat;
                    e.clearcoatRoughness.value = t.clearcoatRoughness;
                    if (t.clearcoatMap) {
                      e.clearcoatMap.value = t.clearcoatMap;
                    }
                    if (t.clearcoatRoughnessMap) {
                      e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap;
                    }
                    if (t.clearcoatNormalMap) {
                      e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale);
                      e.clearcoatNormalMap.value = t.clearcoatNormalMap;
                      if (t.side === h) {
                        e.clearcoatNormalScale.value.negate();
                      }
                    }
                  }
                  if (t.iridescence > 0) {
                    e.iridescence.value = t.iridescence;
                    e.iridescenceIOR.value = t.iridescenceIOR;
                    e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0];
                    e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1];
                    if (t.iridescenceMap) {
                      e.iridescenceMap.value = t.iridescenceMap;
                    }
                    if (t.iridescenceThicknessMap) {
                      e.iridescenceThicknessMap.value = t.iridescenceThicknessMap;
                    }
                  }
                  if (t.transmission > 0) {
                    e.transmission.value = t.transmission;
                    e.transmissionSamplerMap.value = i.texture;
                    e.transmissionSamplerSize.value.set(i.width, i.height);
                    if (t.transmissionMap) {
                      e.transmissionMap.value = t.transmissionMap;
                    }
                    e.thickness.value = t.thickness;
                    if (t.thicknessMap) {
                      e.thicknessMap.value = t.thicknessMap;
                    }
                    e.attenuationDistance.value = t.attenuationDistance;
                    e.attenuationColor.value.copy(t.attenuationColor);
                  }
                  e.specularIntensity.value = t.specularIntensity;
                  e.specularColor.value.copy(t.specularColor);
                  if (t.specularIntensityMap) {
                    e.specularIntensityMap.value = t.specularIntensityMap;
                  }
                  if (t.specularColorMap) {
                    e.specularColorMap.value = t.specularColorMap;
                  }
                })(e, n, s);
              }
            } else if (n.isMeshMatcapMaterial) {
              i(e, n);
              (function (e, t) {
                if (t.matcap) {
                  e.matcap.value = t.matcap;
                }
              })(e, n);
            } else if (n.isMeshDepthMaterial) {
              i(e, n);
            } else if (n.isMeshDistanceMaterial) {
              i(e, n);
              (function (e, t) {
                e.referencePosition.value.copy(t.referencePosition);
                e.nearDistance.value = t.nearDistance;
                e.farDistance.value = t.farDistance;
              })(e, n);
            } else if (n.isMeshNormalMaterial) {
              i(e, n);
            } else if (n.isLineBasicMaterial) {
              (function (e, t) {
                e.diffuse.value.copy(t.color);
                e.opacity.value = t.opacity;
              })(e, n);
              if (n.isLineDashedMaterial) {
                (function (e, t) {
                  e.dashSize.value = t.dashSize;
                  e.totalSize.value = t.dashSize + t.gapSize;
                  e.scale.value = t.scale;
                })(e, n);
              }
            } else if (n.isPointsMaterial) {
              (function (e, t, i, n) {
                let a;
                e.diffuse.value.copy(t.color);
                e.opacity.value = t.opacity;
                e.size.value = t.size * i;
                e.scale.value = n * 0.5;
                if (t.map) {
                  e.map.value = t.map;
                }
                if (t.alphaMap) {
                  e.alphaMap.value = t.alphaMap;
                }
                if (t.alphaTest > 0) {
                  e.alphaTest.value = t.alphaTest;
                }
                if (t.map) {
                  a = t.map;
                } else if (t.alphaMap) {
                  a = t.alphaMap;
                }
                if (a !== undefined) {
                  if (a.matrixAutoUpdate === true) {
                    a.updateMatrix();
                  }
                  e.uvTransform.value.copy(a.matrix);
                }
              })(e, n, a, r);
            } else if (n.isSpriteMaterial) {
              (function (e, t) {
                let i;
                e.diffuse.value.copy(t.color);
                e.opacity.value = t.opacity;
                e.rotation.value = t.rotation;
                if (t.map) {
                  e.map.value = t.map;
                }
                if (t.alphaMap) {
                  e.alphaMap.value = t.alphaMap;
                }
                if (t.alphaTest > 0) {
                  e.alphaTest.value = t.alphaTest;
                }
                if (t.map) {
                  i = t.map;
                } else if (t.alphaMap) {
                  i = t.alphaMap;
                }
                if (i !== undefined) {
                  if (i.matrixAutoUpdate === true) {
                    i.updateMatrix();
                  }
                  e.uvTransform.value.copy(i.matrix);
                }
              })(e, n);
            } else if (n.isShadowMaterial) {
              e.color.value.copy(n.color);
              e.opacity.value = n.opacity;
            } else if (n.isShaderMaterial) {
              n.uniformsNeedUpdate = false;
            }
          }
        };
      }
      function Xs(e, t, i, n) {
        let a = {};
        let r = {};
        let s = [];
        const o = i.isWebGL2 ? e.getParameter(35375) : 0;
        function l(e, t, i) {
          const n = e.value;
          if (i[t] === undefined) {
            i[t] = typeof n == "number" ? n : n.clone();
            return true;
          }
          if (typeof n == "number") {
            if (i[t] !== n) {
              i[t] = n;
              return true;
            }
          } else {
            const e = i[t];
            if (e.equals(n) === false) {
              e.copy(n);
              return true;
            }
          }
          return false;
        }
        function c(e) {
          const t = e.value;
          const i = {
            boundary: 0,
            storage: 0
          };
          if (typeof t == "number") {
            i.boundary = 4;
            i.storage = 4;
          } else if (t.isVector2) {
            i.boundary = 8;
            i.storage = 8;
          } else if (t.isVector3 || t.isColor) {
            i.boundary = 16;
            i.storage = 12;
          } else if (t.isVector4) {
            i.boundary = 16;
            i.storage = 16;
          } else if (t.isMatrix3) {
            i.boundary = 48;
            i.storage = 48;
          } else if (t.isMatrix4) {
            i.boundary = 64;
            i.storage = 64;
          } else if (t.isTexture) {
            console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
          } else {
            console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", t);
          }
          return i;
        }
        function h(t) {
          const i = t.target;
          i.removeEventListener("dispose", h);
          const n = s.indexOf(i.__bindingPointIndex);
          s.splice(n, 1);
          e.deleteBuffer(a[i.id]);
          delete a[i.id];
          delete r[i.id];
        }
        return {
          bind: function (e, t) {
            const i = t.program;
            n.uniformBlockBinding(e, i);
          },
          update: function (i, d) {
            let u = a[i.id];
            if (u === undefined) {
              (function (e) {
                const t = e.uniforms;
                let i = 0;
                let n = 0;
                for (let e = 0, a = t.length; e < a; e++) {
                  const a = t[e];
                  const r = c(a);
                  a.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT);
                  a.__offset = i;
                  if (e > 0) {
                    n = i % 16;
                    if (n !== 0 && 16 - n - r.boundary < 0) {
                      i += 16 - n;
                      a.__offset = i;
                    }
                  }
                  i += r.storage;
                }
                n = i % 16;
                if (n > 0) {
                  i += 16 - n;
                }
                e.__size = i;
                e.__cache = {};
              })(i);
              u = function (t) {
                const i = function () {
                  for (let e = 0; e < o; e++) {
                    if (s.indexOf(e) === -1) {
                      s.push(e);
                      return e;
                    }
                  }
                  console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
                  return 0;
                }();
                t.__bindingPointIndex = i;
                const n = e.createBuffer();
                const a = t.__size;
                const r = t.usage;
                e.bindBuffer(35345, n);
                e.bufferData(35345, a, r);
                e.bindBuffer(35345, null);
                e.bindBufferBase(35345, i, n);
                return n;
              }(i);
              a[i.id] = u;
              i.addEventListener("dispose", h);
            }
            const p = d.program;
            n.updateUBOMapping(i, p);
            const m = t.render.frame;
            if (r[i.id] !== m) {
              (function (t) {
                const i = a[t.id];
                const n = t.uniforms;
                const r = t.__cache;
                e.bindBuffer(35345, i);
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  if (l(i, t, r) === true) {
                    const t = i.value;
                    const n = i.__offset;
                    if (typeof t == "number") {
                      i.__data[0] = t;
                      e.bufferSubData(35345, n, i.__data);
                    } else {
                      if (i.value.isMatrix3) {
                        i.__data[0] = i.value.elements[0];
                        i.__data[1] = i.value.elements[1];
                        i.__data[2] = i.value.elements[2];
                        i.__data[3] = i.value.elements[0];
                        i.__data[4] = i.value.elements[3];
                        i.__data[5] = i.value.elements[4];
                        i.__data[6] = i.value.elements[5];
                        i.__data[7] = i.value.elements[0];
                        i.__data[8] = i.value.elements[6];
                        i.__data[9] = i.value.elements[7];
                        i.__data[10] = i.value.elements[8];
                        i.__data[11] = i.value.elements[0];
                      } else {
                        t.toArray(i.__data);
                      }
                      e.bufferSubData(35345, n, i.__data);
                    }
                  }
                }
                e.bindBuffer(35345, null);
              })(i);
              r[i.id] = m;
            }
          },
          dispose: function () {
            for (const t in a) {
              e.deleteBuffer(a[t]);
            }
            s = [];
            a = {};
            r = {};
          }
        };
      }
      function Ks(e = {}) {
        this.isWebGLRenderer = true;
        const i = e.canvas !== undefined ? e.canvas : function () {
          const e = It("canvas");
          e.style.display = "block";
          return e;
        }();
        const n = e.context !== undefined ? e.context : null;
        const a = e.depth === undefined || e.depth;
        const r = e.stencil === undefined || e.stencil;
        const s = e.antialias !== undefined && e.antialias;
        const o = e.premultipliedAlpha === undefined || e.premultipliedAlpha;
        const l = e.preserveDrawingBuffer !== undefined && e.preserveDrawingBuffer;
        const u = e.powerPreference !== undefined ? e.powerPreference : "default";
        const p = e.failIfMajorPerformanceCaveat !== undefined && e.failIfMajorPerformanceCaveat;
        let m;
        m = n !== null ? n.getContextAttributes().alpha : e.alpha !== undefined && e.alpha;
        let f = null;
        let g = null;
        const _ = [];
        const v = [];
        this.domElement = i;
        this.debug = {
          checkShaderErrors: true
        };
        this.autoClear = true;
        this.autoClearColor = true;
        this.autoClearDepth = true;
        this.autoClearStencil = true;
        this.sortObjects = true;
        this.clippingPlanes = [];
        this.localClippingEnabled = false;
        this.outputEncoding = ht;
        this.physicallyCorrectLights = false;
        this.toneMapping = q;
        this.toneMappingExposure = 1;
        Object.defineProperties(this, {
          gammaFactor: {
            get: function () {
              console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
              return 2;
            },
            set: function () {
              console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
            }
          }
        });
        const b = this;
        let y = false;
        let x = 0;
        let w = 0;
        let M = null;
        let S = -1;
        let E = null;
        const T = new Zt();
        const C = new Zt();
        let k = null;
        let A = i.width;
        let L = i.height;
        let R = 1;
        let P = null;
        let D = null;
        const I = new Zt(0, 0, A, L);
        const $ = new Zt(0, 0, A, L);
        let z = false;
        const N = new _a();
        let O = false;
        let U = false;
        let F = null;
        const B = new Ii();
        const H = new Rt();
        const V = new ni();
        const G = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        function W() {
          if (M === null) {
            return R;
          } else {
            return 1;
          }
        }
        let j;
        let X;
        let K;
        let Y;
        let J;
        let Z;
        let Q;
        let ee;
        let te;
        let ie;
        let ne;
        let ae;
        let re;
        let se;
        let oe;
        let le;
        let ce;
        let he;
        let pe;
        let me;
        let fe;
        let ge;
        let _e;
        let ye;
        let xe = n;
        function we(e, t) {
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            const r = i.getContext(a, t);
            if (r !== null) {
              return r;
            }
          }
          return null;
        }
        try {
          const e = {
            alpha: true,
            depth: a,
            stencil: r,
            antialias: s,
            premultipliedAlpha: o,
            preserveDrawingBuffer: l,
            powerPreference: u,
            failIfMajorPerformanceCaveat: p
          };
          if ("setAttribute" in i) {
            i.setAttribute("data-engine", `three.js r${t}`);
          }
          i.addEventListener("webglcontextlost", Te, false);
          i.addEventListener("webglcontextrestored", Ce, false);
          i.addEventListener("webglcontextcreationerror", ke, false);
          if (xe === null) {
            const t = ["webgl2", "webgl", "experimental-webgl"];
            if (b.isWebGL1Renderer === true) {
              t.shift();
            }
            xe = we(t, e);
            if (xe === null) {
              throw we(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          }
          if (xe.getShaderPrecisionFormat === undefined) {
            xe.getShaderPrecisionFormat = function () {
              return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
              };
            };
          }
        } catch (e) {
          console.error("THREE.WebGLRenderer: " + e.message);
          throw e;
        }
        function Me() {
          j = new Ga(xe);
          X = new Ca(xe, j, e);
          j.init(X);
          ge = new Fs(xe, j, X);
          K = new Os(xe, j, X);
          Y = new ja();
          J = new ws();
          Z = new Us(xe, j, K, J, X, ge, Y);
          Q = new Aa(b);
          ee = new Va(b);
          te = new ba(xe, X);
          _e = new Ea(xe, j, te, X);
          ie = new Wa(xe, te, Y, _e);
          ne = new Ja(xe, ie, te, Y);
          pe = new Ya(xe, X, Z);
          le = new ka(J);
          ae = new xs(b, Q, ee, j, X, _e, le);
          re = new js(b, J);
          se = new Ts();
          oe = new Ps(j, X);
          he = new Sa(b, Q, K, ne, m, o);
          ce = new Ns(b, ne, X);
          ye = new Xs(xe, Y, X, K);
          me = new Ta(xe, j, Y, X);
          fe = new qa(xe, j, Y, X);
          Y.programs = ae.programs;
          b.capabilities = X;
          b.extensions = j;
          b.properties = J;
          b.renderLists = se;
          b.shadowMap = ce;
          b.state = K;
          b.info = Y;
        }
        Me();
        const Se = new qs(b, xe);
        function Te(e) {
          e.preventDefault();
          console.log("THREE.WebGLRenderer: Context Lost.");
          y = true;
        }
        function Ce() {
          console.log("THREE.WebGLRenderer: Context Restored.");
          y = false;
          const e = Y.autoReset;
          const t = ce.enabled;
          const i = ce.autoUpdate;
          const n = ce.needsUpdate;
          const a = ce.type;
          Me();
          Y.autoReset = e;
          ce.enabled = t;
          ce.autoUpdate = i;
          ce.needsUpdate = n;
          ce.type = a;
        }
        function ke(e) {
          console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage);
        }
        function Ae(e) {
          const t = e.target;
          t.removeEventListener("dispose", Ae);
          (function (e) {
            (function (e) {
              const t = J.get(e).programs;
              if (t !== undefined) {
                t.forEach(function (e) {
                  ae.releaseProgram(e);
                });
                if (e.isShaderMaterial) {
                  ae.releaseShaderCache(e);
                }
              }
            })(e);
            J.remove(e);
          })(t);
        }
        this.xr = Se;
        this.getContext = function () {
          return xe;
        };
        this.getContextAttributes = function () {
          return xe.getContextAttributes();
        };
        this.forceContextLoss = function () {
          const e = j.get("WEBGL_lose_context");
          if (e) {
            e.loseContext();
          }
        };
        this.forceContextRestore = function () {
          const e = j.get("WEBGL_lose_context");
          if (e) {
            e.restoreContext();
          }
        };
        this.getPixelRatio = function () {
          return R;
        };
        this.setPixelRatio = function (e) {
          if (e !== undefined) {
            R = e;
            this.setSize(A, L, false);
          }
        };
        this.getSize = function (e) {
          return e.set(A, L);
        };
        this.setSize = function (e, t, n) {
          if (Se.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
          } else {
            A = e;
            L = t;
            i.width = Math.floor(e * R);
            i.height = Math.floor(t * R);
            if (n !== false) {
              i.style.width = e + "px";
              i.style.height = t + "px";
            }
            this.setViewport(0, 0, e, t);
          }
        };
        this.getDrawingBufferSize = function (e) {
          return e.set(A * R, L * R).floor();
        };
        this.setDrawingBufferSize = function (e, t, n) {
          A = e;
          L = t;
          R = n;
          i.width = Math.floor(e * n);
          i.height = Math.floor(t * n);
          this.setViewport(0, 0, e, t);
        };
        this.getCurrentViewport = function (e) {
          return e.copy(T);
        };
        this.getViewport = function (e) {
          return e.copy(I);
        };
        this.setViewport = function (e, t, i, n) {
          if (e.isVector4) {
            I.set(e.x, e.y, e.z, e.w);
          } else {
            I.set(e, t, i, n);
          }
          K.viewport(T.copy(I).multiplyScalar(R).floor());
        };
        this.getScissor = function (e) {
          return e.copy($);
        };
        this.setScissor = function (e, t, i, n) {
          if (e.isVector4) {
            $.set(e.x, e.y, e.z, e.w);
          } else {
            $.set(e, t, i, n);
          }
          K.scissor(C.copy($).multiplyScalar(R).floor());
        };
        this.getScissorTest = function () {
          return z;
        };
        this.setScissorTest = function (e) {
          K.setScissorTest(z = e);
        };
        this.setOpaqueSort = function (e) {
          P = e;
        };
        this.setTransparentSort = function (e) {
          D = e;
        };
        this.getClearColor = function (e) {
          return e.copy(he.getClearColor());
        };
        this.setClearColor = function () {
          he.setClearColor.apply(he, arguments);
        };
        this.getClearAlpha = function () {
          return he.getClearAlpha();
        };
        this.setClearAlpha = function () {
          he.setClearAlpha.apply(he, arguments);
        };
        this.clear = function (e = true, t = true, i = true) {
          let n = 0;
          if (e) {
            n |= 16384;
          }
          if (t) {
            n |= 256;
          }
          if (i) {
            n |= 1024;
          }
          xe.clear(n);
        };
        this.clearColor = function () {
          this.clear(true, false, false);
        };
        this.clearDepth = function () {
          this.clear(false, true, false);
        };
        this.clearStencil = function () {
          this.clear(false, false, true);
        };
        this.dispose = function () {
          i.removeEventListener("webglcontextlost", Te, false);
          i.removeEventListener("webglcontextrestored", Ce, false);
          i.removeEventListener("webglcontextcreationerror", ke, false);
          se.dispose();
          oe.dispose();
          J.dispose();
          Q.dispose();
          ee.dispose();
          ne.dispose();
          _e.dispose();
          ye.dispose();
          ae.dispose();
          Se.dispose();
          Se.removeEventListener("sessionstart", Re);
          Se.removeEventListener("sessionend", Pe);
          if (F) {
            F.dispose();
            F = null;
          }
          De.stop();
        };
        this.renderBufferDirect = function (e, t, i, n, a, r) {
          if (t === null) {
            t = G;
          }
          const s = a.isMesh && a.matrixWorld.determinant() < 0;
          const o = function (e, t, i, n, a) {
            if (t.isScene !== true) {
              t = G;
            }
            Z.resetTextureUnits();
            const r = t.fog;
            const s = n.isMeshStandardMaterial ? t.environment : null;
            const o = M === null ? b.outputEncoding : M.isXRRenderTarget === true ? M.texture.encoding : ht;
            const l = (n.isMeshStandardMaterial ? ee : Q).get(n.envMap || s);
            const c = n.vertexColors === true && !!i.attributes.color && i.attributes.color.itemSize === 4;
            const h = !!n.normalMap && !!i.attributes.tangent;
            const d = !!i.morphAttributes.position;
            const u = !!i.morphAttributes.normal;
            const p = !!i.morphAttributes.color;
            const m = n.toneMapped ? b.toneMapping : q;
            const f = i.morphAttributes.position || i.morphAttributes.normal || i.morphAttributes.color;
            const _ = f !== undefined ? f.length : 0;
            const v = J.get(n);
            const y = g.state.lights;
            if (O === true && (U === true || e !== E)) {
              const t = e === E && n.id === S;
              le.setState(n, e, t);
            }
            let x = false;
            if (n.version === v.__version) {
              if (v.needsLights && v.lightsStateVersion !== y.state.version || v.outputEncoding !== o || a.isInstancedMesh && v.instancing === false) {
                x = true;
              } else if (a.isInstancedMesh || v.instancing !== true) {
                if (a.isSkinnedMesh && v.skinning === false) {
                  x = true;
                } else if (a.isSkinnedMesh || v.skinning !== true) {
                  if (v.envMap !== l || n.fog === true && v.fog !== r) {
                    x = true;
                  } else if (v.numClippingPlanes === undefined || v.numClippingPlanes === le.numPlanes && v.numIntersection === le.numIntersection) {
                    if (v.vertexAlphas !== c || v.vertexTangents !== h || v.morphTargets !== d || v.morphNormals !== u || v.morphColors !== p || v.toneMapping !== m || X.isWebGL2 === true && v.morphTargetsCount !== _) {
                      x = true;
                    }
                  } else {
                    x = true;
                  }
                } else {
                  x = true;
                }
              } else {
                x = true;
              }
            } else {
              x = true;
              v.__version = n.version;
            }
            let w = v.currentProgram;
            if (x === true) {
              w = Oe(n, t, a);
            }
            let T = false;
            let C = false;
            let k = false;
            const A = w.getUniforms();
            const P = v.uniforms;
            if (K.useProgram(w.program)) {
              T = true;
              C = true;
              k = true;
            }
            if (n.id !== S) {
              S = n.id;
              C = true;
            }
            if (T || E !== e) {
              A.setValue(xe, "projectionMatrix", e.projectionMatrix);
              if (X.logarithmicDepthBuffer) {
                A.setValue(xe, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2));
              }
              if (E !== e) {
                E = e;
                C = true;
                k = true;
              }
              if (n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                const t = A.map.cameraPosition;
                if (t !== undefined) {
                  t.setValue(xe, V.setFromMatrixPosition(e.matrixWorld));
                }
              }
              if (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) {
                A.setValue(xe, "isOrthographic", e.isOrthographicCamera === true);
              }
              if (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || a.isSkinnedMesh) {
                A.setValue(xe, "viewMatrix", e.matrixWorldInverse);
              }
            }
            if (a.isSkinnedMesh) {
              A.setOptional(xe, a, "bindMatrix");
              A.setOptional(xe, a, "bindMatrixInverse");
              const e = a.skeleton;
              if (e) {
                if (X.floatVertexTextures) {
                  if (e.boneTexture === null) {
                    e.computeBoneTexture();
                  }
                  A.setValue(xe, "boneTexture", e.boneTexture, Z);
                  A.setValue(xe, "boneTextureSize", e.boneTextureSize);
                } else {
                  console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
                }
              }
            }
            const D = i.morphAttributes;
            if (D.position !== undefined || D.normal !== undefined || D.color !== undefined && X.isWebGL2 === true) {
              pe.update(a, i, n, w);
            }
            if (C || v.receiveShadow !== a.receiveShadow) {
              v.receiveShadow = a.receiveShadow;
              A.setValue(xe, "receiveShadow", a.receiveShadow);
            }
            if (n.isMeshGouraudMaterial && n.envMap !== null) {
              P.envMap.value = l;
              P.flipEnvMap.value = l.isCubeTexture && l.isRenderTargetTexture === false ? -1 : 1;
            }
            if (C) {
              A.setValue(xe, "toneMappingExposure", b.toneMappingExposure);
              if (v.needsLights) {
                (function (e, t) {
                  e.ambientLightColor.needsUpdate = t;
                  e.lightProbe.needsUpdate = t;
                  e.directionalLights.needsUpdate = t;
                  e.directionalLightShadows.needsUpdate = t;
                  e.pointLights.needsUpdate = t;
                  e.pointLightShadows.needsUpdate = t;
                  e.spotLights.needsUpdate = t;
                  e.spotLightShadows.needsUpdate = t;
                  e.rectAreaLights.needsUpdate = t;
                  e.hemisphereLights.needsUpdate = t;
                })(P, k);
              }
              if (r && n.fog === true) {
                re.refreshFogUniforms(P, r);
              }
              re.refreshMaterialUniforms(P, n, R, L, F);
              ts.upload(xe, v.uniformsList, P, Z);
            }
            if (n.isShaderMaterial && n.uniformsNeedUpdate === true) {
              ts.upload(xe, v.uniformsList, P, Z);
              n.uniformsNeedUpdate = false;
            }
            if (n.isSpriteMaterial) {
              A.setValue(xe, "center", a.center);
            }
            A.setValue(xe, "modelViewMatrix", a.modelViewMatrix);
            A.setValue(xe, "normalMatrix", a.normalMatrix);
            A.setValue(xe, "modelMatrix", a.matrixWorld);
            if (n.isShaderMaterial || n.isRawShaderMaterial) {
              const e = n.uniformsGroups;
              for (let t = 0, i = e.length; t < i; t++) {
                if (X.isWebGL2) {
                  const i = e[t];
                  ye.update(i, w);
                  ye.bind(i, w);
                } else {
                  console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
                }
              }
            }
            return w;
          }(e, t, i, n, a);
          K.setMaterial(n, s);
          let l = i.index;
          const c = i.attributes.position;
          if (l === null) {
            if (c === undefined || c.count === 0) {
              return;
            }
          } else if (l.count === 0) {
            return;
          }
          let h;
          let d = 1;
          if (n.wireframe === true) {
            l = ie.getWireframeAttribute(i);
            d = 2;
          }
          _e.setup(a, n, o, i, l);
          let u = me;
          if (l !== null) {
            h = te.get(l);
            u = fe;
            u.setIndex(h);
          }
          const p = l !== null ? l.count : c.count;
          const m = i.drawRange.start * d;
          const f = i.drawRange.count * d;
          const _ = r !== null ? r.start * d : 0;
          const v = r !== null ? r.count * d : Infinity;
          const y = Math.max(m, _);
          const x = Math.min(p, m + f, _ + v) - 1;
          const w = Math.max(0, x - y + 1);
          if (w !== 0) {
            if (a.isMesh) {
              if (n.wireframe === true) {
                K.setLineWidth(n.wireframeLinewidth * W());
                u.setMode(1);
              } else {
                u.setMode(4);
              }
            } else if (a.isLine) {
              let e = n.linewidth;
              if (e === undefined) {
                e = 1;
              }
              K.setLineWidth(e * W());
              if (a.isLineSegments) {
                u.setMode(1);
              } else if (a.isLineLoop) {
                u.setMode(2);
              } else {
                u.setMode(3);
              }
            } else if (a.isPoints) {
              u.setMode(0);
            } else if (a.isSprite) {
              u.setMode(4);
            }
            if (a.isInstancedMesh) {
              u.renderInstances(y, w, a.count);
            } else if (i.isInstancedBufferGeometry) {
              const e = Math.min(i.instanceCount, i._maxInstanceCount);
              u.renderInstances(y, w, e);
            } else {
              u.render(y, w);
            }
          }
        };
        this.compile = function (e, t) {
          function i(e, t, i) {
            if (e.transparent === true && e.side === d) {
              e.side = h;
              e.needsUpdate = true;
              Oe(e, t, i);
              e.side = c;
              e.needsUpdate = true;
              Oe(e, t, i);
              e.side = d;
            } else {
              Oe(e, t, i);
            }
          }
          g = oe.get(e);
          g.init();
          v.push(g);
          e.traverseVisible(function (e) {
            if (e.isLight && e.layers.test(t.layers)) {
              g.pushLight(e);
              if (e.castShadow) {
                g.pushShadow(e);
              }
            }
          });
          g.setupLights(b.physicallyCorrectLights);
          e.traverse(function (t) {
            const n = t.material;
            if (n) {
              if (Array.isArray(n)) {
                for (let a = 0; a < n.length; a++) {
                  i(n[a], e, t);
                }
              } else {
                i(n, e, t);
              }
            }
          });
          v.pop();
          g = null;
        };
        let Le = null;
        function Re() {
          De.stop();
        }
        function Pe() {
          De.start();
        }
        const De = new va();
        function Ie(e, t, i, n) {
          if (e.visible === false) {
            return;
          }
          if (e.layers.test(t.layers)) {
            if (e.isGroup) {
              i = e.renderOrder;
            } else if (e.isLOD) {
              if (e.autoUpdate === true) {
                e.update(t);
              }
            } else if (e.isLight) {
              g.pushLight(e);
              if (e.castShadow) {
                g.pushShadow(e);
              }
            } else if (e.isSprite) {
              if (!e.frustumCulled || N.intersectsSprite(e)) {
                if (n) {
                  V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
                }
                const t = ne.update(e);
                const a = e.material;
                if (a.visible) {
                  f.push(e, t, a, i, V.z, null);
                }
              }
            } else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Y.render.frame && (e.skeleton.update(), e.skeleton.frame = Y.render.frame), !e.frustumCulled || N.intersectsObject(e))) {
              if (n) {
                V.setFromMatrixPosition(e.matrixWorld).applyMatrix4(B);
              }
              const t = ne.update(e);
              const a = e.material;
              if (Array.isArray(a)) {
                const n = t.groups;
                for (let r = 0, s = n.length; r < s; r++) {
                  const s = n[r];
                  const o = a[s.materialIndex];
                  if (o && o.visible) {
                    f.push(e, t, o, i, V.z, s);
                  }
                }
              } else if (a.visible) {
                f.push(e, t, a, i, V.z, null);
              }
            }
          }
          const a = e.children;
          for (let e = 0, r = a.length; e < r; e++) {
            Ie(a[e], t, i, n);
          }
        }
        function $e(e, t, i, n) {
          const a = e.opaque;
          const r = e.transmissive;
          const o = e.transparent;
          g.setupLightsView(i);
          if (r.length > 0) {
            (function (e, t, i) {
              const n = X.isWebGL2;
              if (F === null) {
                F = new Qt(1, 1, {
                  generateMipmaps: true,
                  type: j.has("EXT_color_buffer_half_float") ? be : ue,
                  minFilter: de,
                  samples: n && s === true ? 4 : 0
                });
              }
              b.getDrawingBufferSize(H);
              if (n) {
                F.setSize(H.x, H.y);
              } else {
                F.setSize(kt(H.x), kt(H.y));
              }
              const a = b.getRenderTarget();
              b.setRenderTarget(F);
              b.clear();
              const r = b.toneMapping;
              b.toneMapping = q;
              ze(e, t, i);
              b.toneMapping = r;
              Z.updateMultisampleRenderTarget(F);
              Z.updateRenderTargetMipmap(F);
              b.setRenderTarget(a);
            })(a, t, i);
          }
          if (n) {
            K.viewport(T.copy(n));
          }
          if (a.length > 0) {
            ze(a, t, i);
          }
          if (r.length > 0) {
            ze(r, t, i);
          }
          if (o.length > 0) {
            ze(o, t, i);
          }
          K.buffers.depth.setTest(true);
          K.buffers.depth.setMask(true);
          K.buffers.color.setMask(true);
          K.setPolygonOffset(false);
        }
        function ze(e, t, i) {
          const n = t.isScene === true ? t.overrideMaterial : null;
          for (let a = 0, r = e.length; a < r; a++) {
            const r = e[a];
            const s = r.object;
            const o = r.geometry;
            const l = n === null ? r.material : n;
            const c = r.group;
            if (s.layers.test(i.layers)) {
              Ne(s, t, i, o, l, c);
            }
          }
        }
        function Ne(e, t, i, n, a, r) {
          e.onBeforeRender(b, t, i, n, a, r);
          e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld);
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix);
          a.onBeforeRender(b, t, i, n, e, r);
          if (a.transparent === true && a.side === d) {
            a.side = h;
            a.needsUpdate = true;
            b.renderBufferDirect(i, t, n, a, e, r);
            a.side = c;
            a.needsUpdate = true;
            b.renderBufferDirect(i, t, n, a, e, r);
            a.side = d;
          } else {
            b.renderBufferDirect(i, t, n, a, e, r);
          }
          e.onAfterRender(b, t, i, n, a, r);
        }
        function Oe(e, t, i) {
          if (t.isScene !== true) {
            t = G;
          }
          const n = J.get(e);
          const a = g.state.lights;
          const r = g.state.shadowsArray;
          const s = a.state.version;
          const o = ae.getParameters(e, a.state, r, t, i);
          const l = ae.getProgramCacheKey(o);
          let c = n.programs;
          n.environment = e.isMeshStandardMaterial ? t.environment : null;
          n.fog = t.fog;
          n.envMap = (e.isMeshStandardMaterial ? ee : Q).get(e.envMap || n.environment);
          if (c === undefined) {
            e.addEventListener("dispose", Ae);
            c = new Map();
            n.programs = c;
          }
          let h = c.get(l);
          if (h !== undefined) {
            if (n.currentProgram === h && n.lightsStateVersion === s) {
              Ue(e, o);
              return h;
            }
          } else {
            o.uniforms = ae.getUniforms(e);
            e.onBuild(i, o, b);
            e.onBeforeCompile(o, b);
            h = ae.acquireProgram(o, l);
            c.set(l, h);
            n.uniforms = o.uniforms;
          }
          const d = n.uniforms;
          if (!e.isShaderMaterial && !e.isRawShaderMaterial || e.clipping === true) {
            d.clippingPlanes = le.uniform;
          }
          Ue(e, o);
          n.needsLights = function (e) {
            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && e.lights === true;
          }(e);
          n.lightsStateVersion = s;
          if (n.needsLights) {
            d.ambientLightColor.value = a.state.ambient;
            d.lightProbe.value = a.state.probe;
            d.directionalLights.value = a.state.directional;
            d.directionalLightShadows.value = a.state.directionalShadow;
            d.spotLights.value = a.state.spot;
            d.spotLightShadows.value = a.state.spotShadow;
            d.rectAreaLights.value = a.state.rectArea;
            d.ltc_1.value = a.state.rectAreaLTC1;
            d.ltc_2.value = a.state.rectAreaLTC2;
            d.pointLights.value = a.state.point;
            d.pointLightShadows.value = a.state.pointShadow;
            d.hemisphereLights.value = a.state.hemi;
            d.directionalShadowMap.value = a.state.directionalShadowMap;
            d.directionalShadowMatrix.value = a.state.directionalShadowMatrix;
            d.spotShadowMap.value = a.state.spotShadowMap;
            d.spotLightMatrix.value = a.state.spotLightMatrix;
            d.spotLightMap.value = a.state.spotLightMap;
            d.pointShadowMap.value = a.state.pointShadowMap;
            d.pointShadowMatrix.value = a.state.pointShadowMatrix;
          }
          const u = h.getUniforms();
          const p = ts.seqWithValue(u.seq, d);
          n.currentProgram = h;
          n.uniformsList = p;
          return h;
        }
        function Ue(e, t) {
          const i = J.get(e);
          i.outputEncoding = t.outputEncoding;
          i.instancing = t.instancing;
          i.skinning = t.skinning;
          i.morphTargets = t.morphTargets;
          i.morphNormals = t.morphNormals;
          i.morphColors = t.morphColors;
          i.morphTargetsCount = t.morphTargetsCount;
          i.numClippingPlanes = t.numClippingPlanes;
          i.numIntersection = t.numClipIntersection;
          i.vertexAlphas = t.vertexAlphas;
          i.vertexTangents = t.vertexTangents;
          i.toneMapping = t.toneMapping;
        }
        De.setAnimationLoop(function (e) {
          if (Le) {
            Le(e);
          }
        });
        if (typeof self != "undefined") {
          De.setContext(self);
        }
        this.setAnimationLoop = function (e) {
          Le = e;
          Se.setAnimationLoop(e);
          if (e === null) {
            De.stop();
          } else {
            De.start();
          }
        };
        Se.addEventListener("sessionstart", Re);
        Se.addEventListener("sessionend", Pe);
        this.render = function (e, t) {
          if (t !== undefined && t.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (y === true) {
            return;
          }
          if (e.matrixWorldAutoUpdate === true) {
            e.updateMatrixWorld();
          }
          if (t.parent === null && t.matrixWorldAutoUpdate === true) {
            t.updateMatrixWorld();
          }
          if (Se.enabled === true && Se.isPresenting === true) {
            if (Se.cameraAutoUpdate === true) {
              Se.updateCamera(t);
            }
            t = Se.getCamera();
          }
          if (e.isScene === true) {
            e.onBeforeRender(b, e, t, M);
          }
          g = oe.get(e, v.length);
          g.init();
          v.push(g);
          B.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse);
          N.setFromProjectionMatrix(B);
          U = this.localClippingEnabled;
          O = le.init(this.clippingPlanes, U, t);
          f = se.get(e, _.length);
          f.init();
          _.push(f);
          Ie(e, t, 0, b.sortObjects);
          f.finish();
          if (b.sortObjects === true) {
            f.sort(P, D);
          }
          if (O === true) {
            le.beginShadows();
          }
          const i = g.state.shadowsArray;
          ce.render(i, e, t);
          if (O === true) {
            le.endShadows();
          }
          if (this.info.autoReset === true) {
            this.info.reset();
          }
          he.render(f, e);
          g.setupLights(b.physicallyCorrectLights);
          if (t.isArrayCamera) {
            const i = t.cameras;
            for (let t = 0, n = i.length; t < n; t++) {
              const n = i[t];
              $e(f, e, n, n.viewport);
            }
          } else {
            $e(f, e, t);
          }
          if (M !== null) {
            Z.updateMultisampleRenderTarget(M);
            Z.updateRenderTargetMipmap(M);
          }
          if (e.isScene === true) {
            e.onAfterRender(b, e, t);
          }
          _e.resetDefaultState();
          S = -1;
          E = null;
          v.pop();
          g = v.length > 0 ? v[v.length - 1] : null;
          _.pop();
          f = _.length > 0 ? _[_.length - 1] : null;
        };
        this.getActiveCubeFace = function () {
          return x;
        };
        this.getActiveMipmapLevel = function () {
          return w;
        };
        this.getRenderTarget = function () {
          return M;
        };
        this.setRenderTargetTextures = function (e, t, i) {
          J.get(e.texture).__webglTexture = t;
          J.get(e.depthTexture).__webglTexture = i;
          const n = J.get(e);
          n.__hasExternalTextures = true;
          if (n.__hasExternalTextures) {
            n.__autoAllocateDepthBuffer = i === undefined;
            if (!n.__autoAllocateDepthBuffer) {
              if (j.has("WEBGL_multisampled_render_to_texture") === true) {
                console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
                n.__useRenderToTexture = false;
              }
            }
          }
        };
        this.setRenderTargetFramebuffer = function (e, t) {
          const i = J.get(e);
          i.__webglFramebuffer = t;
          i.__useDefaultFramebuffer = t === undefined;
        };
        this.setRenderTarget = function (e, t = 0, i = 0) {
          M = e;
          x = t;
          w = i;
          let n = true;
          if (e) {
            const t = J.get(e);
            if (t.__useDefaultFramebuffer !== undefined) {
              K.bindFramebuffer(36160, null);
              n = false;
            } else if (t.__webglFramebuffer === undefined) {
              Z.setupRenderTarget(e);
            } else if (t.__hasExternalTextures) {
              Z.rebindTextures(e, J.get(e.texture).__webglTexture, J.get(e.depthTexture).__webglTexture);
            }
          }
          let a = null;
          let r = false;
          let s = false;
          if (e) {
            const i = e.texture;
            if (i.isData3DTexture || i.isDataArrayTexture) {
              s = true;
            }
            const n = J.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget) {
              a = n[t];
              r = true;
            } else {
              a = X.isWebGL2 && e.samples > 0 && Z.useMultisampledRTT(e) === false ? J.get(e).__webglMultisampledFramebuffer : n;
            }
            T.copy(e.viewport);
            C.copy(e.scissor);
            k = e.scissorTest;
          } else {
            T.copy(I).multiplyScalar(R).floor();
            C.copy($).multiplyScalar(R).floor();
            k = z;
          }
          if (K.bindFramebuffer(36160, a) && X.drawBuffers && n) {
            K.drawBuffers(e, a);
          }
          K.viewport(T);
          K.scissor(C);
          K.setScissorTest(k);
          if (r) {
            const n = J.get(e.texture);
            xe.framebufferTexture2D(36160, 36064, 34069 + t, n.__webglTexture, i);
          } else if (s) {
            const n = J.get(e.texture);
            const a = t || 0;
            xe.framebufferTextureLayer(36160, 36064, n.__webglTexture, i || 0, a);
          }
          S = -1;
        };
        this.readRenderTargetPixels = function (e, t, i, n, a, r, s) {
          if (!e || !e.isWebGLRenderTarget) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let o = J.get(e).__webglFramebuffer;
          if (e.isWebGLCubeRenderTarget && s !== undefined) {
            o = o[s];
          }
          if (o) {
            K.bindFramebuffer(36160, o);
            try {
              const s = e.texture;
              const o = s.format;
              const l = s.type;
              if (o !== Ee && ge.convert(o) !== xe.getParameter(35739)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              const c = l === be && (j.has("EXT_color_buffer_half_float") || X.isWebGL2 && j.has("EXT_color_buffer_float"));
              if (l !== ue && ge.convert(l) !== xe.getParameter(35738) && (l !== ve || !X.isWebGL2 && !j.has("OES_texture_float") && !j.has("WEBGL_color_buffer_float")) && !c) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              if (t >= 0 && t <= e.width - n && i >= 0 && i <= e.height - a) {
                xe.readPixels(t, i, n, a, ge.convert(o), ge.convert(l), r);
              }
            } finally {
              const e = M !== null ? J.get(M).__webglFramebuffer : null;
              K.bindFramebuffer(36160, e);
            }
          }
        };
        this.copyFramebufferToTexture = function (e, t, i = 0) {
          const n = Math.pow(2, -i);
          const a = Math.floor(t.image.width * n);
          const r = Math.floor(t.image.height * n);
          Z.setTexture2D(t, 0);
          xe.copyTexSubImage2D(3553, i, 0, 0, e.x, e.y, a, r);
          K.unbindTexture();
        };
        this.copyTextureToTexture = function (e, t, i, n = 0) {
          const a = t.image.width;
          const r = t.image.height;
          const s = ge.convert(i.format);
          const o = ge.convert(i.type);
          Z.setTexture2D(i, 0);
          xe.pixelStorei(37440, i.flipY);
          xe.pixelStorei(37441, i.premultiplyAlpha);
          xe.pixelStorei(3317, i.unpackAlignment);
          if (t.isDataTexture) {
            xe.texSubImage2D(3553, n, e.x, e.y, a, r, s, o, t.image.data);
          } else if (t.isCompressedTexture) {
            xe.compressedTexSubImage2D(3553, n, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data);
          } else {
            xe.texSubImage2D(3553, n, e.x, e.y, s, o, t.image);
          }
          if (n === 0 && i.generateMipmaps) {
            xe.generateMipmap(3553);
          }
          K.unbindTexture();
        };
        this.copyTextureToTexture3D = function (e, t, i, n, a = 0) {
          if (b.isWebGL1Renderer) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            return;
          }
          const r = e.max.x - e.min.x + 1;
          const s = e.max.y - e.min.y + 1;
          const o = e.max.z - e.min.z + 1;
          const l = ge.convert(n.format);
          const c = ge.convert(n.type);
          let h;
          if (n.isData3DTexture) {
            Z.setTexture3D(n, 0);
            h = 32879;
          } else {
            if (!n.isDataArrayTexture) {
              console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
              return;
            }
            Z.setTexture2DArray(n, 0);
            h = 35866;
          }
          xe.pixelStorei(37440, n.flipY);
          xe.pixelStorei(37441, n.premultiplyAlpha);
          xe.pixelStorei(3317, n.unpackAlignment);
          const d = xe.getParameter(3314);
          const u = xe.getParameter(32878);
          const p = xe.getParameter(3316);
          const m = xe.getParameter(3315);
          const f = xe.getParameter(32877);
          const g = i.isCompressedTexture ? i.mipmaps[0] : i.image;
          xe.pixelStorei(3314, g.width);
          xe.pixelStorei(32878, g.height);
          xe.pixelStorei(3316, e.min.x);
          xe.pixelStorei(3315, e.min.y);
          xe.pixelStorei(32877, e.min.z);
          if (i.isDataTexture || i.isData3DTexture) {
            xe.texSubImage3D(h, a, t.x, t.y, t.z, r, s, o, l, c, g.data);
          } else if (i.isCompressedTexture) {
            console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
            xe.compressedTexSubImage3D(h, a, t.x, t.y, t.z, r, s, o, l, g.data);
          } else {
            xe.texSubImage3D(h, a, t.x, t.y, t.z, r, s, o, l, c, g);
          }
          xe.pixelStorei(3314, d);
          xe.pixelStorei(32878, u);
          xe.pixelStorei(3316, p);
          xe.pixelStorei(3315, m);
          xe.pixelStorei(32877, f);
          if (a === 0 && n.generateMipmaps) {
            xe.generateMipmap(h);
          }
          K.unbindTexture();
        };
        this.initTexture = function (e) {
          if (e.isCubeTexture) {
            Z.setTextureCube(e, 0);
          } else if (e.isData3DTexture) {
            Z.setTexture3D(e, 0);
          } else if (e.isDataArrayTexture) {
            Z.setTexture2DArray(e, 0);
          } else {
            Z.setTexture2D(e, 0);
          }
          K.unbindTexture();
        };
        this.resetState = function () {
          x = 0;
          w = 0;
          M = null;
          K.reset();
          _e.reset();
        };
        if (typeof __THREE_DEVTOOLS__ != "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
      }
      (class extends Ks {}).prototype.isWebGL1Renderer = true;
      class Ys extends Jt {
        constructor(e = null, t = 1, i = 1, n, a, r, s, o, l = se, c = se, h, d) {
          super(null, r, s, o, l, c, n, a, h, d);
          this.isDataTexture = true;
          this.image = {
            data: e,
            width: t,
            height: i
          };
          this.generateMipmaps = false;
          this.flipY = false;
          this.unpackAlignment = 1;
        }
      }
      function Js(e, t, i) {
        if (Qs(e)) {
          return new e.constructor(e.subarray(t, i !== undefined ? i : e.length));
        } else {
          return e.slice(t, i);
        }
      }
      function Zs(e, t, i) {
        if (!e || !i && e.constructor === t) {
          return e;
        } else if (typeof t.BYTES_PER_ELEMENT == "number") {
          return new t(e);
        } else {
          return Array.prototype.slice.call(e);
        }
      }
      function Qs(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      class eo {
        constructor(e, t, i, n) {
          this.parameterPositions = e;
          this._cachedIndex = 0;
          this.resultBuffer = n !== undefined ? n : new t.constructor(i);
          this.sampleValues = t;
          this.valueSize = i;
          this.settings = null;
          this.DefaultSettings_ = {};
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex;
          let n = t[i];
          let a = t[i - 1];
          e: {
            t: {
              let r;
              i: {
                n: if (!(e < n)) {
                  for (let r = i + 2;;) {
                    if (n === undefined) {
                      if (e < a) {
                        break n;
                      }
                      i = t.length;
                      this._cachedIndex = i;
                      return this.copySampleValue_(i - 1);
                    }
                    if (i === r) {
                      break;
                    }
                    a = n;
                    n = t[++i];
                    if (e < n) {
                      break t;
                    }
                  }
                  r = t.length;
                  break i;
                }
                if (e >= a) {
                  break e;
                }
                {
                  const s = t[1];
                  if (e < s) {
                    i = 2;
                    a = s;
                  }
                  for (let r = i - 2;;) {
                    if (a === undefined) {
                      this._cachedIndex = 0;
                      return this.copySampleValue_(0);
                    }
                    if (i === r) {
                      break;
                    }
                    n = a;
                    a = t[--i - 1];
                    if (e >= a) {
                      break t;
                    }
                  }
                  r = i;
                  i = 0;
                }
              }
              while (i < r) {
                const n = i + r >>> 1;
                if (e < t[n]) {
                  r = n;
                } else {
                  i = n + 1;
                }
              }
              n = t[i];
              a = t[i - 1];
              if (a === undefined) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (n === undefined) {
                i = t.length;
                this._cachedIndex = i;
                return this.copySampleValue_(i - 1);
              }
            }
            this._cachedIndex = i;
            this.intervalChanged_(i, a, n);
          }
          return this.interpolate_(i, a, e, n);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer;
          const i = this.sampleValues;
          const n = this.valueSize;
          const a = e * n;
          for (let e = 0; e !== n; ++e) {
            t[e] = i[a + e];
          }
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class to extends eo {
        constructor(e, t, i, n) {
          super(e, t, i, n);
          this._weightPrev = -0;
          this._offsetPrev = -0;
          this._weightNext = -0;
          this._offsetNext = -0;
          this.DefaultSettings_ = {
            endingStart: 2400,
            endingEnd: 2400
          };
        }
        intervalChanged_(e, t, i) {
          const n = this.parameterPositions;
          let a = e - 2;
          let r = e + 1;
          let s = n[a];
          let o = n[r];
          if (s === undefined) {
            switch (this.getSettings_().endingStart) {
              case 2401:
                a = e;
                s = t * 2 - i;
                break;
              case 2402:
                a = n.length - 2;
                s = t + n[a] - n[a + 1];
                break;
              default:
                a = e;
                s = i;
            }
          }
          if (o === undefined) {
            switch (this.getSettings_().endingEnd) {
              case 2401:
                r = e;
                o = i * 2 - t;
                break;
              case 2402:
                r = 1;
                o = i + n[1] - n[0];
                break;
              default:
                r = e - 1;
                o = t;
            }
          }
          const l = (i - t) * 0.5;
          const c = this.valueSize;
          this._weightPrev = l / (t - s);
          this._weightNext = l / (o - i);
          this._offsetPrev = a * c;
          this._offsetNext = r * c;
        }
        interpolate_(e, t, i, n) {
          const a = this.resultBuffer;
          const r = this.sampleValues;
          const s = this.valueSize;
          const o = e * s;
          const l = o - s;
          const c = this._offsetPrev;
          const h = this._offsetNext;
          const d = this._weightPrev;
          const u = this._weightNext;
          const p = (i - t) / (n - t);
          const m = p * p;
          const f = m * p;
          const g = -d * f + d * 2 * m - d * p;
          const _ = (1 + d) * f + (-1.5 - d * 2) * m + (-0.5 + d) * p + 1;
          const v = (-1 - u) * f + (1.5 + u) * m + p * 0.5;
          const b = u * f - u * m;
          for (let e = 0; e !== s; ++e) {
            a[e] = g * r[c + e] + _ * r[l + e] + v * r[o + e] + b * r[h + e];
          }
          return a;
        }
      }
      class io extends eo {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e, t, i, n) {
          const a = this.resultBuffer;
          const r = this.sampleValues;
          const s = this.valueSize;
          const o = e * s;
          const l = o - s;
          const c = (i - t) / (n - t);
          const h = 1 - c;
          for (let e = 0; e !== s; ++e) {
            a[e] = r[l + e] * h + r[o + e] * c;
          }
          return a;
        }
      }
      class no extends eo {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class ao {
        constructor(e, t, i, n) {
          if (e === undefined) {
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          }
          if (t === undefined || t.length === 0) {
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          }
          this.name = e;
          this.times = Zs(t, this.TimeBufferType);
          this.values = Zs(i, this.ValueBufferType);
          this.setInterpolation(n || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) {
            i = t.toJSON(e);
          } else {
            i = {
              name: e.name,
              times: Zs(e.times, Array),
              values: Zs(e.values, Array)
            };
            const t = e.getInterpolation();
            if (t !== e.DefaultInterpolation) {
              i.interpolation = t;
            }
          }
          i.type = e.ValueTypeName;
          return i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new no(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new io(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new to(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case ot:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case lt:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case ct:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (t === undefined) {
            const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === undefined) {
              if (e === this.DefaultInterpolation) {
                throw new Error(t);
              }
              this.setInterpolation(this.DefaultInterpolation);
            }
            console.warn("THREE.KeyframeTrack:", t);
            return this;
          }
          this.createInterpolant = t;
          return this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return ot;
            case this.InterpolantFactoryMethodLinear:
              return lt;
            case this.InterpolantFactoryMethodSmooth:
              return ct;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i) {
              t[i] += e;
            }
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let i = 0, n = t.length; i !== n; ++i) {
              t[i] *= e;
            }
          }
          return this;
        }
        trim(e, t) {
          const i = this.times;
          const n = i.length;
          let a = 0;
          let r = n - 1;
          while (a !== n && i[a] < e) {
            ++a;
          }
          while (r !== -1 && i[r] > t) {
            --r;
          }
          ++r;
          if (a !== 0 || r !== n) {
            if (a >= r) {
              r = Math.max(r, 1);
              a = r - 1;
            }
            const e = this.getValueSize();
            this.times = Js(i, a, r);
            this.values = Js(this.values, a * e, r * e);
          }
          return this;
        }
        validate() {
          let e = true;
          const t = this.getValueSize();
          if (t - Math.floor(t) != 0) {
            console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
            e = false;
          }
          const i = this.times;
          const n = this.values;
          const a = i.length;
          if (a === 0) {
            console.error("THREE.KeyframeTrack: Track is empty.", this);
            e = false;
          }
          let r = null;
          for (let t = 0; t !== a; t++) {
            const n = i[t];
            if (typeof n == "number" && isNaN(n)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, n);
              e = false;
              break;
            }
            if (r !== null && r > n) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, t, n, r);
              e = false;
              break;
            }
            r = n;
          }
          if (n !== undefined && Qs(n)) {
            for (let t = 0, i = n.length; t !== i; ++t) {
              const i = n[t];
              if (isNaN(i)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, i);
                e = false;
                break;
              }
            }
          }
          return e;
        }
        optimize() {
          const e = Js(this.times);
          const t = Js(this.values);
          const i = this.getValueSize();
          const n = this.getInterpolation() === ct;
          const a = e.length - 1;
          let r = 1;
          for (let s = 1; s < a; ++s) {
            let a = false;
            const o = e[s];
            if (o !== e[s + 1] && (s !== 1 || o !== e[0])) {
              if (n) {
                a = true;
              } else {
                const e = s * i;
                const n = e - i;
                const r = e + i;
                for (let s = 0; s !== i; ++s) {
                  const i = t[e + s];
                  if (i !== t[n + s] || i !== t[r + s]) {
                    a = true;
                    break;
                  }
                }
              }
            }
            if (a) {
              if (s !== r) {
                e[r] = e[s];
                const n = s * i;
                const a = r * i;
                for (let e = 0; e !== i; ++e) {
                  t[a + e] = t[n + e];
                }
              }
              ++r;
            }
          }
          if (a > 0) {
            e[r] = e[a];
            for (let e = a * i, n = r * i, s = 0; s !== i; ++s) {
              t[n + s] = t[e + s];
            }
            ++r;
          }
          if (r !== e.length) {
            this.times = Js(e, 0, r);
            this.values = Js(t, 0, r * i);
          } else {
            this.times = e;
            this.values = t;
          }
          return this;
        }
        clone() {
          const e = Js(this.times, 0);
          const t = Js(this.values, 0);
          const i = new (0, this.constructor)(this.name, e, t);
          i.createInterpolant = this.createInterpolant;
          return i;
        }
      }
      ao.prototype.TimeBufferType = Float32Array;
      ao.prototype.ValueBufferType = Float32Array;
      ao.prototype.DefaultInterpolation = lt;
      class ro extends ao {}
      ro.prototype.ValueTypeName = "bool";
      ro.prototype.ValueBufferType = Array;
      ro.prototype.DefaultInterpolation = ot;
      ro.prototype.InterpolantFactoryMethodLinear = undefined;
      ro.prototype.InterpolantFactoryMethodSmooth = undefined;
      (class extends ao {}).prototype.ValueTypeName = "color";
      (class extends ao {}).prototype.ValueTypeName = "number";
      class so extends eo {
        constructor(e, t, i, n) {
          super(e, t, i, n);
        }
        interpolate_(e, t, i, n) {
          const a = this.resultBuffer;
          const r = this.sampleValues;
          const s = this.valueSize;
          const o = (i - t) / (n - t);
          let l = e * s;
          for (let e = l + s; l !== e; l += 4) {
            ii.slerpFlat(a, 0, r, l - s, r, l, o);
          }
          return a;
        }
      }
      class oo extends ao {
        InterpolantFactoryMethodLinear(e) {
          return new so(this.times, this.values, this.getValueSize(), e);
        }
      }
      oo.prototype.ValueTypeName = "quaternion";
      oo.prototype.DefaultInterpolation = lt;
      oo.prototype.InterpolantFactoryMethodSmooth = undefined;
      class lo extends ao {}
      lo.prototype.ValueTypeName = "string";
      lo.prototype.ValueBufferType = Array;
      lo.prototype.DefaultInterpolation = ot;
      lo.prototype.InterpolantFactoryMethodLinear = undefined;
      lo.prototype.InterpolantFactoryMethodSmooth = undefined;
      (class extends ao {}).prototype.ValueTypeName = "vector";
      const co = {
        enabled: false,
        files: {},
        add: function (e, t) {
          if (this.enabled !== false) {
            this.files[e] = t;
          }
        },
        get: function (e) {
          if (this.enabled !== false) {
            return this.files[e];
          }
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        }
      };
      class ho {
        constructor(e, t, i) {
          const n = this;
          let a;
          let r = false;
          let s = 0;
          let o = 0;
          const l = [];
          this.onStart = undefined;
          this.onLoad = e;
          this.onProgress = t;
          this.onError = i;
          this.itemStart = function (e) {
            o++;
            if (r === false && n.onStart !== undefined) {
              n.onStart(e, s, o);
            }
            r = true;
          };
          this.itemEnd = function (e) {
            s++;
            if (n.onProgress !== undefined) {
              n.onProgress(e, s, o);
            }
            if (s === o) {
              r = false;
              if (n.onLoad !== undefined) {
                n.onLoad();
              }
            }
          };
          this.itemError = function (e) {
            if (n.onError !== undefined) {
              n.onError(e);
            }
          };
          this.resolveURL = function (e) {
            if (a) {
              return a(e);
            } else {
              return e;
            }
          };
          this.setURLModifier = function (e) {
            a = e;
            return this;
          };
          this.addHandler = function (e, t) {
            l.push(e, t);
            return this;
          };
          this.removeHandler = function (e) {
            const t = l.indexOf(e);
            if (t !== -1) {
              l.splice(t, 2);
            }
            return this;
          };
          this.getHandler = function (e) {
            for (let t = 0, i = l.length; t < i; t += 2) {
              const i = l[t];
              const n = l[t + 1];
              if (i.global) {
                i.lastIndex = 0;
              }
              if (i.test(e)) {
                return n;
              }
            }
            return null;
          };
        }
      }
      const uo = new ho();
      class po {
        constructor(e) {
          this.manager = e !== undefined ? e : uo;
          this.crossOrigin = "anonymous";
          this.withCredentials = false;
          this.path = "";
          this.resourcePath = "";
          this.requestHeader = {};
        }
        load() {}
        loadAsync(e, t) {
          const i = this;
          return new Promise(function (n, a) {
            i.load(e, n, t, a);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          this.crossOrigin = e;
          return this;
        }
        setWithCredentials(e) {
          this.withCredentials = e;
          return this;
        }
        setPath(e) {
          this.path = e;
          return this;
        }
        setResourcePath(e) {
          this.resourcePath = e;
          return this;
        }
        setRequestHeader(e) {
          this.requestHeader = e;
          return this;
        }
      }
      const mo = {};
      class fo extends Error {
        constructor(e, t) {
          super(e);
          this.response = t;
        }
      }
      class go extends po {
        constructor(e) {
          super(e);
        }
        load(e = "", t, i, n) {
          if (this.path !== undefined) {
            e = this.path + e;
          }
          e = this.manager.resolveURL(e);
          const a = co.get(e);
          if (a !== undefined) {
            this.manager.itemStart(e);
            setTimeout(() => {
              if (t) {
                t(a);
              }
              this.manager.itemEnd(e);
            }, 0);
            return a;
          }
          if (mo[e] !== undefined) {
            mo[e].push({
              onLoad: t,
              onProgress: i,
              onError: n
            });
            return;
          }
          mo[e] = [];
          mo[e].push({
            onLoad: t,
            onProgress: i,
            onError: n
          });
          const r = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          });
          const s = this.mimeType;
          const o = this.responseType;
          fetch(r).then(t => {
            if (t.status === 200 || t.status === 0) {
              if (t.status === 0) {
                console.warn("THREE.FileLoader: HTTP Status 0 received.");
              }
              if (typeof ReadableStream == "undefined" || t.body === undefined || t.body.getReader === undefined) {
                return t;
              }
              const i = mo[e];
              const n = t.body.getReader();
              const a = t.headers.get("Content-Length");
              const r = a ? parseInt(a) : 0;
              const s = r !== 0;
              let o = 0;
              const l = new ReadableStream({
                start(e) {
                  (function t() {
                    n.read().then(({
                      done: n,
                      value: a
                    }) => {
                      if (n) {
                        e.close();
                      } else {
                        o += a.byteLength;
                        const n = new ProgressEvent("progress", {
                          lengthComputable: s,
                          loaded: o,
                          total: r
                        });
                        for (let e = 0, t = i.length; e < t; e++) {
                          const t = i[e];
                          if (t.onProgress) {
                            t.onProgress(n);
                          }
                        }
                        e.enqueue(a);
                        t();
                      }
                    });
                  })();
                }
              });
              return new Response(l);
            }
            throw new fo(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t);
          }).then(e => {
            switch (o) {
              case "arraybuffer":
                return e.arrayBuffer();
              case "blob":
                return e.blob();
              case "document":
                return e.text().then(e => new DOMParser().parseFromString(e, s));
              case "json":
                return e.json();
              default:
                if (s === undefined) {
                  return e.text();
                }
                {
                  const t = /charset="?([^;"\s]*)"?/i.exec(s);
                  const i = t && t[1] ? t[1].toLowerCase() : undefined;
                  const n = new TextDecoder(i);
                  return e.arrayBuffer().then(e => n.decode(e));
                }
            }
          }).then(t => {
            co.add(e, t);
            const i = mo[e];
            delete mo[e];
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              if (n.onLoad) {
                n.onLoad(t);
              }
            }
          }).catch(t => {
            const i = mo[e];
            if (i === undefined) {
              this.manager.itemError(e);
              throw t;
            }
            delete mo[e];
            for (let e = 0, n = i.length; e < n; e++) {
              const n = i[e];
              if (n.onError) {
                n.onError(t);
              }
            }
            this.manager.itemError(e);
          }).finally(() => {
            this.manager.itemEnd(e);
          });
          this.manager.itemStart(e);
        }
        setResponseType(e) {
          this.responseType = e;
          return this;
        }
        setMimeType(e) {
          this.mimeType = e;
          return this;
        }
      }
      class _o extends po {
        constructor(e) {
          super(e);
        }
        load(e, t, i, n) {
          const a = this;
          const r = new Ys();
          const s = new go(this.manager);
          s.setResponseType("arraybuffer");
          s.setRequestHeader(this.requestHeader);
          s.setPath(this.path);
          s.setWithCredentials(a.withCredentials);
          s.load(e, function (e) {
            const i = a.parse(e);
            if (i) {
              if (i.image !== undefined) {
                r.image = i.image;
              } else if (i.data !== undefined) {
                r.image.width = i.width;
                r.image.height = i.height;
                r.image.data = i.data;
              }
              r.wrapS = i.wrapS !== undefined ? i.wrapS : ae;
              r.wrapT = i.wrapT !== undefined ? i.wrapT : ae;
              r.magFilter = i.magFilter !== undefined ? i.magFilter : ce;
              r.minFilter = i.minFilter !== undefined ? i.minFilter : ce;
              r.anisotropy = i.anisotropy !== undefined ? i.anisotropy : 1;
              if (i.encoding !== undefined) {
                r.encoding = i.encoding;
              }
              if (i.flipY !== undefined) {
                r.flipY = i.flipY;
              }
              if (i.format !== undefined) {
                r.format = i.format;
              }
              if (i.type !== undefined) {
                r.type = i.type;
              }
              if (i.mipmaps !== undefined) {
                r.mipmaps = i.mipmaps;
                r.minFilter = de;
              }
              if (i.mipmapCount === 1) {
                r.minFilter = ce;
              }
              if (i.generateMipmaps !== undefined) {
                r.generateMipmaps = i.generateMipmaps;
              }
              r.needsUpdate = true;
              if (t) {
                t(r, i);
              }
            }
          }, i, n);
          return r;
        }
      }
      const vo = "\\[\\]\\.:\\/";
      const bo = new RegExp("[" + vo + "]", "g");
      const yo = "[^" + vo + "]";
      const xo = "[^" + vo.replace("\\.", "") + "]";
      const wo = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", yo) + /(WCOD+)?/.source.replace("WCOD", xo) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", yo) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", yo) + "$");
      const Mo = ["material", "materials", "bones", "map"];
      class So {
        constructor(e, t, i) {
          this.path = t;
          this.parsedPath = i || So.parseTrackName(t);
          this.node = So.findNode(e, this.parsedPath.nodeName) || e;
          this.rootNode = e;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
        static create(e, t, i) {
          if (e && e.isAnimationObjectGroup) {
            return new So.Composite(e, t, i);
          } else {
            return new So(e, t, i);
          }
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(bo, "");
        }
        static parseTrackName(e) {
          const t = wo.exec(e);
          if (t === null) {
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          }
          const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
          };
          const n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (n !== undefined && n !== -1) {
            const e = i.nodeName.substring(n + 1);
            if (Mo.indexOf(e) !== -1) {
              i.nodeName = i.nodeName.substring(0, n);
              i.objectName = e;
            }
          }
          if (i.propertyName === null || i.propertyName.length === 0) {
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          }
          return i;
        }
        static findNode(e, t) {
          if (t === undefined || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) {
            return e;
          }
          if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== undefined) {
              return i;
            }
          }
          if (e.children) {
            const i = function (e) {
              for (let n = 0; n < e.length; n++) {
                const a = e[n];
                if (a.name === t || a.uuid === t) {
                  return a;
                }
                const r = i(a.children);
                if (r) {
                  return r;
                }
              }
              return null;
            };
            const n = i(e.children);
            if (n) {
              return n;
            }
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, a = i.length; n !== a; ++n) {
            e[t++] = i[n];
          }
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t];
          this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, a = i.length; n !== a; ++n) {
            i[n] = e[t++];
          }
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, a = i.length; n !== a; ++n) {
            i[n] = e[t++];
          }
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let n = 0, a = i.length; n !== a; ++n) {
            i[n] = e[t++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
          this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t);
          this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(e, t) {
          this.bind();
          this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind();
          this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath;
          const i = t.objectName;
          const n = t.propertyName;
          let a = t.propertyIndex;
          if (!e) {
            e = So.findNode(this.rootNode, t.nodeName) || this.rootNode;
            this.node = e;
          }
          this.getValue = this._getValue_unavailable;
          this.setValue = this._setValue_unavailable;
          if (!e) {
            console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            return;
          }
          if (i) {
            let n = t.objectIndex;
            switch (i) {
              case "materials":
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++) {
                  if (e[t].name === n) {
                    n = t;
                    break;
                  }
                }
                break;
              case "map":
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                e = e.material.map;
                break;
              default:
                if (e[i] === undefined) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                e = e[i];
            }
            if (n !== undefined) {
              if (e[n] === undefined) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                return;
              }
              e = e[n];
            }
          }
          const r = e[n];
          if (r === undefined) {
            const i = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + i + "." + n + " but it wasn't found.", e);
            return;
          }
          let s = this.Versioning.None;
          this.targetObject = e;
          if (e.needsUpdate !== undefined) {
            s = this.Versioning.NeedsUpdate;
          } else if (e.matrixWorldNeedsUpdate !== undefined) {
            s = this.Versioning.MatrixWorldNeedsUpdate;
          }
          let o = this.BindingType.Direct;
          if (a !== undefined) {
            if (n === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!e.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (e.morphTargetDictionary[a] !== undefined) {
                a = e.morphTargetDictionary[a];
              }
            }
            o = this.BindingType.ArrayElement;
            this.resolvedProperty = r;
            this.propertyIndex = a;
          } else if (r.fromArray !== undefined && r.toArray !== undefined) {
            o = this.BindingType.HasFromToArray;
            this.resolvedProperty = r;
          } else if (Array.isArray(r)) {
            o = this.BindingType.EntireArray;
            this.resolvedProperty = r;
          } else {
            this.propertyName = n;
          }
          this.getValue = this.GetterByBindingType[o];
          this.setValue = this.SetterByBindingTypeAndVersioning[o][s];
        }
        unbind() {
          this.node = null;
          this.getValue = this._getValue_unbound;
          this.setValue = this._setValue_unbound;
        }
      }
      So.Composite = class {
        constructor(e, t, i) {
          const n = i || So.parseTrackName(t);
          this._targetGroup = e;
          this._bindings = e.subscribe_(t, n);
        }
        getValue(e, t) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_;
          const n = this._bindings[i];
          if (n !== undefined) {
            n.getValue(e, t);
          }
        }
        setValue(e, t) {
          const i = this._bindings;
          for (let n = this._targetGroup.nCachedObjects_, a = i.length; n !== a; ++n) {
            i[n].setValue(e, t);
          }
        }
        bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) {
            e[t].bind();
          }
        }
        unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) {
            e[t].unbind();
          }
        }
      };
      So.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      };
      So.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      };
      So.prototype.GetterByBindingType = [So.prototype._getValue_direct, So.prototype._getValue_array, So.prototype._getValue_arrayElement, So.prototype._getValue_toArray];
      So.prototype.SetterByBindingTypeAndVersioning = [[So.prototype._setValue_direct, So.prototype._setValue_direct_setNeedsUpdate, So.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [So.prototype._setValue_array, So.prototype._setValue_array_setNeedsUpdate, So.prototype._setValue_array_setMatrixWorldNeedsUpdate], [So.prototype._setValue_arrayElement, So.prototype._setValue_arrayElement_setNeedsUpdate, So.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [So.prototype._setValue_fromArray, So.prototype._setValue_fromArray_setNeedsUpdate, So.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
      new Float32Array(1);
      if (typeof __THREE_DEVTOOLS__ != "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
          detail: {
            revision: t
          }
        }));
      }
      if (typeof window != "undefined") {
        if (window.__THREE__) {
          console.warn("WARNING: Multiple instances of Three.js being imported.");
        } else {
          window.__THREE__ = t;
        }
      }
      var Eo = a(114);
      function To(e, t) {
        var i = [];
        var n = [];
        for (var a = arguments.length; a-- > 2;) {
          i.push(arguments[a]);
        }
        while (i.length) {
          var r = i.pop();
          if (r && r.pop) {
            for (a = r.length; a--;) {
              i.push(r[a]);
            }
          } else if (r != null && r !== true && r !== false) {
            n.push(r);
          }
        }
        if (typeof e == "function") {
          return e(t || {}, n);
        } else {
          return {
            nodeName: e,
            attributes: t || {},
            children: n,
            key: t && t.key
          };
        }
      }
      function Co(e, t, i, n) {
        var a;
        var r = [].map;
        var s = n && n.children[0] || null;
        var o = s && function e(t) {
          return {
            nodeName: t.nodeName.toLowerCase(),
            attributes: {},
            children: r.call(t.childNodes, function (t) {
              if (t.nodeType === 3) {
                return t.nodeValue;
              } else {
                return e(t);
              }
            })
          };
        }(s);
        var l = [];
        var c = true;
        var h = f(e);
        var d = function e(t, i, n) {
          for (var a in n) {
            if (typeof n[a] == "function") {
              (function (e, a) {
                n[e] = function (e) {
                  var r = a(e);
                  if (typeof r == "function") {
                    r = r(_(t, h), n);
                  }
                  if (r && r !== (i = _(t, h)) && !r.then) {
                    m(h = g(t, f(i, r), h));
                  }
                  return r;
                };
              })(a, n[a]);
            } else {
              e(t.concat(a), i[a] = f(i[a]), n[a] = f(n[a]));
            }
          }
          return n;
        }([], h, f(t));
        m();
        return d;
        function u(e) {
          if (typeof e == "function") {
            return u(e(h, d));
          } else {
            return e ?? "";
          }
        }
        function p() {
          a = !a;
          var e = u(i);
          if (n && !a) {
            s = S(n, s, o, o = e);
          }
          c = false;
          while (l.length) {
            l.pop()();
          }
        }
        function m() {
          if (!a) {
            a = true;
            setTimeout(p);
          }
        }
        function f(e, t) {
          var i = {};
          for (var n in e) {
            i[n] = e[n];
          }
          for (var n in t) {
            i[n] = t[n];
          }
          return i;
        }
        function g(e, t, i) {
          var n = {};
          if (e.length) {
            n[e[0]] = e.length > 1 ? g(e.slice(1), t, i[e[0]]) : t;
            return f(i, n);
          } else {
            return t;
          }
        }
        function _(e, t) {
          for (var i = 0; i < e.length;) {
            t = t[e[i++]];
          }
          return t;
        }
        function v(e) {
          if (e) {
            return e.key;
          } else {
            return null;
          }
        }
        function b(e) {
          return e.currentTarget.events[e.type](e);
        }
        function y(e, t, i, n, a) {
          if (t === "key") ;else if (t === "style") {
            if (typeof i == "string") {
              e.style.cssText = i;
            } else {
              if (typeof n == "string") {
                n = e.style.cssText = "";
              }
              for (var r in f(n, i)) {
                var s = i == null || i[r] == null ? "" : i[r];
                if (r[0] === "-") {
                  e.style.setProperty(r, s);
                } else {
                  e.style[r] = s;
                }
              }
            }
          } else {
            if (t[0] === "o" && t[1] === "n") {
              t = t.slice(2);
              if (e.events) {
                n ||= e.events[t];
              } else {
                e.events = {};
              }
              e.events[t] = i;
              if (i) {
                if (!n) {
                  e.addEventListener(t, b);
                }
              } else {
                e.removeEventListener(t, b);
              }
            } else if (t in e && t !== "list" && t !== "type" && t !== "draggable" && t !== "spellcheck" && t !== "translate" && !a) {
              e[t] = i == null ? "" : i;
            } else if (i != null && i !== false) {
              e.setAttribute(t, i);
            }
            if (i == null || i === false) {
              e.removeAttribute(t);
            }
          }
        }
        function x(e, t) {
          var i = typeof e == "string" || typeof e == "number" ? document.createTextNode(e) : (t = t || e.nodeName === "svg") ? document.createElementNS("http://www.w3.org/2000/svg", e.nodeName) : document.createElement(e.nodeName);
          var n = e.attributes;
          if (n) {
            if (n.oncreate) {
              l.push(function () {
                n.oncreate(i);
              });
            }
            for (var a = 0; a < e.children.length; a++) {
              i.appendChild(x(e.children[a] = u(e.children[a]), t));
            }
            for (var r in n) {
              y(i, r, n[r], null, t);
            }
          }
          return i;
        }
        function w(e, t) {
          var i = t.attributes;
          if (i) {
            for (var n = 0; n < t.children.length; n++) {
              w(e.childNodes[n], t.children[n]);
            }
            if (i.ondestroy) {
              i.ondestroy(e);
            }
          }
          return e;
        }
        function M(e, t, i) {
          function n() {
            e.removeChild(w(t, i));
          }
          var a = i.attributes && i.attributes.onremove;
          if (a) {
            a(t, n);
          } else {
            n();
          }
        }
        function S(e, t, i, n, a) {
          if (n === i) ;else if (i == null || i.nodeName !== n.nodeName) {
            var r = x(n, a);
            e.insertBefore(r, t);
            if (i != null) {
              M(e, t, i);
            }
            t = r;
          } else if (i.nodeName == null) {
            t.nodeValue = n;
          } else {
            (function (e, t, i, n) {
              for (var a in f(t, i)) {
                if (i[a] !== (a === "value" || a === "checked" ? e[a] : t[a])) {
                  y(e, a, i[a], t[a], n);
                }
              }
              var r = c ? i.oncreate : i.onupdate;
              if (r) {
                l.push(function () {
                  r(e, t);
                });
              }
            })(t, i.attributes, n.attributes, a = a || n.nodeName === "svg");
            var s = {};
            var o = {};
            var h = [];
            for (var d = i.children, p = n.children, m = 0; m < d.length; m++) {
              h[m] = t.childNodes[m];
              if ((_ = v(d[m])) != null) {
                s[_] = [h[m], d[m]];
              }
            }
            m = 0;
            for (var g = 0; g < p.length;) {
              var _ = v(d[m]);
              var b = v(p[g] = u(p[g]));
              if (o[_]) {
                m++;
              } else if (b == null || b !== v(d[m + 1])) {
                if (b == null || c) {
                  if (_ == null) {
                    S(t, h[m], d[m], p[g], a);
                    g++;
                  }
                  m++;
                } else {
                  var w = s[b] || [];
                  if (_ === b) {
                    S(t, w[0], w[1], p[g], a);
                    m++;
                  } else if (w[0]) {
                    S(t, t.insertBefore(w[0], h[m]), w[1], p[g], a);
                  } else {
                    S(t, h[m], null, p[g], a);
                  }
                  o[b] = p[g];
                  g++;
                }
              } else {
                if (_ == null) {
                  M(t, h[m], d[m]);
                }
                m++;
              }
            }
            while (m < d.length) {
              if (v(d[m]) == null) {
                M(t, h[m], d[m]);
              }
              m++;
            }
            for (var m in s) {
              if (!o[m]) {
                M(t, s[m][0], s[m][1]);
              }
            }
          }
          return t;
        }
      }
      const ko = Object.create(null);
      ko.open = "0";
      ko.close = "1";
      ko.ping = "2";
      ko.pong = "3";
      ko.message = "4";
      ko.upgrade = "5";
      ko.noop = "6";
      const Ao = Object.create(null);
      Object.keys(ko).forEach(e => {
        Ao[ko[e]] = e;
      });
      const Lo = {
        type: "error",
        data: "parser error"
      };
      const Ro = typeof Blob == "function" || typeof Blob != "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
      const Po = typeof ArrayBuffer == "function";
      const Do = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer;
      const Io = ({
        type: e,
        data: t
      }, i, n) => Ro && t instanceof Blob ? i ? n(t) : $o(t, n) : Po && (t instanceof ArrayBuffer || Do(t)) ? i ? n(t) : $o(new Blob([t]), n) : n(ko[e] + (t || ""));
      const $o = (e, t) => {
        const i = new FileReader();
        i.onload = function () {
          const e = i.result.split(",")[1];
          t("b" + (e || ""));
        };
        return i.readAsDataURL(e);
      };
      function zo(e) {
        if (e instanceof Uint8Array) {
          return e;
        } else if (e instanceof ArrayBuffer) {
          return new Uint8Array(e);
        } else {
          return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
        }
      }
      let No;
      const Oo = typeof Uint8Array == "undefined" ? [] : new Uint8Array(256);
      for (let e = 0; e < 64; e++) {
        Oo["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(e)] = e;
      }
      const Uo = typeof ArrayBuffer == "function";
      const Fo = (e, t) => {
        if (typeof e != "string") {
          return {
            type: "message",
            data: Ho(e, t)
          };
        }
        const i = e.charAt(0);
        if (i === "b") {
          return {
            type: "message",
            data: Bo(e.substring(1), t)
          };
        } else if (Ao[i]) {
          if (e.length > 1) {
            return {
              type: Ao[i],
              data: e.substring(1)
            };
          } else {
            return {
              type: Ao[i]
            };
          }
        } else {
          return Lo;
        }
      };
      const Bo = (e, t) => {
        if (Uo) {
          const i = (e => {
            let t;
            let i;
            let n;
            let a;
            let r;
            let s = e.length * 0.75;
            let o = e.length;
            let l = 0;
            if (e[e.length - 1] === "=") {
              s--;
              if (e[e.length - 2] === "=") {
                s--;
              }
            }
            const c = new ArrayBuffer(s);
            const h = new Uint8Array(c);
            for (t = 0; t < o; t += 4) {
              i = Oo[e.charCodeAt(t)];
              n = Oo[e.charCodeAt(t + 1)];
              a = Oo[e.charCodeAt(t + 2)];
              r = Oo[e.charCodeAt(t + 3)];
              h[l++] = i << 2 | n >> 4;
              h[l++] = (n & 15) << 4 | a >> 2;
              h[l++] = (a & 3) << 6 | r & 63;
            }
            return c;
          })(e);
          return Ho(i, t);
        }
        return {
          base64: true,
          data: e
        };
      };
      const Ho = (e, t) => t === "blob" ? e instanceof Blob ? e : new Blob([e]) : e instanceof ArrayBuffer ? e : e.buffer;
      const Vo = String.fromCharCode(30);
      let Go;
      function Wo(e) {
        return e.reduce((e, t) => e + t.length, 0);
      }
      function qo(e, t) {
        if (e[0].length === t) {
          return e.shift();
        }
        const i = new Uint8Array(t);
        let n = 0;
        for (let a = 0; a < t; a++) {
          i[a] = e[0][n++];
          if (n === e[0].length) {
            e.shift();
            n = 0;
          }
        }
        if (e.length && n < e[0].length) {
          e[0] = e[0].slice(n);
        }
        return i;
      }
      function jo(e) {
        if (e) {
          return function (e) {
            for (var t in jo.prototype) {
              e[t] = jo.prototype[t];
            }
            return e;
          }(e);
        }
      }
      jo.prototype.on = jo.prototype.addEventListener = function (e, t) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t);
        return this;
      };
      jo.prototype.once = function (e, t) {
        function i() {
          this.off(e, i);
          t.apply(this, arguments);
        }
        i.fn = t;
        this.on(e, i);
        return this;
      };
      jo.prototype.off = jo.prototype.removeListener = jo.prototype.removeAllListeners = jo.prototype.removeEventListener = function (e, t) {
        this._callbacks = this._callbacks || {};
        if (arguments.length == 0) {
          this._callbacks = {};
          return this;
        }
        var i;
        var n = this._callbacks["$" + e];
        if (!n) {
          return this;
        }
        if (arguments.length == 1) {
          delete this._callbacks["$" + e];
          return this;
        }
        for (var a = 0; a < n.length; a++) {
          if ((i = n[a]) === t || i.fn === t) {
            n.splice(a, 1);
            break;
          }
        }
        if (n.length === 0) {
          delete this._callbacks["$" + e];
        }
        return this;
      };
      jo.prototype.emit = function (e) {
        this._callbacks = this._callbacks || {};
        var t = new Array(arguments.length - 1);
        var i = this._callbacks["$" + e];
        for (var n = 1; n < arguments.length; n++) {
          t[n - 1] = arguments[n];
        }
        if (i) {
          n = 0;
          for (var a = (i = i.slice(0)).length; n < a; ++n) {
            i[n].apply(this, t);
          }
        }
        return this;
      };
      jo.prototype.emitReserved = jo.prototype.emit;
      jo.prototype.listeners = function (e) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + e] || [];
      };
      jo.prototype.hasListeners = function (e) {
        return !!this.listeners(e).length;
      };
      const Xo = typeof self != "undefined" ? self : typeof window != "undefined" ? window : Function("return this")();
      function Ko(e, ...t) {
        return t.reduce((t, i) => {
          if (e.hasOwnProperty(i)) {
            t[i] = e[i];
          }
          return t;
        }, {});
      }
      const Yo = Xo.setTimeout;
      const Jo = Xo.clearTimeout;
      function Zo(e, t) {
        if (t.useNativeTimers) {
          e.setTimeoutFn = Yo.bind(Xo);
          e.clearTimeoutFn = Jo.bind(Xo);
        } else {
          e.setTimeoutFn = Xo.setTimeout.bind(Xo);
          e.clearTimeoutFn = Xo.clearTimeout.bind(Xo);
        }
      }
      class Qo extends Error {
        constructor(e, t, i) {
          super(e);
          this.description = t;
          this.context = i;
          this.type = "TransportError";
        }
      }
      class el extends jo {
        constructor(e) {
          super();
          this.writable = false;
          Zo(this, e);
          this.opts = e;
          this.query = e.query;
          this.socket = e.socket;
        }
        onError(e, t, i) {
          super.emitReserved("error", new Qo(e, t, i));
          return this;
        }
        open() {
          this.readyState = "opening";
          this.doOpen();
          return this;
        }
        close() {
          if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
          }
          return this;
        }
        send(e) {
          if (this.readyState === "open") {
            this.write(e);
          }
        }
        onOpen() {
          this.readyState = "open";
          this.writable = true;
          super.emitReserved("open");
        }
        onData(e) {
          const t = Fo(e, this.socket.binaryType);
          this.onPacket(t);
        }
        onPacket(e) {
          super.emitReserved("packet", e);
        }
        onClose(e) {
          this.readyState = "closed";
          super.emitReserved("close", e);
        }
        pause(e) {}
        createUri(e, t = {}) {
          return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t);
        }
        _hostname() {
          const e = this.opts.hostname;
          if (e.indexOf(":") === -1) {
            return e;
          } else {
            return "[" + e + "]";
          }
        }
        _port() {
          if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
            return ":" + this.opts.port;
          } else {
            return "";
          }
        }
        _query(e) {
          const t = function (e) {
            let t = "";
            for (let i in e) {
              if (e.hasOwnProperty(i)) {
                if (t.length) {
                  t += "&";
                }
                t += encodeURIComponent(i) + "=" + encodeURIComponent(e[i]);
              }
            }
            return t;
          }(e);
          if (t.length) {
            return "?" + t;
          } else {
            return "";
          }
        }
      }
      const tl = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
      const il = 64;
      const nl = {};
      let al;
      let rl = 0;
      let sl = 0;
      function ol(e) {
        let t = "";
        do {
          t = tl[e % il] + t;
          e = Math.floor(e / il);
        } while (e > 0);
        return t;
      }
      function ll() {
        const e = ol(+new Date());
        if (e !== al) {
          rl = 0;
          return al = e;
        } else {
          return e + "." + ol(rl++);
        }
      }
      for (; sl < il; sl++) {
        nl[tl[sl]] = sl;
      }
      let cl = false;
      try {
        cl = typeof XMLHttpRequest != "undefined" && "withCredentials" in new XMLHttpRequest();
      } catch (e) {}
      const hl = cl;
      function dl(e) {
        const t = e.xdomain;
        try {
          if (typeof XMLHttpRequest != "undefined" && (!t || hl)) {
            return new XMLHttpRequest();
          }
        } catch (e) {}
        if (!t) {
          try {
            return new Xo[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
          } catch (e) {}
        }
      }
      function ul() {}
      const pl = new dl({
        xdomain: false
      }).responseType != null;
      class ml extends jo {
        constructor(e, t) {
          super();
          Zo(this, t);
          this.opts = t;
          this.method = t.method || "GET";
          this.uri = e;
          this.data = t.data !== undefined ? t.data : null;
          this.create();
        }
        create() {
          var e;
          const t = Ko(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
          t.xdomain = !!this.opts.xd;
          const i = this.xhr = new dl(t);
          try {
            i.open(this.method, this.uri, true);
            try {
              if (this.opts.extraHeaders) {
                if (i.setDisableHeaderCheck) {
                  i.setDisableHeaderCheck(true);
                }
                for (let e in this.opts.extraHeaders) {
                  if (this.opts.extraHeaders.hasOwnProperty(e)) {
                    i.setRequestHeader(e, this.opts.extraHeaders[e]);
                  }
                }
              }
            } catch (e) {}
            if (this.method === "POST") {
              try {
                i.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
              } catch (e) {}
            }
            try {
              i.setRequestHeader("Accept", "*/*");
            } catch (e) {}
            if ((e = this.opts.cookieJar) !== null && e !== undefined) {
              e.addCookies(i);
            }
            if ("withCredentials" in i) {
              i.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
              i.timeout = this.opts.requestTimeout;
            }
            i.onreadystatechange = () => {
              var e;
              if (i.readyState === 3) {
                if ((e = this.opts.cookieJar) !== null && e !== undefined) {
                  e.parseCookies(i);
                }
              }
              if (i.readyState === 4) {
                if (i.status === 200 || i.status === 1223) {
                  this.onLoad();
                } else {
                  this.setTimeoutFn(() => {
                    this.onError(typeof i.status == "number" ? i.status : 0);
                  }, 0);
                }
              }
            };
            i.send(this.data);
          } catch (e) {
            this.setTimeoutFn(() => {
              this.onError(e);
            }, 0);
            return;
          }
          if (typeof document != "undefined") {
            this.index = ml.requestsCount++;
            ml.requests[this.index] = this;
          }
        }
        onError(e) {
          this.emitReserved("error", e, this.xhr);
          this.cleanup(true);
        }
        cleanup(e) {
          if (this.xhr !== undefined && this.xhr !== null) {
            this.xhr.onreadystatechange = ul;
            if (e) {
              try {
                this.xhr.abort();
              } catch (e) {}
            }
            if (typeof document != "undefined") {
              delete ml.requests[this.index];
            }
            this.xhr = null;
          }
        }
        onLoad() {
          const e = this.xhr.responseText;
          if (e !== null) {
            this.emitReserved("data", e);
            this.emitReserved("success");
            this.cleanup();
          }
        }
        abort() {
          this.cleanup();
        }
      }
      function fl() {
        for (let e in ml.requests) {
          if (ml.requests.hasOwnProperty(e)) {
            ml.requests[e].abort();
          }
        }
      }
      ml.requestsCount = 0;
      ml.requests = {};
      if (typeof document != "undefined") {
        if (typeof attachEvent == "function") {
          attachEvent("onunload", fl);
        } else if (typeof addEventListener == "function") {
          addEventListener("onpagehide" in Xo ? "pagehide" : "unload", fl, false);
        }
      }
      const gl = typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, t) => t(e, 0);
      const _l = Xo.WebSocket || Xo.MozWebSocket;
      const vl = typeof navigator != "undefined" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
      const bl = {
        websocket: class extends el {
          constructor(e) {
            super(e);
            this.supportsBinary = !e.forceBase64;
          }
          get name() {
            return "websocket";
          }
          doOpen() {
            if (!this.check()) {
              return;
            }
            const e = this.uri();
            const t = this.opts.protocols;
            const i = vl ? {} : Ko(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
            if (this.opts.extraHeaders) {
              i.headers = this.opts.extraHeaders;
            }
            try {
              this.ws = vl ? new _l(e, t, i) : t ? new _l(e, t) : new _l(e);
            } catch (e) {
              return this.emitReserved("error", e);
            }
            this.ws.binaryType = this.socket.binaryType;
            this.addEventListeners();
          }
          addEventListeners() {
            this.ws.onopen = () => {
              if (this.opts.autoUnref) {
                this.ws._socket.unref();
              }
              this.onOpen();
            };
            this.ws.onclose = e => this.onClose({
              description: "websocket connection closed",
              context: e
            });
            this.ws.onmessage = e => this.onData(e.data);
            this.ws.onerror = e => this.onError("websocket error", e);
          }
          write(e) {
            this.writable = false;
            for (let t = 0; t < e.length; t++) {
              const i = e[t];
              const n = t === e.length - 1;
              Io(i, this.supportsBinary, e => {
                try {
                  this.ws.send(e);
                } catch (e) {}
                if (n) {
                  gl(() => {
                    this.writable = true;
                    this.emitReserved("drain");
                  }, this.setTimeoutFn);
                }
              });
            }
          }
          doClose() {
            if (this.ws !== undefined) {
              this.ws.close();
              this.ws = null;
            }
          }
          uri() {
            const e = this.opts.secure ? "wss" : "ws";
            const t = this.query || {};
            if (this.opts.timestampRequests) {
              t[this.opts.timestampParam] = ll();
            }
            if (!this.supportsBinary) {
              t.b64 = 1;
            }
            return this.createUri(e, t);
          }
          check() {
            return !!_l;
          }
        },
        webtransport: class extends el {
          get name() {
            return "webtransport";
          }
          doOpen() {
            if (typeof WebTransport == "function") {
              this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
              this.transport.closed.then(() => {
                this.onClose();
              }).catch(e => {
                this.onError("webtransport error", e);
              });
              this.transport.ready.then(() => {
                this.transport.createBidirectionalStream().then(e => {
                  const t = function (e, t) {
                    Go ||= new TextDecoder();
                    const i = [];
                    let n = 0;
                    let a = -1;
                    let r = false;
                    return new TransformStream({
                      transform(s, o) {
                        for (i.push(s);;) {
                          if (n === 0) {
                            if (Wo(i) < 1) {
                              break;
                            }
                            const e = qo(i, 1);
                            r = !(~e[0] & 128);
                            a = e[0] & 127;
                            n = a < 126 ? 3 : a === 126 ? 1 : 2;
                          } else if (n === 1) {
                            if (Wo(i) < 2) {
                              break;
                            }
                            const e = qo(i, 2);
                            a = new DataView(e.buffer, e.byteOffset, e.length).getUint16(0);
                            n = 3;
                          } else if (n === 2) {
                            if (Wo(i) < 8) {
                              break;
                            }
                            const e = qo(i, 8);
                            const t = new DataView(e.buffer, e.byteOffset, e.length);
                            const r = t.getUint32(0);
                            if (r > Math.pow(2, 21) - 1) {
                              o.enqueue(Lo);
                              break;
                            }
                            a = r * Math.pow(2, 32) + t.getUint32(4);
                            n = 3;
                          } else {
                            if (Wo(i) < a) {
                              break;
                            }
                            const e = qo(i, a);
                            o.enqueue(Fo(r ? e : Go.decode(e), t));
                            n = 0;
                          }
                          if (a === 0 || a > e) {
                            o.enqueue(Lo);
                            break;
                          }
                        }
                      }
                    });
                  }(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
                  const i = e.readable.pipeThrough(t).getReader();
                  const n = new TransformStream({
                    transform(e, t) {
                      (function (e, t) {
                        if (Ro && e.data instanceof Blob) {
                          e.data.arrayBuffer().then(zo).then(t);
                        } else if (Po && (e.data instanceof ArrayBuffer || Do(e.data))) {
                          t(zo(e.data));
                        } else {
                          Io(e, false, e => {
                            No ||= new TextEncoder();
                            t(No.encode(e));
                          });
                        }
                      })(e, i => {
                        const n = i.length;
                        let a;
                        if (n < 126) {
                          a = new Uint8Array(1);
                          new DataView(a.buffer).setUint8(0, n);
                        } else if (n < 65536) {
                          a = new Uint8Array(3);
                          const e = new DataView(a.buffer);
                          e.setUint8(0, 126);
                          e.setUint16(1, n);
                        } else {
                          a = new Uint8Array(9);
                          const e = new DataView(a.buffer);
                          e.setUint8(0, 127);
                          e.setBigUint64(1, BigInt(n));
                        }
                        if (e.data && typeof e.data != "string") {
                          a[0] |= 128;
                        }
                        t.enqueue(a);
                        t.enqueue(i);
                      });
                    }
                  });
                  n.readable.pipeTo(e.writable);
                  this.writer = n.writable.getWriter();
                  const a = () => {
                    i.read().then(({
                      done: e,
                      value: t
                    }) => {
                      if (!e) {
                        this.onPacket(t);
                        a();
                      }
                    }).catch(e => {});
                  };
                  a();
                  const r = {
                    type: "open"
                  };
                  if (this.query.sid) {
                    r.data = `{"sid":"${this.query.sid}"}`;
                  }
                  this.writer.write(r).then(() => this.onOpen());
                });
              });
            }
          }
          write(e) {
            this.writable = false;
            for (let t = 0; t < e.length; t++) {
              const i = e[t];
              const n = t === e.length - 1;
              this.writer.write(i).then(() => {
                if (n) {
                  gl(() => {
                    this.writable = true;
                    this.emitReserved("drain");
                  }, this.setTimeoutFn);
                }
              });
            }
          }
          doClose() {
            var e;
            if ((e = this.transport) !== null && e !== undefined) {
              e.close();
            }
          }
        },
        polling: class extends el {
          constructor(e) {
            super(e);
            this.polling = false;
            if (typeof location != "undefined") {
              const t = location.protocol === "https:";
              let i = location.port;
              i ||= t ? "443" : "80";
              this.xd = typeof location != "undefined" && e.hostname !== location.hostname || i !== e.port;
            }
            const t = e && e.forceBase64;
            this.supportsBinary = pl && !t;
            if (this.opts.withCredentials) {
              this.cookieJar = undefined;
            }
          }
          get name() {
            return "polling";
          }
          doOpen() {
            this.poll();
          }
          pause(e) {
            this.readyState = "pausing";
            const t = () => {
              this.readyState = "paused";
              e();
            };
            if (this.polling || !this.writable) {
              let e = 0;
              if (this.polling) {
                e++;
                this.once("pollComplete", function () {
                  if (! --e) {
                    t();
                  }
                });
              }
              if (!this.writable) {
                e++;
                this.once("drain", function () {
                  if (! --e) {
                    t();
                  }
                });
              }
            } else {
              t();
            }
          }
          poll() {
            this.polling = true;
            this.doPoll();
            this.emitReserved("poll");
          }
          onData(e) {
            ((e, t) => {
              const i = e.split(Vo);
              const n = [];
              for (let e = 0; e < i.length; e++) {
                const a = Fo(i[e], t);
                n.push(a);
                if (a.type === "error") {
                  break;
                }
              }
              return n;
            })(e, this.socket.binaryType).forEach(e => {
              if (this.readyState === "opening" && e.type === "open") {
                this.onOpen();
              }
              if (e.type === "close") {
                this.onClose({
                  description: "transport closed by the server"
                });
                return false;
              }
              this.onPacket(e);
            });
            if (this.readyState !== "closed") {
              this.polling = false;
              this.emitReserved("pollComplete");
              if (this.readyState === "open") {
                this.poll();
              }
            }
          }
          doClose() {
            const e = () => {
              this.write([{
                type: "close"
              }]);
            };
            if (this.readyState === "open") {
              e();
            } else {
              this.once("open", e);
            }
          }
          write(e) {
            this.writable = false;
            ((e, t) => {
              const i = e.length;
              const n = new Array(i);
              let a = 0;
              e.forEach((e, r) => {
                Io(e, false, e => {
                  n[r] = e;
                  if (++a === i) {
                    t(n.join(Vo));
                  }
                });
              });
            })(e, e => {
              this.doWrite(e, () => {
                this.writable = true;
                this.emitReserved("drain");
              });
            });
          }
          uri() {
            const e = this.opts.secure ? "https" : "http";
            const t = this.query || {};
            if (this.opts.timestampRequests !== false) {
              t[this.opts.timestampParam] = ll();
            }
            if (!this.supportsBinary && !t.sid) {
              t.b64 = 1;
            }
            return this.createUri(e, t);
          }
          request(e = {}) {
            Object.assign(e, {
              xd: this.xd,
              cookieJar: this.cookieJar
            }, this.opts);
            return new ml(this.uri(), e);
          }
          doWrite(e, t) {
            const i = this.request({
              method: "POST",
              data: e
            });
            i.on("success", t);
            i.on("error", (e, t) => {
              this.onError("xhr post error", e, t);
            });
          }
          doPoll() {
            const e = this.request();
            e.on("data", this.onData.bind(this));
            e.on("error", (e, t) => {
              this.onError("xhr poll error", e, t);
            });
            this.pollXhr = e;
          }
        }
      };
      const yl = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      const xl = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
      function wl(e) {
        if (e.length > 2000) {
          throw "URI too long";
        }
        const t = e;
        const i = e.indexOf("[");
        const n = e.indexOf("]");
        if (i != -1 && n != -1) {
          e = e.substring(0, i) + e.substring(i, n).replace(/:/g, ";") + e.substring(n, e.length);
        }
        let a = yl.exec(e || "");
        let r = {};
        let s = 14;
        while (s--) {
          r[xl[s]] = a[s] || "";
        }
        if (i != -1 && n != -1) {
          r.source = t;
          r.host = r.host.substring(1, r.host.length - 1).replace(/;/g, ":");
          r.authority = r.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
          r.ipv6uri = true;
        }
        r.pathNames = function (e, t) {
          const i = t.replace(/\/{2,9}/g, "/").split("/");
          if (t.slice(0, 1) == "/" || t.length === 0) {
            i.splice(0, 1);
          }
          if (t.slice(-1) == "/") {
            i.splice(i.length - 1, 1);
          }
          return i;
        }(0, r.path);
        r.queryKey = function (e, t) {
          const i = {};
          t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (e, t, n) {
            if (t) {
              i[t] = n;
            }
          });
          return i;
        }(0, r.query);
        return r;
      }
      class Ml extends jo {
        constructor(e, t = {}) {
          super();
          this.binaryType = "arraybuffer";
          this.writeBuffer = [];
          if (e && typeof e == "object") {
            t = e;
            e = null;
          }
          if (e) {
            e = wl(e);
            t.hostname = e.host;
            t.secure = e.protocol === "https" || e.protocol === "wss";
            t.port = e.port;
            if (e.query) {
              t.query = e.query;
            }
          } else if (t.host) {
            t.hostname = wl(t.host).host;
          }
          Zo(this, t);
          this.secure = t.secure ?? (typeof location != "undefined" && location.protocol === "https:");
          if (t.hostname && !t.port) {
            t.port = this.secure ? "443" : "80";
          }
          this.hostname = t.hostname || (typeof location != "undefined" ? location.hostname : "localhost");
          this.port = t.port || (typeof location != "undefined" && location.port ? location.port : this.secure ? "443" : "80");
          this.transports = t.transports || ["polling", "websocket", "webtransport"];
          this.writeBuffer = [];
          this.prevBufferLen = 0;
          this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            timestampParam: "t",
            rememberUpgrade: false,
            addTrailingSlash: true,
            rejectUnauthorized: true,
            perMessageDeflate: {
              threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: false
          }, t);
          this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
          if (typeof this.opts.query == "string") {
            this.opts.query = function (e) {
              let t = {};
              let i = e.split("&");
              for (let e = 0, n = i.length; e < n; e++) {
                let n = i[e].split("=");
                t[decodeURIComponent(n[0])] = decodeURIComponent(n[1]);
              }
              return t;
            }(this.opts.query);
          }
          this.id = null;
          this.upgrades = null;
          this.pingInterval = null;
          this.pingTimeout = null;
          this.pingTimeoutTimer = null;
          if (typeof addEventListener == "function") {
            if (this.opts.closeOnBeforeunload) {
              this.beforeunloadEventListener = () => {
                if (this.transport) {
                  this.transport.removeAllListeners();
                  this.transport.close();
                }
              };
              addEventListener("beforeunload", this.beforeunloadEventListener, false);
            }
            if (this.hostname !== "localhost") {
              this.offlineEventListener = () => {
                this.onClose("transport close", {
                  description: "network connection lost"
                });
              };
              addEventListener("offline", this.offlineEventListener, false);
            }
          }
          this.open();
        }
        createTransport(e) {
          const t = Object.assign({}, this.opts.query);
          t.EIO = 4;
          t.transport = e;
          if (this.id) {
            t.sid = this.id;
          }
          const i = Object.assign({}, this.opts, {
            query: t,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
          }, this.opts.transportOptions[e]);
          return new bl[e](i);
        }
        open() {
          let e;
          if (this.opts.rememberUpgrade && Ml.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
            e = "websocket";
          } else {
            if (this.transports.length === 0) {
              this.setTimeoutFn(() => {
                this.emitReserved("error", "No transports available");
              }, 0);
              return;
            }
            e = this.transports[0];
          }
          this.readyState = "opening";
          try {
            e = this.createTransport(e);
          } catch (e) {
            this.transports.shift();
            this.open();
            return;
          }
          e.open();
          this.setTransport(e);
        }
        setTransport(e) {
          if (this.transport) {
            this.transport.removeAllListeners();
          }
          this.transport = e;
          e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", e => this.onClose("transport close", e));
        }
        probe(e) {
          let t = this.createTransport(e);
          let i = false;
          Ml.priorWebsocketSuccess = false;
          const n = () => {
            if (!i) {
              t.send([{
                type: "ping",
                data: "probe"
              }]);
              t.once("packet", e => {
                if (!i) {
                  if (e.type === "pong" && e.data === "probe") {
                    this.upgrading = true;
                    this.emitReserved("upgrading", t);
                    if (!t) {
                      return;
                    }
                    Ml.priorWebsocketSuccess = t.name === "websocket";
                    this.transport.pause(() => {
                      if (!i) {
                        if (this.readyState !== "closed") {
                          c();
                          this.setTransport(t);
                          t.send([{
                            type: "upgrade"
                          }]);
                          this.emitReserved("upgrade", t);
                          t = null;
                          this.upgrading = false;
                          this.flush();
                        }
                      }
                    });
                  } else {
                    const e = new Error("probe error");
                    e.transport = t.name;
                    this.emitReserved("upgradeError", e);
                  }
                }
              });
            }
          };
          function a() {
            if (!i) {
              i = true;
              c();
              t.close();
              t = null;
            }
          }
          const r = e => {
            const i = new Error("probe error: " + e);
            i.transport = t.name;
            a();
            this.emitReserved("upgradeError", i);
          };
          function s() {
            r("transport closed");
          }
          function o() {
            r("socket closed");
          }
          function l(e) {
            if (t && e.name !== t.name) {
              a();
            }
          }
          const c = () => {
            t.removeListener("open", n);
            t.removeListener("error", r);
            t.removeListener("close", s);
            this.off("close", o);
            this.off("upgrading", l);
          };
          t.once("open", n);
          t.once("error", r);
          t.once("close", s);
          this.once("close", o);
          this.once("upgrading", l);
          if (this.upgrades.indexOf("webtransport") !== -1 && e !== "webtransport") {
            this.setTimeoutFn(() => {
              if (!i) {
                t.open();
              }
            }, 200);
          } else {
            t.open();
          }
        }
        onOpen() {
          this.readyState = "open";
          Ml.priorWebsocketSuccess = this.transport.name === "websocket";
          this.emitReserved("open");
          this.flush();
          if (this.readyState === "open" && this.opts.upgrade) {
            let e = 0;
            const t = this.upgrades.length;
            for (; e < t; e++) {
              this.probe(this.upgrades[e]);
            }
          }
        }
        onPacket(e) {
          if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            this.emitReserved("packet", e);
            this.emitReserved("heartbeat");
            this.resetPingTimeout();
            switch (e.type) {
              case "open":
                this.onHandshake(JSON.parse(e.data));
                break;
              case "ping":
                this.sendPacket("pong");
                this.emitReserved("ping");
                this.emitReserved("pong");
                break;
              case "error":
                const t = new Error("server error");
                t.code = e.data;
                this.onError(t);
                break;
              case "message":
                this.emitReserved("data", e.data);
                this.emitReserved("message", e.data);
            }
          }
        }
        onHandshake(e) {
          this.emitReserved("handshake", e);
          this.id = e.sid;
          this.transport.query.sid = e.sid;
          this.upgrades = this.filterUpgrades(e.upgrades);
          this.pingInterval = e.pingInterval;
          this.pingTimeout = e.pingTimeout;
          this.maxPayload = e.maxPayload;
          this.onOpen();
          if (this.readyState !== "closed") {
            this.resetPingTimeout();
          }
        }
        resetPingTimeout() {
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
          }, this.pingInterval + this.pingTimeout);
          if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
          }
        }
        onDrain() {
          this.writeBuffer.splice(0, this.prevBufferLen);
          this.prevBufferLen = 0;
          if (this.writeBuffer.length === 0) {
            this.emitReserved("drain");
          } else {
            this.flush();
          }
        }
        flush() {
          if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            const e = this.getWritablePackets();
            this.transport.send(e);
            this.prevBufferLen = e.length;
            this.emitReserved("flush");
          }
        }
        getWritablePackets() {
          if (!this.maxPayload || this.transport.name !== "polling" || !(this.writeBuffer.length > 1)) {
            return this.writeBuffer;
          }
          let e = 1;
          for (let i = 0; i < this.writeBuffer.length; i++) {
            const n = this.writeBuffer[i].data;
            if (n) {
              e += typeof (t = n) == "string" ? function (e) {
                let t = 0;
                let i = 0;
                for (let n = 0, a = e.length; n < a; n++) {
                  t = e.charCodeAt(n);
                  if (t < 128) {
                    i += 1;
                  } else if (t < 2048) {
                    i += 2;
                  } else if (t < 55296 || t >= 57344) {
                    i += 3;
                  } else {
                    n++;
                    i += 4;
                  }
                }
                return i;
              }(t) : Math.ceil((t.byteLength || t.size) * 1.33);
            }
            if (i > 0 && e > this.maxPayload) {
              return this.writeBuffer.slice(0, i);
            }
            e += 2;
          }
          var t;
          return this.writeBuffer;
        }
        write(e, t, i) {
          this.sendPacket("message", e, t, i);
          return this;
        }
        send(e, t, i) {
          this.sendPacket("message", e, t, i);
          return this;
        }
        sendPacket(e, t, i, n) {
          if (typeof t == "function") {
            n = t;
            t = undefined;
          }
          if (typeof i == "function") {
            n = i;
            i = null;
          }
          if (this.readyState === "closing" || this.readyState === "closed") {
            return;
          }
          (i = i || {}).compress = i.compress !== false;
          const a = {
            type: e,
            data: t,
            options: i
          };
          this.emitReserved("packetCreate", a);
          this.writeBuffer.push(a);
          if (n) {
            this.once("flush", n);
          }
          this.flush();
        }
        close() {
          const e = () => {
            this.onClose("forced close");
            this.transport.close();
          };
          const t = () => {
            this.off("upgrade", t);
            this.off("upgradeError", t);
            e();
          };
          const i = () => {
            this.once("upgrade", t);
            this.once("upgradeError", t);
          };
          if (this.readyState === "opening" || this.readyState === "open") {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
              this.once("drain", () => {
                if (this.upgrading) {
                  i();
                } else {
                  e();
                }
              });
            } else if (this.upgrading) {
              i();
            } else {
              e();
            }
          }
          return this;
        }
        onError(e) {
          Ml.priorWebsocketSuccess = false;
          this.emitReserved("error", e);
          this.onClose("transport error", e);
        }
        onClose(e, t) {
          if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            this.clearTimeoutFn(this.pingTimeoutTimer);
            this.transport.removeAllListeners("close");
            this.transport.close();
            this.transport.removeAllListeners();
            if (typeof removeEventListener == "function") {
              removeEventListener("beforeunload", this.beforeunloadEventListener, false);
              removeEventListener("offline", this.offlineEventListener, false);
            }
            this.readyState = "closed";
            this.id = null;
            this.emitReserved("close", e, t);
            this.writeBuffer = [];
            this.prevBufferLen = 0;
          }
        }
        filterUpgrades(e) {
          const t = [];
          let i = 0;
          const n = e.length;
          for (; i < n; i++) {
            if (~this.transports.indexOf(e[i])) {
              t.push(e[i]);
            }
          }
          return t;
        }
      }
      Ml.protocol = 4;
      Ml.protocol;
      const Sl = typeof ArrayBuffer == "function";
      const El = e => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer;
      const Tl = Object.prototype.toString;
      const Cl = typeof Blob == "function" || typeof Blob != "undefined" && Tl.call(Blob) === "[object BlobConstructor]";
      const kl = typeof File == "function" || typeof File != "undefined" && Tl.call(File) === "[object FileConstructor]";
      function Al(e) {
        return Sl && (e instanceof ArrayBuffer || El(e)) || Cl && e instanceof Blob || kl && e instanceof File;
      }
      function Ll(e, t) {
        if (!e || typeof e != "object") {
          return false;
        }
        if (Array.isArray(e)) {
          for (let t = 0, i = e.length; t < i; t++) {
            if (Ll(e[t])) {
              return true;
            }
          }
          return false;
        }
        if (Al(e)) {
          return true;
        }
        if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1) {
          return Ll(e.toJSON(), true);
        }
        for (const t in e) {
          if (Object.prototype.hasOwnProperty.call(e, t) && Ll(e[t])) {
            return true;
          }
        }
        return false;
      }
      function Rl(e) {
        const t = [];
        const i = e.data;
        const n = e;
        n.data = Pl(i, t);
        n.attachments = t.length;
        return {
          packet: n,
          buffers: t
        };
      }
      function Pl(e, t) {
        if (!e) {
          return e;
        }
        if (Al(e)) {
          const i = {
            _placeholder: true,
            num: t.length
          };
          t.push(e);
          return i;
        }
        if (Array.isArray(e)) {
          const i = new Array(e.length);
          for (let n = 0; n < e.length; n++) {
            i[n] = Pl(e[n], t);
          }
          return i;
        }
        if (typeof e == "object" && !(e instanceof Date)) {
          const i = {};
          for (const n in e) {
            if (Object.prototype.hasOwnProperty.call(e, n)) {
              i[n] = Pl(e[n], t);
            }
          }
          return i;
        }
        return e;
      }
      function Dl(e, t) {
        e.data = Il(e.data, t);
        delete e.attachments;
        return e;
      }
      function Il(e, t) {
        if (!e) {
          return e;
        }
        if (e && e._placeholder === true) {
          if (typeof e.num == "number" && e.num >= 0 && e.num < t.length) {
            return t[e.num];
          }
          throw new Error("illegal attachments");
        }
        if (Array.isArray(e)) {
          for (let i = 0; i < e.length; i++) {
            e[i] = Il(e[i], t);
          }
        } else if (typeof e == "object") {
          for (const i in e) {
            if (Object.prototype.hasOwnProperty.call(e, i)) {
              e[i] = Il(e[i], t);
            }
          }
        }
        return e;
      }
      const $l = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"];
      const zl = 5;
      var Nl;
      (function (e) {
        e[e.CONNECT = 0] = "CONNECT";
        e[e.DISCONNECT = 1] = "DISCONNECT";
        e[e.EVENT = 2] = "EVENT";
        e[e.ACK = 3] = "ACK";
        e[e.CONNECT_ERROR = 4] = "CONNECT_ERROR";
        e[e.BINARY_EVENT = 5] = "BINARY_EVENT";
        e[e.BINARY_ACK = 6] = "BINARY_ACK";
      })(Nl ||= {});
      class Ol {
        constructor(e) {
          this.replacer = e;
        }
        encode(e) {
          if (e.type !== Nl.EVENT && e.type !== Nl.ACK || !Ll(e)) {
            return [this.encodeAsString(e)];
          } else {
            return this.encodeAsBinary({
              type: e.type === Nl.EVENT ? Nl.BINARY_EVENT : Nl.BINARY_ACK,
              nsp: e.nsp,
              data: e.data,
              id: e.id
            });
          }
        }
        encodeAsString(e) {
          let t = "" + e.type;
          if (e.type === Nl.BINARY_EVENT || e.type === Nl.BINARY_ACK) {
            t += e.attachments + "-";
          }
          if (e.nsp && e.nsp !== "/") {
            t += e.nsp + ",";
          }
          if (e.id != null) {
            t += e.id;
          }
          if (e.data != null) {
            t += JSON.stringify(e.data, this.replacer);
          }
          return t;
        }
        encodeAsBinary(e) {
          const t = Rl(e);
          const i = this.encodeAsString(t.packet);
          const n = t.buffers;
          n.unshift(i);
          return n;
        }
      }
      function Ul(e) {
        return Object.prototype.toString.call(e) === "[object Object]";
      }
      class Fl extends jo {
        constructor(e) {
          super();
          this.reviver = e;
        }
        add(e) {
          let t;
          if (typeof e == "string") {
            if (this.reconstructor) {
              throw new Error("got plaintext data when reconstructing a packet");
            }
            t = this.decodeString(e);
            const i = t.type === Nl.BINARY_EVENT;
            if (i || t.type === Nl.BINARY_ACK) {
              t.type = i ? Nl.EVENT : Nl.ACK;
              this.reconstructor = new Bl(t);
              if (t.attachments === 0) {
                super.emitReserved("decoded", t);
              }
            } else {
              super.emitReserved("decoded", t);
            }
          } else {
            if (!Al(e) && !e.base64) {
              throw new Error("Unknown type: " + e);
            }
            if (!this.reconstructor) {
              throw new Error("got binary data when not reconstructing a packet");
            }
            t = this.reconstructor.takeBinaryData(e);
            if (t) {
              this.reconstructor = null;
              super.emitReserved("decoded", t);
            }
          }
        }
        decodeString(e) {
          let t = 0;
          const i = {
            type: Number(e.charAt(0))
          };
          if (Nl[i.type] === undefined) {
            throw new Error("unknown packet type " + i.type);
          }
          if (i.type === Nl.BINARY_EVENT || i.type === Nl.BINARY_ACK) {
            const n = t + 1;
            while (e.charAt(++t) !== "-" && t != e.length);
            const a = e.substring(n, t);
            if (a != Number(a) || e.charAt(t) !== "-") {
              throw new Error("Illegal attachments");
            }
            i.attachments = Number(a);
          }
          if (e.charAt(t + 1) === "/") {
            const n = t + 1;
            while (++t && e.charAt(t) !== "," && t !== e.length);
            i.nsp = e.substring(n, t);
          } else {
            i.nsp = "/";
          }
          const n = e.charAt(t + 1);
          if (n !== "" && Number(n) == n) {
            const n = t + 1;
            while (++t) {
              const i = e.charAt(t);
              if (i == null || Number(i) != i) {
                --t;
                break;
              }
              if (t === e.length) {
                break;
              }
            }
            i.id = Number(e.substring(n, t + 1));
          }
          if (e.charAt(++t)) {
            const n = this.tryParse(e.substr(t));
            if (!Fl.isPayloadValid(i.type, n)) {
              throw new Error("invalid payload");
            }
            i.data = n;
          }
          return i;
        }
        tryParse(e) {
          try {
            return JSON.parse(e, this.reviver);
          } catch (e) {
            return false;
          }
        }
        static isPayloadValid(e, t) {
          switch (e) {
            case Nl.CONNECT:
              return Ul(t);
            case Nl.DISCONNECT:
              return t === undefined;
            case Nl.CONNECT_ERROR:
              return typeof t == "string" || Ul(t);
            case Nl.EVENT:
            case Nl.BINARY_EVENT:
              return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && $l.indexOf(t[0]) === -1);
            case Nl.ACK:
            case Nl.BINARY_ACK:
              return Array.isArray(t);
          }
        }
        destroy() {
          if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
            this.reconstructor = null;
          }
        }
      }
      class Bl {
        constructor(e) {
          this.packet = e;
          this.buffers = [];
          this.reconPack = e;
        }
        takeBinaryData(e) {
          this.buffers.push(e);
          if (this.buffers.length === this.reconPack.attachments) {
            const e = Dl(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return e;
          }
          return null;
        }
        finishedReconstruction() {
          this.reconPack = null;
          this.buffers = [];
        }
      }
      function Hl(e, t, i) {
        e.on(t, i);
        return function () {
          e.off(t, i);
        };
      }
      const Vl = Object.freeze({
        connect: 1,
        connect_error: 1,
        disconnect: 1,
        disconnecting: 1,
        newListener: 1,
        removeListener: 1
      });
      class Gl extends jo {
        constructor(e, t, i) {
          super();
          this.connected = false;
          this.recovered = false;
          this.receiveBuffer = [];
          this.sendBuffer = [];
          this._queue = [];
          this._queueSeq = 0;
          this.ids = 0;
          this.acks = {};
          this.flags = {};
          this.io = e;
          this.nsp = t;
          if (i && i.auth) {
            this.auth = i.auth;
          }
          this._opts = Object.assign({}, i);
          if (this.io._autoConnect) {
            this.open();
          }
        }
        get disconnected() {
          return !this.connected;
        }
        subEvents() {
          if (this.subs) {
            return;
          }
          const e = this.io;
          this.subs = [Hl(e, "open", this.onopen.bind(this)), Hl(e, "packet", this.onpacket.bind(this)), Hl(e, "error", this.onerror.bind(this)), Hl(e, "close", this.onclose.bind(this))];
        }
        get active() {
          return !!this.subs;
        }
        connect() {
          if (!this.connected) {
            this.subEvents();
            if (!this.io._reconnecting) {
              this.io.open();
            }
            if (this.io._readyState === "open") {
              this.onopen();
            }
          }
          return this;
        }
        open() {
          return this.connect();
        }
        send(...e) {
          e.unshift("message");
          this.emit.apply(this, e);
          return this;
        }
        emit(e, ...t) {
          if (Vl.hasOwnProperty(e)) {
            throw new Error("\"" + e.toString() + "\" is a reserved event name");
          }
          t.unshift(e);
          if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
            this._addToQueue(t);
            return this;
          }
          const i = {
            type: Nl.EVENT,
            data: t,
            options: {}
          };
          i.options.compress = this.flags.compress !== false;
          if (typeof t[t.length - 1] == "function") {
            const e = this.ids++;
            const n = t.pop();
            this._registerAckCallback(e, n);
            i.id = e;
          }
          const n = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
          if (!this.flags.volatile || !!n && !!this.connected) {
            if (this.connected) {
              this.notifyOutgoingListeners(i);
              this.packet(i);
            } else {
              this.sendBuffer.push(i);
            }
          }
          this.flags = {};
          return this;
        }
        _registerAckCallback(e, t) {
          const n = this.flags.timeout ?? this._opts.ackTimeout;
          if (n === undefined) {
            this.acks[e] = t;
            return;
          }
          const a = this.io.setTimeoutFn(() => {
            delete this.acks[e];
            for (let t = 0; t < this.sendBuffer.length; t++) {
              if (this.sendBuffer[t].id === e) {
                this.sendBuffer.splice(t, 1);
              }
            }
            t.call(this, new Error("operation has timed out"));
          }, n);
          const r = (...e) => {
            this.io.clearTimeoutFn(a);
            t.apply(this, e);
          };
          r.withError = true;
          this.acks[e] = r;
        }
        emitWithAck(e, ...t) {
          return new Promise((i, n) => {
            const a = (e, t) => e ? n(e) : i(t);
            a.withError = true;
            t.push(a);
            this.emit(e, ...t);
          });
        }
        _addToQueue(e) {
          let t;
          if (typeof e[e.length - 1] == "function") {
            t = e.pop();
          }
          const i = {
            id: this._queueSeq++,
            tryCount: 0,
            pending: false,
            args: e,
            flags: Object.assign({
              fromQueue: true
            }, this.flags)
          };
          e.push((e, ...n) => {
            if (i === this._queue[0]) {
              if (e !== null) {
                if (i.tryCount > this._opts.retries) {
                  this._queue.shift();
                  if (t) {
                    t(e);
                  }
                }
              } else {
                this._queue.shift();
                if (t) {
                  t(null, ...n);
                }
              }
              i.pending = false;
              return this._drainQueue();
            }
          });
          this._queue.push(i);
          this._drainQueue();
        }
        _drainQueue(e = false) {
          if (!this.connected || this._queue.length === 0) {
            return;
          }
          const t = this._queue[0];
          if (!t.pending || !!e) {
            t.pending = true;
            t.tryCount++;
            this.flags = t.flags;
            this.emit.apply(this, t.args);
          }
        }
        packet(e) {
          e.nsp = this.nsp;
          this.io._packet(e);
        }
        onopen() {
          if (typeof this.auth == "function") {
            this.auth(e => {
              this._sendConnectPacket(e);
            });
          } else {
            this._sendConnectPacket(this.auth);
          }
        }
        _sendConnectPacket(e) {
          this.packet({
            type: Nl.CONNECT,
            data: this._pid ? Object.assign({
              pid: this._pid,
              offset: this._lastOffset
            }, e) : e
          });
        }
        onerror(e) {
          if (!this.connected) {
            this.emitReserved("connect_error", e);
          }
        }
        onclose(e, t) {
          this.connected = false;
          delete this.id;
          this.emitReserved("disconnect", e, t);
          this._clearAcks();
        }
        _clearAcks() {
          Object.keys(this.acks).forEach(e => {
            if (!this.sendBuffer.some(t => String(t.id) === e)) {
              const t = this.acks[e];
              delete this.acks[e];
              if (t.withError) {
                t.call(this, new Error("socket has been disconnected"));
              }
            }
          });
        }
        onpacket(e) {
          if (e.nsp === this.nsp) {
            switch (e.type) {
              case Nl.CONNECT:
                if (e.data && e.data.sid) {
                  this.onconnect(e.data.sid, e.data.pid);
                } else {
                  this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
                }
                break;
              case Nl.EVENT:
              case Nl.BINARY_EVENT:
                this.onevent(e);
                break;
              case Nl.ACK:
              case Nl.BINARY_ACK:
                this.onack(e);
                break;
              case Nl.DISCONNECT:
                this.ondisconnect();
                break;
              case Nl.CONNECT_ERROR:
                this.destroy();
                const t = new Error(e.data.message);
                t.data = e.data.data;
                this.emitReserved("connect_error", t);
            }
          }
        }
        onevent(e) {
          const t = e.data || [];
          if (e.id != null) {
            t.push(this.ack(e.id));
          }
          if (this.connected) {
            this.emitEvent(t);
          } else {
            this.receiveBuffer.push(Object.freeze(t));
          }
        }
        emitEvent(e) {
          if (this._anyListeners && this._anyListeners.length) {
            const t = this._anyListeners.slice();
            for (const i of t) {
              i.apply(this, e);
            }
          }
          super.emit.apply(this, e);
          if (this._pid && e.length && typeof e[e.length - 1] == "string") {
            this._lastOffset = e[e.length - 1];
          }
        }
        ack(e) {
          const t = this;
          let i = false;
          return function (...n) {
            if (!i) {
              i = true;
              t.packet({
                type: Nl.ACK,
                id: e,
                data: n
              });
            }
          };
        }
        onack(e) {
          const t = this.acks[e.id];
          if (typeof t == "function") {
            delete this.acks[e.id];
            if (t.withError) {
              e.data.unshift(null);
            }
            t.apply(this, e.data);
          }
        }
        onconnect(e, t) {
          this.id = e;
          this.recovered = t && this._pid === t;
          this._pid = t;
          this.connected = true;
          this.emitBuffered();
          this.emitReserved("connect");
          this._drainQueue(true);
        }
        emitBuffered() {
          this.receiveBuffer.forEach(e => this.emitEvent(e));
          this.receiveBuffer = [];
          this.sendBuffer.forEach(e => {
            this.notifyOutgoingListeners(e);
            this.packet(e);
          });
          this.sendBuffer = [];
        }
        ondisconnect() {
          this.destroy();
          this.onclose("io server disconnect");
        }
        destroy() {
          if (this.subs) {
            this.subs.forEach(e => e());
            this.subs = undefined;
          }
          this.io._destroy(this);
        }
        disconnect() {
          if (this.connected) {
            this.packet({
              type: Nl.DISCONNECT
            });
          }
          this.destroy();
          if (this.connected) {
            this.onclose("io client disconnect");
          }
          return this;
        }
        close() {
          return this.disconnect();
        }
        compress(e) {
          this.flags.compress = e;
          return this;
        }
        get volatile() {
          this.flags.volatile = true;
          return this;
        }
        timeout(e) {
          this.flags.timeout = e;
          return this;
        }
        onAny(e) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.push(e);
          return this;
        }
        prependAny(e) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.unshift(e);
          return this;
        }
        offAny(e) {
          if (!this._anyListeners) {
            return this;
          }
          if (e) {
            const t = this._anyListeners;
            for (let i = 0; i < t.length; i++) {
              if (e === t[i]) {
                t.splice(i, 1);
                return this;
              }
            }
          } else {
            this._anyListeners = [];
          }
          return this;
        }
        listenersAny() {
          return this._anyListeners || [];
        }
        onAnyOutgoing(e) {
          this._anyOutgoingListeners = this._anyOutgoingListeners || [];
          this._anyOutgoingListeners.push(e);
          return this;
        }
        prependAnyOutgoing(e) {
          this._anyOutgoingListeners = this._anyOutgoingListeners || [];
          this._anyOutgoingListeners.unshift(e);
          return this;
        }
        offAnyOutgoing(e) {
          if (!this._anyOutgoingListeners) {
            return this;
          }
          if (e) {
            const t = this._anyOutgoingListeners;
            for (let i = 0; i < t.length; i++) {
              if (e === t[i]) {
                t.splice(i, 1);
                return this;
              }
            }
          } else {
            this._anyOutgoingListeners = [];
          }
          return this;
        }
        listenersAnyOutgoing() {
          return this._anyOutgoingListeners || [];
        }
        notifyOutgoingListeners(e) {
          if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
            const t = this._anyOutgoingListeners.slice();
            for (const i of t) {
              i.apply(this, e.data);
            }
          }
        }
      }
      function Wl(e) {
        e = e || {};
        this.ms = e.min || 100;
        this.max = e.max || 10000;
        this.factor = e.factor || 2;
        this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0;
        this.attempts = 0;
      }
      Wl.prototype.duration = function () {
        var e = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var t = Math.random();
          var i = Math.floor(t * this.jitter * e);
          e = Math.floor(t * 10) & 1 ? e + i : e - i;
        }
        return Math.min(e, this.max) | 0;
      };
      Wl.prototype.reset = function () {
        this.attempts = 0;
      };
      Wl.prototype.setMin = function (e) {
        this.ms = e;
      };
      Wl.prototype.setMax = function (e) {
        this.max = e;
      };
      Wl.prototype.setJitter = function (e) {
        this.jitter = e;
      };
      class ql extends jo {
        constructor(t, i) {
          super();
          this.nsps = {};
          this.subs = [];
          if (t && typeof t == "object") {
            i = t;
            t = undefined;
          }
          (i = i || {}).path = i.path || "/socket.io";
          this.opts = i;
          Zo(this, i);
          this.reconnection(i.reconnection !== false);
          this.reconnectionAttempts(i.reconnectionAttempts || Infinity);
          this.reconnectionDelay(i.reconnectionDelay || 1000);
          this.reconnectionDelayMax(i.reconnectionDelayMax || 5000);
          this.randomizationFactor(i.randomizationFactor ?? 0.5);
          this.backoff = new Wl({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          });
          this.timeout(i.timeout == null ? 20000 : i.timeout);
          this._readyState = "closed";
          this.uri = t;
          const a = i.parser || e;
          this.encoder = new a.Encoder();
          this.decoder = new a.Decoder();
          this._autoConnect = i.autoConnect !== false;
          if (this._autoConnect) {
            this.open();
          }
        }
        reconnection(e) {
          if (arguments.length) {
            this._reconnection = !!e;
            return this;
          } else {
            return this._reconnection;
          }
        }
        reconnectionAttempts(e) {
          if (e === undefined) {
            return this._reconnectionAttempts;
          } else {
            this._reconnectionAttempts = e;
            return this;
          }
        }
        reconnectionDelay(e) {
          var t;
          if (e === undefined) {
            return this._reconnectionDelay;
          } else {
            this._reconnectionDelay = e;
            if ((t = this.backoff) !== null && t !== undefined) {
              t.setMin(e);
            }
            return this;
          }
        }
        randomizationFactor(e) {
          var t;
          if (e === undefined) {
            return this._randomizationFactor;
          } else {
            this._randomizationFactor = e;
            if ((t = this.backoff) !== null && t !== undefined) {
              t.setJitter(e);
            }
            return this;
          }
        }
        reconnectionDelayMax(e) {
          var t;
          if (e === undefined) {
            return this._reconnectionDelayMax;
          } else {
            this._reconnectionDelayMax = e;
            if ((t = this.backoff) !== null && t !== undefined) {
              t.setMax(e);
            }
            return this;
          }
        }
        timeout(e) {
          if (arguments.length) {
            this._timeout = e;
            return this;
          } else {
            return this._timeout;
          }
        }
        maybeReconnectOnOpen() {
          if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
            this.reconnect();
          }
        }
        open(e) {
          if (~this._readyState.indexOf("open")) {
            return this;
          }
          this.engine = new Ml(this.uri, this.opts);
          const t = this.engine;
          const i = this;
          this._readyState = "opening";
          this.skipReconnect = false;
          const n = Hl(t, "open", function () {
            i.onopen();
            if (e) {
              e();
            }
          });
          const a = t => {
            this.cleanup();
            this._readyState = "closed";
            this.emitReserved("error", t);
            if (e) {
              e(t);
            } else {
              this.maybeReconnectOnOpen();
            }
          };
          const r = Hl(t, "error", a);
          if (this._timeout !== false) {
            const e = this._timeout;
            const i = this.setTimeoutFn(() => {
              n();
              a(new Error("timeout"));
              t.close();
            }, e);
            if (this.opts.autoUnref) {
              i.unref();
            }
            this.subs.push(() => {
              this.clearTimeoutFn(i);
            });
          }
          this.subs.push(n);
          this.subs.push(r);
          return this;
        }
        connect(e) {
          return this.open(e);
        }
        onopen() {
          this.cleanup();
          this._readyState = "open";
          this.emitReserved("open");
          const e = this.engine;
          this.subs.push(Hl(e, "ping", this.onping.bind(this)), Hl(e, "data", this.ondata.bind(this)), Hl(e, "error", this.onerror.bind(this)), Hl(e, "close", this.onclose.bind(this)), Hl(this.decoder, "decoded", this.ondecoded.bind(this)));
        }
        onping() {
          this.emitReserved("ping");
        }
        ondata(e) {
          try {
            this.decoder.add(e);
          } catch (e) {
            this.onclose("parse error", e);
          }
        }
        ondecoded(e) {
          gl(() => {
            this.emitReserved("packet", e);
          }, this.setTimeoutFn);
        }
        onerror(e) {
          this.emitReserved("error", e);
        }
        socket(e, t) {
          let i = this.nsps[e];
          if (i) {
            if (this._autoConnect && !i.active) {
              i.connect();
            }
          } else {
            i = new Gl(this, e, t);
            this.nsps[e] = i;
          }
          return i;
        }
        _destroy(e) {
          const t = Object.keys(this.nsps);
          for (const e of t) {
            if (this.nsps[e].active) {
              return;
            }
          }
          this._close();
        }
        _packet(e) {
          const t = this.encoder.encode(e);
          for (let i = 0; i < t.length; i++) {
            this.engine.write(t[i], e.options);
          }
        }
        cleanup() {
          this.subs.forEach(e => e());
          this.subs.length = 0;
          this.decoder.destroy();
        }
        _close() {
          this.skipReconnect = true;
          this._reconnecting = false;
          this.onclose("forced close");
          if (this.engine) {
            this.engine.close();
          }
        }
        disconnect() {
          return this._close();
        }
        onclose(e, t) {
          this.cleanup();
          this.backoff.reset();
          this._readyState = "closed";
          this.emitReserved("close", e, t);
          if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
          }
        }
        reconnect() {
          if (this._reconnecting || this.skipReconnect) {
            return this;
          }
          const e = this;
          if (this.backoff.attempts >= this._reconnectionAttempts) {
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
          } else {
            const t = this.backoff.duration();
            this._reconnecting = true;
            const i = this.setTimeoutFn(() => {
              if (!e.skipReconnect) {
                this.emitReserved("reconnect_attempt", e.backoff.attempts);
                if (!e.skipReconnect) {
                  e.open(t => {
                    if (t) {
                      e._reconnecting = false;
                      e.reconnect();
                      this.emitReserved("reconnect_error", t);
                    } else {
                      e.onreconnect();
                    }
                  });
                }
              }
            }, t);
            if (this.opts.autoUnref) {
              i.unref();
            }
            this.subs.push(() => {
              this.clearTimeoutFn(i);
            });
          }
        }
        onreconnect() {
          const e = this.backoff.attempts;
          this._reconnecting = false;
          this.backoff.reset();
          this.emitReserved("reconnect", e);
        }
      }
      const jl = {};
      function Xl(e, t) {
        if (typeof e == "object") {
          t = e;
          e = undefined;
        }
        const i = function (e, t = "", i) {
          let n = e;
          i = i || typeof location != "undefined" && location;
          if (e == null) {
            e = i.protocol + "//" + i.host;
          }
          if (typeof e == "string") {
            if (e.charAt(0) === "/") {
              e = e.charAt(1) === "/" ? i.protocol + e : i.host + e;
            }
            if (!/^(https?|wss?):\/\//.test(e)) {
              e = i !== undefined ? i.protocol + "//" + e : "https://" + e;
            }
            n = wl(e);
          }
          if (!n.port) {
            if (/^(http|ws)$/.test(n.protocol)) {
              n.port = "80";
            } else if (/^(http|ws)s$/.test(n.protocol)) {
              n.port = "443";
            }
          }
          n.path = n.path || "/";
          const a = n.host.indexOf(":") !== -1 ? "[" + n.host + "]" : n.host;
          n.id = n.protocol + "://" + a + ":" + n.port + t;
          n.href = n.protocol + "://" + a + (i && i.port === n.port ? "" : ":" + n.port);
          return n;
        }(e, (t = t || {}).path || "/socket.io");
        const n = i.source;
        const a = i.id;
        const r = i.path;
        const s = jl[a] && r in jl[a].nsps;
        let o;
        if (t.forceNew || t["force new connection"] || t.multiplex === false || s) {
          o = new ql(n, t);
        } else {
          jl[a] ||= new ql(n, t);
          o = jl[a];
        }
        if (i.query && !t.query) {
          t.query = i.queryKey;
        }
        return o.socket(i.path, t);
      }
      Object.assign(Xl, {
        Manager: ql,
        Socket: Gl,
        io: Xl,
        connect: Xl
      });
      var Kl = a(129);
      var Yl = a.t(Kl, 2);
      const Jl = {
        Devs: ["ITSDABOMB", "RussianMope", "devclied", "theweewee"],
        Admins: ["ITSDABOMB", "RussianMope", "devclied", "Best1111", "PotatoPrem", "Speedy_Sloth", "DaRkHaCkEr7777"],
        Mods: ["Nitrogen", "Yabot28", "BlackHour"],
        Helpers: ["SINKERF", "Duckioboi", "Fiftyyyyy", "HuronAlbino", "GLORY.exe", "hatchi"],
        url: "https://krew.io",
        version: "1.40.1",
        worldsize: 2200,
        christmasTree: [],
        snowman: [],
        emojiRegex: /:([^:\s]+):/g,
        isTesting: true,
        setProperties: {
          inVision: false
        },
        Labels: {
          redrawInterval: 250,
          fontFamily: "Arial, Helvetica, sans-serif",
          distanceMultiplier: {
            0: 40,
            1: 160,
            5: 300
          },
          boats: {
            useMethod: "inRange"
          }
        }
      };
      const Zl = {
        0: {
          id: 0,
          image: "<img src=\"/assets/img/ships/raft.png\" style=\"height: 30px\">",
          name: "Raft",
          hp: 100,
          turnspeed: 1.2,
          price: 500,
          maxKrewCapacity: 3,
          cargoSize: 250,
          baseheight: 1.6,
          width: 4.4,
          depth: 6.05,
          arcFront: 0,
          arcBack: 0,
          inertia: 0.1,
          radius: 5,
          speed: 7.2,
          labelHeight: 8,
          regeneration: 1,
          body: "raft",
          sail: "raft",
          mast: "raft",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Jamaica", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        1: {
          id: 1,
          image: "<img src=\"/assets/img/ships/boat.png\" style=\"height: 30px\">",
          name: "Boat 1",
          hp: 850,
          turnspeed: 0.7,
          price: 2500,
          maxKrewCapacity: 5,
          cargoSize: 500,
          baseheight: 3,
          width: 5.7,
          depth: 13.4,
          arcFront: 0.21,
          arcBack: 0.02,
          inertia: 0.5,
          radius: 10,
          speed: 6.5,
          labelHeight: 13,
          regeneration: 3,
          armor: 15,
          specialInfo: "This ship has a 15% armor bonus.",
          body: "boat",
          sail: "boat",
          mast: "boat",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        2: {
          id: 2,
          image: "<img src=\"/assets/img/ships/boat.png\" style=\"height: 35px\">",
          name: "Boat 2",
          hp: 1050,
          turnspeed: 0.7,
          price: 7000,
          maxKrewCapacity: 6,
          cargoSize: 600,
          baseheight: 3,
          width: 6.9,
          depth: 20,
          arcFront: 0.21,
          arcBack: 0.02,
          inertia: 0.5,
          radius: 10,
          speed: 6.5,
          labelHeight: 15,
          regeneration: 3,
          armor: 15,
          specialInfo: "This ship has a 15% armor bonus.",
          body: "boat2",
          sail: "boat2",
          mast: "boat2",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        3: {
          id: 3,
          image: "<img src=\"/assets/img/ships/boat.png\" style=\"height: 40px\">",
          name: "Boat 3",
          hp: 1250,
          turnspeed: 0.7,
          price: 16000,
          maxKrewCapacity: 7,
          cargoSize: 700,
          baseheight: 3,
          width: 8.7,
          depth: 25,
          arcFront: 0.18,
          arcBack: 0.03,
          inertia: 0.5,
          radius: 10,
          speed: 6.6,
          labelHeight: 15,
          regeneration: 4,
          armor: 15,
          specialInfo: "This ship has a 15% armor bonus.",
          body: "boat3",
          sail: "boat3",
          mast: "boat3",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        4: {
          id: 4,
          image: "<img src=\"/assets/img/ships/trader.png\" style=\"height: 30px\">",
          name: "Trader 1",
          hp: 800,
          turnspeed: 0.7,
          price: 4350,
          maxKrewCapacity: 4,
          cargoSize: 2000,
          baseheight: 3,
          width: 7,
          depth: 17.3,
          arcFront: 0.2,
          arcBack: 0,
          inertia: 0.5,
          radius: 10,
          speed: 5.3,
          labelHeight: 12,
          regeneration: 2,
          body: "trader",
          sail: "trader",
          mast: "trader",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        5: {
          id: 5,
          image: "<img src=\"/assets/img/ships/trader.png\" style=\"height: 35px\">",
          name: "Trader 2",
          hp: 1000,
          turnspeed: 0.7,
          price: 18000,
          maxKrewCapacity: 6,
          cargoSize: 4000,
          baseheight: 3,
          width: 7.3,
          depth: 19.2,
          arcFront: 0.2,
          arcBack: 0,
          inertia: 0.5,
          radius: 10,
          speed: 5.2,
          labelHeight: 13,
          regeneration: 2,
          body: "trader2",
          sail: "trader2",
          mast: "trader2",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        6: {
          id: 6,
          image: "<img src=\"/assets/img/ships/trader.png\" style=\"height: 40px\">",
          name: "Trader 3",
          hp: 1200,
          turnspeed: 0.7,
          price: 45000,
          maxKrewCapacity: 6,
          cargoSize: 6000,
          baseheight: 3,
          width: 8.8,
          depth: 21.2,
          arcFront: 0.2,
          arcBack: 0.03,
          inertia: 0.5,
          radius: 10,
          speed: 5.1,
          labelHeight: 15,
          regeneration: 2,
          body: "trader3",
          sail: "trader3",
          mast: "trader3",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica"]
        },
        7: {
          id: 7,
          image: "<img src=\"/assets/img/ships/destroyer.png\" style=\"height: 35px\">",
          name: "Destroyer 1",
          hp: 2600,
          turnspeed: 0.7,
          price: 60000,
          maxKrewCapacity: 12,
          cargoSize: 1000,
          baseheight: 5,
          width: 9,
          depth: 22,
          arcFront: 0.2,
          arcBack: 0.1,
          inertia: 1,
          radius: 15,
          speed: 6.5,
          labelHeight: 15,
          regeneration: 2,
          damageBoost: 0.25,
          specialInfo: "This ship increases your damage as health decreases, up to maximum of 25% damage increase.",
          body: "destroyer",
          sail: "destroyer",
          mast: "destroyer",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        8: {
          id: 8,
          image: "<img src=\"/assets/img/ships/destroyer.png\" style=\"height: 40px\">",
          name: "Destroyer 2",
          hp: 3000,
          turnspeed: 0.7,
          price: 100000,
          maxKrewCapacity: 15,
          cargoSize: 1000,
          baseheight: 5,
          width: 11.5,
          depth: 25.3,
          arcFront: 0.23,
          arcBack: 0.1,
          inertia: 1,
          radius: 15,
          speed: 6.5,
          labelHeight: 15,
          regeneration: 2,
          damageBoost: 0.25,
          specialInfo: "This ship increases your damage as health decreases, up to maximum of 25% damage increase.",
          body: "destroyer2",
          sail: "destroyer2",
          mast: "destroyer2",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Guinea", "Jamaica", "Labrador", "Brazil", "Cuba", "Malaysia"]
        },
        9: {
          id: 9,
          image: "<img src=\"/assets/img/ships/babyFancy.png\" style=\"height: 35px\">",
          name: "Baby Fancy",
          hp: 300,
          turnspeed: 1.2,
          price: 20000,
          maxKrewCapacity: 3,
          cargoSize: 600,
          baseheight: 1.4,
          width: 4.4,
          depth: 9.35,
          arcFront: 0.3,
          arcBack: 0.1,
          inertia: 0.1,
          radius: 8.5,
          speed: 7.2,
          labelHeight: 15,
          regeneration: 2,
          body: "babyFancy",
          sail: "babyFancy",
          mast: "babyFancy",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain", "Brazil", "Jamaica"]
        },
        10: {
          id: 10,
          image: "<img src=\"/assets/img/ships/silentDragon.png\" style=\"height: 40px\">",
          name: "Silent Dragon",
          hp: 500,
          turnspeed: 1.2,
          price: 85000,
          maxKrewCapacity: 3,
          cargoSize: 800,
          baseheight: 1.4,
          width: 4.4,
          depth: 10.45,
          arcFront: 0.3,
          arcBack: 0.2,
          inertia: 0.1,
          radius: 8,
          speed: 7.1,
          labelHeight: 15,
          regeneration: 2,
          body: "silentDragon",
          sail: "silentDragon",
          mast: "silentDragon",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Labrador", "Malaysia"]
        },
        11: {
          id: 11,
          image: "<img src=\"/assets/img/ships/royalFortune.png\" style=\"height: 35px\">",
          name: "Royal Fortune",
          hp: 2400,
          turnspeed: 0.8,
          price: 150000,
          maxKrewCapacity: 15,
          cargoSize: 500,
          baseheight: 4,
          width: 10,
          depth: 26,
          arcFront: 0.3,
          arcBack: 0,
          inertia: 0.5,
          radius: 15,
          speed: 6.9,
          labelHeight: 15,
          regeneration: 2,
          damageBoost: 0.33,
          specialInfo: "This ship increases your damage as health decreases, up to maximum of 33% damage increase.",
          body: "royalFortune",
          sail: "royalFortune",
          mast: "royalFortune",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Cuba", "Spain"]
        },
        12: {
          id: 12,
          image: "<img src=\"/assets/img/ships/echelle.png\" style=\"height: 35px\">",
          name: "Echelle",
          hp: 1500,
          turnspeed: 0.8,
          price: 65000,
          maxKrewCapacity: 5,
          cargoSize: 5000,
          baseheight: 4,
          width: 9.5,
          depth: 29.5,
          arcFront: 0.22,
          arcBack: 0.25,
          inertia: 0.5,
          radius: 16,
          speed: 6.2,
          labelHeight: 15,
          regeneration: 1,
          body: "echelle",
          sail: "echelle",
          mast: "echelle",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Labrador", "Malaysia"]
        },
        13: {
          id: 13,
          image: "<img src=\"/assets/img/ships/calmSpirit.png\" style=\"height: 45px\">",
          name: "Calm Spirit",
          hp: 2400,
          turnspeed: 0.7,
          price: 140000,
          maxKrewCapacity: 20,
          cargoSize: 6000,
          baseheight: 4,
          width: 10,
          depth: 30,
          arcFront: 0.3,
          arcBack: 0,
          inertia: 0.5,
          radius: 16,
          speed: 6,
          labelHeight: 15,
          regeneration: 2,
          body: "calmSpirit",
          sail: "calmSpirit",
          mast: "calmSpirit",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica", "Guinea"]
        },
        14: {
          id: 14,
          image: "<img src=\"/assets/img/ships/pinta.png\" style=\"height: 35px\">",
          name: "Pinta",
          hp: 2400,
          turnspeed: 0.7,
          price: 340000,
          maxKrewCapacity: 5,
          cargoSize: 7500,
          baseheight: 5,
          width: 9.02,
          depth: 30.8,
          arcFront: 0.1,
          arcBack: 0.18,
          inertia: 1,
          radius: 20,
          speed: 6.3,
          labelHeight: 15,
          regeneration: 5,
          body: "pinta",
          sail: "pinta",
          mast: "pinta",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain"]
        },
        15: {
          id: 15,
          image: "<img src=\"/assets/img/ships/battalion.png\" style=\"height: 35px\">",
          name: "Battalion",
          hp: 3700,
          turnspeed: 0.7,
          price: 240000,
          maxKrewCapacity: 15,
          cargoSize: 3500,
          baseheight: 4,
          width: 9.9,
          depth: 29.7,
          arcFront: 0,
          arcBack: 0.1,
          inertia: 0.5,
          radius: 16,
          speed: 6.3,
          labelHeight: 15,
          regeneration: 4,
          armor: 15,
          specialInfo: "This ship has a 15% armor bonus.",
          body: "battalion",
          sail: "battalion",
          mast: "battalion",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Malaysia"]
        },
        16: {
          id: 16,
          image: "<img src=\"/assets/img/ships/junkie.png\" style=\"height: 35px\">",
          name: "Junkie",
          hp: 3000,
          turnspeed: 0.7,
          price: 160000,
          maxKrewCapacity: 10,
          cargoSize: 8000,
          baseheight: 4,
          width: 10,
          depth: 34,
          arcFront: 0.2,
          arcBack: 0,
          inertia: 1,
          radius: 15,
          speed: 5.2,
          labelHeight: 15,
          regeneration: 3,
          body: "junkie",
          sail: "junkie",
          mast: "junkie",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Spain"]
        },
        17: {
          id: 17,
          image: "<img src=\"/assets/img/ships/raider.png\" style=\"height: 35px\">",
          name: "Raider",
          hp: 1500,
          turnspeed: 0.9,
          price: 120000,
          maxKrewCapacity: 5,
          cargoSize: 1000,
          baseheight: 2,
          width: 5.04,
          depth: 19.8,
          arcFront: 0.18,
          arcBack: 0.18,
          inertia: 0.5,
          radius: 15,
          speed: 7.1,
          labelHeight: 15,
          regeneration: 2,
          body: "raider",
          sail: "raider",
          mast: "raider",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Brazil", "Cuba"]
        },
        18: {
          id: 18,
          image: "<img src=\"/assets/img/ships/queenBarbsJustice.png\" style=\"height: 50px\">",
          name: "Queen Barb's Justice",
          hp: 4000,
          turnspeed: 0.7,
          price: 260000,
          maxKrewCapacity: 20,
          cargoSize: 4000,
          baseheight: 5,
          width: 8,
          depth: 38,
          arcFront: 0.09,
          arcBack: 0.05,
          inertia: 1,
          radius: 20,
          speed: 5.9,
          labelHeight: 15,
          regeneration: 9,
          body: "queenBarbsJustice",
          sail: "queenBarbsJustice",
          mast: "queenBarbsJustice",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica"]
        },
        19: {
          id: 19,
          image: "<img src=\"/assets/img/ships/blackOyster.png\" style=\"height: 35px\">",
          name: "Black Oyster",
          hp: 6000,
          turnspeed: 0.8,
          price: 550000,
          maxKrewCapacity: 20,
          cargoSize: 2000,
          baseheight: 6,
          width: 11.5,
          depth: 45,
          arcFront: 0.14,
          arcBack: 0.08,
          inertia: 1,
          radius: 20,
          speed: 6.3,
          labelHeight: 15,
          regeneration: 5,
          body: "blackOyster",
          sail: "blackOyster",
          mast: "blackOyster",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica", "Labrador"]
        },
        20: {
          id: 20,
          image: "<img src=\"/assets/img/ships/fortuneTrader.png\" style=\"height: 50px\">",
          name: "Fortune Trader",
          hp: 7500,
          turnspeed: 0.6,
          price: 550000,
          maxKrewCapacity: 20,
          cargoSize: 12000,
          baseheight: 6.2,
          width: 15,
          depth: 64,
          arcFront: 0.14,
          arcBack: 0.12,
          inertia: 1,
          radius: 20,
          speed: 4.9,
          labelHeight: 18,
          regeneration: 1,
          body: "fortuneTrader",
          sail: "fortuneTrader",
          mast: "fortuneTrader",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Guinea"]
        },
        21: {
          id: 21,
          image: "<img src=\"/assets/img/ships/nightWind.png\" style=\"height: 35px\">",
          name: "Night Wind",
          hp: 4500,
          turnspeed: 0.7,
          price: 500000,
          maxKrewCapacity: 15,
          cargoSize: 1000,
          baseheight: 6,
          width: 12.5,
          depth: 36,
          arcFront: 0.08,
          arcBack: 0.08,
          inertia: 1,
          radius: 20,
          speed: 7,
          labelHeight: 15,
          regeneration: 2,
          body: "nightWind",
          sail: "nightWind",
          mast: "nightWind",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Cuba"]
        },
        22: {
          id: 22,
          image: "<img src=\"/assets/img/ships/flyingDutchman.png\" style=\"height: 35px\">",
          name: "Flying Dutchman",
          hp: 6500,
          turnspeed: 0.7,
          price: 1500000,
          maxKrewCapacity: 12,
          cargoSize: 1000,
          baseheight: 6,
          width: 11,
          depth: 53,
          arcFront: 0.08,
          arcBack: 0.12,
          inertia: 1,
          radius: 20,
          speed: 6.7,
          labelHeight: 15,
          regeneration: 3,
          body: "flyingDutchman",
          sail: "flyingDutchman",
          mast: "flyingDutchman",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica"]
        },
        23: {
          id: 23,
          image: "<img src=\"/assets/img/ships/queenAnnesRevenge.png\" style=\"height: 35px\">",
          name: "Queen Anne's Revenge",
          hp: 8000,
          turnspeed: 0.7,
          price: 1500000,
          maxKrewCapacity: 15,
          cargoSize: 4000,
          baseheight: 6,
          width: 11,
          depth: 53.5,
          arcFront: 0.08,
          arcBack: 0.12,
          inertia: 1,
          radius: 20,
          speed: 5.8,
          labelHeight: 15,
          regeneration: 6,
          armor: 5,
          specialInfo: "This ship has a 5% armor bonus.",
          body: "queenAnnesRevenge",
          sail: "queenAnnesRevenge",
          mast: "queenAnnesRevenge",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Brazil"]
        },
        24: {
          id: 24,
          image: "<img src=\"/assets/img/ships/taiping.png\" style=\"height: 35px\">",
          name: "Taiping",
          hp: 4500,
          turnspeed: 0.8,
          price: 550000,
          maxKrewCapacity: 15,
          cargoSize: 500,
          baseheight: 6,
          width: 13.5,
          depth: 55,
          arcFront: 0.14,
          arcBack: 0.08,
          inertia: 1,
          radius: 20,
          speed: 6.7,
          labelHeight: 15,
          regeneration: 5,
          body: "taiping",
          sail: "taiping",
          mast: "taiping",
          scale: [1, 1, 1],
          offset: [0, 0, 0],
          rotation: [0, 0, 0],
          availableAt: ["Jamaica", "Brazil"]
        }
      };
      const Ql = {
        rum: {
          cargoSpace: 8
        },
        coffee: {
          cargoSpace: 4
        },
        spice: {
          cargoSpace: 6
        },
        silk: {
          cargoSpace: 12
        },
        gems: {
          cargoSpace: 15
        },
        sugar: {
          cargoSpace: 10
        },
        bananas: {
          cargoSpace: 4
        }
      };
      let ec;
      let tc;
      let ic;
      let nc;
      let ac;
      let rc;
      let sc;
      let oc;
      let lc;
      let cc;
      let hc;
      let dc;
      let uc;
      let pc;
      let mc;
      let fc;
      let gc;
      let _c;
      let vc;
      let bc;
      let yc = [{
        id: 0,
        name: "Attack speed upgrade",
        Description: "+5 cannon fire rate",
        price: 2000,
        rarity: 1,
        attributes: {
          attackSpeed: "5"
        },
        availableAt: ["Brazil", "Malaysia", "Guinea", "Jamaica", "Spain", "Cuba", "Labrador"]
      }, {
        id: 1,
        name: "Ship speed upgrade",
        Description: "+0.2 ship speed",
        price: 3000,
        rarity: 1,
        attributes: {
          movementSpeed: "20"
        },
        availableAt: ["Brazil", "Malaysia", "Guinea", "Jamaica", "Spain", "Cuba", "Labrador"]
      }, {
        id: 2,
        name: "Cannon distance upgrade",
        Description: "+5 cannon distance",
        price: 4000,
        rarity: 1,
        attributes: {
          attackDistance: "5"
        },
        availableAt: ["Brazil", "Malaysia", "Guinea", "Jamaica", "Spain", "Cuba", "Labrador"]
      }, {
        id: 3,
        name: "Damage upgrade",
        Description: "+5 cannon damage",
        price: 5000,
        rarity: 1,
        attributes: {
          attackDamage: "5"
        },
        availableAt: ["Brazil", "Malaysia", "Guinea", "Jamaica", "Spain", "Cuba", "Labrador"]
      }, {
        id: 4,
        name: "Bruiser",
        Description: "+10 cannon damage<br/>+10 cannon fire rate",
        price: 25000,
        rarity: 1,
        availableAt: ["Cuba", "Brazil"],
        attributes: {
          attackSpeed: "10",
          attackDamage: "10"
        }
      }, {
        id: 5,
        name: "Air Pegleg",
        Description: "+1 ship speed",
        price: 40000,
        rarity: 1,
        availableAt: ["Jamaica", "Malaysia"],
        attributes: {
          movementSpeed: "100"
        }
      }, {
        id: 6,
        name: "Reinforced Planks",
        Description: "25% armor",
        price: 25000,
        rarity: 1,
        availableAt: ["Brazil"],
        attributes: {
          armor: "25"
        }
      }, {
        id: 7,
        name: "Steel Barrel",
        Description: "+25 cannon distance",
        price: 45000,
        rarity: 1,
        availableAt: ["Labrador"],
        attributes: {
          attackDistance: "25"
        }
      }, {
        id: 8,
        name: "Sinker's Gloves",
        Description: "+35 cannon fire rate",
        price: 80000,
        rarity: 1,
        availableAt: ["Spain", "Malaysia"],
        attributes: {
          attackSpeed: "35"
        }
      }, {
        id: 9,
        name: "Steel Reinforced Planks",
        Description: "40% armor",
        price: 150000,
        rarity: 1,
        availableAt: ["Brazil"],
        attributes: {
          armor: "40"
        }
      }, {
        id: 10,
        name: "Advanced Toolkit",
        Description: "+6 Regen",
        price: 125000,
        rarity: 1,
        availableAt: ["Labrador", "Malaysia"],
        attributes: {
          regen: "6"
        }
      }, {
        id: 11,
        name: "Blue Gunpowder",
        Description: "+25 cannon damage",
        price: 180000,
        rarity: 1,
        availableAt: ["Jamaica", "Cuba"],
        attributes: {
          attackDamage: "25"
        }
      }, {
        id: 12,
        name: "Drifter",
        Description: "+15 cannon damage<br/>+1.5 ship speed",
        price: 385000,
        rarity: 1,
        availableAt: ["Guinea", "Cuba"],
        attributes: {
          attackDamage: "15",
          movementSpeed: "150"
        }
      }, {
        id: 13,
        name: "Nitro Peg",
        Description: "+2 ship speed",
        price: 440000,
        rarity: 1,
        availableAt: ["Jamaica"],
        attributes: {
          movementSpeed: "200"
        }
      }, {
        id: 14,
        name: "Titanium Barrel",
        Description: "+40 cannon distance",
        price: 440000,
        rarity: 1,
        availableAt: ["Spain"],
        attributes: {
          attackDistance: "40"
        }
      }, {
        id: 15,
        name: "Demolisher",
        Description: "+25 cannon fire rate<br/>+15 cannon damage",
        price: 385000,
        rarity: 1,
        availableAt: ["Jamaica"],
        attributes: {
          attackSpeed: "25",
          attackDamage: "15"
        }
      }, {
        id: 16,
        name: "Fountain of Youth",
        Description: "Reset your skill points and allow them to be reallocated.",
        price: 300000,
        rarity: 1,
        availableAt: ["Jamaica"]
      }, {
        id: 17,
        name: "Reinforced Toolkit",
        Description: "+4 Regen<br/>33% armor<br/>+0.5 ship speed",
        price: 440000,
        rarity: 1,
        availableAt: ["Jamaica"],
        attributes: {
          movementSpeed: "50",
          regen: "4",
          armor: "33"
        }
      }, {
        id: 18,
        name: "Swift",
        Description: "+5 cannon damage<br/>+0.5 ship speed",
        price: 12500,
        rarity: 1,
        availableAt: ["Malaysia", "Labrador"],
        attributes: {
          attackDamage: "5",
          movementSpeed: "50"
        }
      }, {
        id: 19,
        name: "Red Gunpowder",
        Description: "+15 cannon damage<br/>+20 cannon distance",
        price: 220000,
        rarity: 1,
        availableAt: ["Brazil"],
        attributes: {
          attackDamage: "15",
          attackDistance: "20"
        }
      }, {
        id: 20,
        name: "Revolver",
        Description: "+5 cannon fire rate<br/>+5 cannon damage",
        price: 7500,
        rarity: 1,
        availableAt: ["Cuba"],
        attributes: {
          attackSpeed: "5",
          attackDamage: "5"
        }
      }, {
        id: 21,
        name: "Kraken's Caliber",
        Description: "+10 cannon damage<br/>+10 cannon fire rate<br/>+10 cannon distance<br/>-1 ship speed",
        price: 120000,
        rarity: 1,
        availableAt: ["Cuba"],
        attributes: {
          attackDamage: "10",
          attackSpeed: "10",
          attackDistance: "10",
          movementSpeed: "-100"
        }
      }, {
        id: 22,
        name: "Corsair's Rampart",
        Description: "60% armor<br/>Disables regen<br/>-1 ship speed",
        price: 440000,
        rarity: 1,
        availableAt: ["Brazil"],
        attributes: {
          disableRegen: true,
          armor: "60",
          movementSpeed: "-100"
        }
      }];
      let xc = {};
      let wc = {};
      let Mc = {};
      let Sc = {};
      let Ec = {};
      let Tc = {};
      let Cc = {};
      let kc = {};
      let Ac = {};
      let Lc = {};
      let Rc = {};
      let Pc = {};
      let Dc = {};
      let Ic = [];
      let $c = [];
      let zc = [];
      let Nc = [];
      let Oc = [];
      let Uc = [["classic", "floppyEars", "ArcticWolf"], ["classic", "floppyEars", "Seafox"], ["classic", "raisedEars", "Commodore"], ["classic", "raisedEars", "Krewmate"], ["classic", "raisedEars", "Seadog"], ["classic", "raisedEars", "Shibainu"], ["members", "floppyEars", "Devilcat"], ["members", "floppyEars", "PotatoPrem"], ["members", "floppyEars", "VOID"], ["members", "raisedEars", "BSK"], ["members", "raisedEars", "Headkeeper"], ["members", "raisedEars", "domino"], ["modern", "floppyEars", "AstronotSkinKrew"], ["modern", "floppyEars", "Crab"], ["modern", "floppyEars", "DavyJones"], ["modern", "floppyEars", "EpicColor"], ["modern", "floppyEars", "EyeThunder"], ["modern", "floppyEars", "HamburgersSkinKrew"], ["modern", "floppyEars", "JackSparrow"], ["modern", "floppyEars", "KnightSkinKrew"], ["modern", "floppyEars", "KrewItachiUchiha"], ["modern", "floppyEars", "KrewSuzaku"], ["modern", "floppyEars", "MermaidPrince"], ["modern", "floppyEars", "OGCommodoreBlack1"], ["modern", "floppyEars", "PirateKing"], ["modern", "floppyEars", "Psychopath"], ["modern", "floppyEars", "Rabbit"], ["modern", "floppyEars", "Sharkman"], ["modern", "floppyEars", "WillTurner"], ["modern", "floppyEars", "Wizard"], ["modern", "floppyEars", "YinYang"], ["modern", "raisedEars", "Alien"], ["modern", "raisedEars", "Cyborg"], ["modern", "raisedEars", "Cyclops"], ["modern", "raisedEars", "Demon"], ["modern", "raisedEars", "Dragon"], ["modern", "raisedEars", "DuckRev"], ["modern", "raisedEars", "Ghost"], ["modern", "raisedEars", "KrewAlucard"], ["modern", "raisedEars", "KrewBayako"], ["modern", "raisedEars", "KrewEren"], ["modern", "raisedEars", "KrewGoku"], ["modern", "raisedEars", "KrewHeie"], ["modern", "raisedEars", "KrewJellal"], ["modern", "raisedEars", "KrewNinetailFox"], ["modern", "raisedEars", "KrewObito"], ["modern", "raisedEars", "KrewSeiryu"], ["modern", "raisedEars", "KrewTouya"], ["modern", "raisedEars", "KrewVegeta"], ["modern", "raisedEars", "NavyDog"], ["modern", "raisedEars", "RedDevilHoodie1"], ["modern", "raisedEars", "Werewolf"], ["modern", "raisedEars", "Zombie"], ["staff", "floppyEars", "BLADE"], ["staff", "floppyEars", "DamienVesper"], ["staff", "floppyEars", "MrGoat"], ["staff", "floppyEars", "Nemesis"], ["staff", "floppyEars", "Sjmun"], ["staff", "floppyEars", "chocomilk"], ["staff", "floppyEars", "devclied"], ["staff", "floppyEars", "oventes"], ["staff", "floppyEars", "xTangox"], ["staff", "raisedEars", "BR88C"], ["staff", "raisedEars", "DrSilver"], ["staff", "raisedEars", "Fiftyyyyy"], ["staff", "raisedEars", "Kekmw"], ["staff", "raisedEars", "Sloth"], ["staff", "raisedEars", "Stendo"], ["staff", "raisedEars", "TheChoco"], ["staff", "raisedEars", "Viplol"]];
      let Fc = "";
      let Bc = 10;
      let Hc = 1;
      let Vc = 2000;
      let Gc = Jl.worldsize / 2;
      let Wc = 0;
      let qc = 0;
      let jc = false;
      let Xc = false;
      let Kc = false;
      let Yc = false;
      let Jc = false;
      let Zc = false;
      let Qc = false;
      let eh = false;
      let th = true;
      let ih = false;
      let nh = false;
      let ah = false;
      let rh = false;
      let sh = false;
      let oh = false;
      let lh = false;
      let ch = false;
      let hh = new THREE.TextureLoader();
      new THREE.FileLoader();
      let dh = new THREE.OBJLoader();
      let uh = new THREE.MTLLoader();
      let ph = new class extends _o {
        constructor(e) {
          super(e);
        }
        parse(e) {
          if (e.length < 19) {
            console.error("THREE.TGALoader: Not enough data to contain header.");
          }
          let t = 0;
          const i = new Uint8Array(e);
          const n = {
            id_length: i[t++],
            colormap_type: i[t++],
            image_type: i[t++],
            colormap_index: i[t++] | i[t++] << 8,
            colormap_length: i[t++] | i[t++] << 8,
            colormap_size: i[t++],
            origin: [i[t++] | i[t++] << 8, i[t++] | i[t++] << 8],
            width: i[t++] | i[t++] << 8,
            height: i[t++] | i[t++] << 8,
            pixel_size: i[t++],
            flags: i[t++]
          };
          (function (e) {
            switch (e.image_type) {
              case 1:
              case 9:
                if (e.colormap_length > 256 || e.colormap_size !== 24 || e.colormap_type !== 1) {
                  console.error("THREE.TGALoader: Invalid type colormap data for indexed type.");
                }
                break;
              case 2:
              case 3:
              case 10:
              case 11:
                if (e.colormap_type) {
                  console.error("THREE.TGALoader: Invalid type colormap data for colormap type.");
                }
                break;
              case 0:
                console.error("THREE.TGALoader: No data.");
              default:
                console.error("THREE.TGALoader: Invalid type \"%s\".", e.image_type);
            }
            if (e.width <= 0 || e.height <= 0) {
              console.error("THREE.TGALoader: Invalid image size.");
            }
            if (e.pixel_size !== 8 && e.pixel_size !== 16 && e.pixel_size !== 24 && e.pixel_size !== 32) {
              console.error("THREE.TGALoader: Invalid pixel size \"%s\".", e.pixel_size);
            }
          })(n);
          if (n.id_length + t > e.length) {
            console.error("THREE.TGALoader: No data.");
          }
          t += n.id_length;
          let a = false;
          let r = false;
          let s = false;
          switch (n.image_type) {
            case 9:
              a = true;
              r = true;
              break;
            case 1:
              r = true;
              break;
            case 10:
              a = true;
              break;
            case 2:
              break;
            case 11:
              a = true;
              s = true;
              break;
            case 3:
              s = true;
          }
          const o = new Uint8Array(n.width * n.height * 4);
          const l = function (e, t, i, n, a) {
            let r;
            let s;
            const o = i.pixel_size >> 3;
            const l = i.width * i.height * o;
            if (t) {
              s = a.subarray(n, n += i.colormap_length * (i.colormap_size >> 3));
            }
            if (e) {
              let e;
              let t;
              let i;
              r = new Uint8Array(l);
              let s = 0;
              const c = new Uint8Array(o);
              while (s < l) {
                e = a[n++];
                t = 1 + (e & 127);
                if (e & 128) {
                  for (i = 0; i < o; ++i) {
                    c[i] = a[n++];
                  }
                  for (i = 0; i < t; ++i) {
                    r.set(c, s + i * o);
                  }
                  s += o * t;
                } else {
                  t *= o;
                  i = 0;
                  for (; i < t; ++i) {
                    r[s + i] = a[n++];
                  }
                  s += t;
                }
              }
            } else {
              r = a.subarray(n, n += t ? i.width * i.height : l);
            }
            return {
              pixel_data: r,
              palettes: s
            };
          }(a, r, n, t, i);
          (function (e, t, i, a, r) {
            let o;
            let l;
            let c;
            let h;
            let d;
            let u;
            switch ((n.flags & 48) >> 4) {
              default:
              case 2:
                o = 0;
                c = 1;
                d = t;
                l = 0;
                h = 1;
                u = i;
                break;
              case 0:
                o = 0;
                c = 1;
                d = t;
                l = i - 1;
                h = -1;
                u = -1;
                break;
              case 3:
                o = t - 1;
                c = -1;
                d = -1;
                l = 0;
                h = 1;
                u = i;
                break;
              case 1:
                o = t - 1;
                c = -1;
                d = -1;
                l = i - 1;
                h = -1;
                u = -1;
            }
            if (s) {
              switch (n.pixel_size) {
                case 8:
                  (function (e, t, i, a, r, s, o, l) {
                    let c;
                    let h;
                    let d;
                    let u = 0;
                    const p = n.width;
                    for (d = t; d !== a; d += i) {
                      for (h = r; h !== o; h += s, u++) {
                        c = l[u];
                        e[(h + p * d) * 4 + 0] = c;
                        e[(h + p * d) * 4 + 1] = c;
                        e[(h + p * d) * 4 + 2] = c;
                        e[(h + p * d) * 4 + 3] = 255;
                      }
                    }
                  })(e, l, h, u, o, c, d, a);
                  break;
                case 16:
                  (function (e, t, i, a, r, s, o, l) {
                    let c;
                    let h;
                    let d = 0;
                    const u = n.width;
                    for (h = t; h !== a; h += i) {
                      for (c = r; c !== o; c += s, d += 2) {
                        e[(c + u * h) * 4 + 0] = l[d + 0];
                        e[(c + u * h) * 4 + 1] = l[d + 0];
                        e[(c + u * h) * 4 + 2] = l[d + 0];
                        e[(c + u * h) * 4 + 3] = l[d + 1];
                      }
                    }
                  })(e, l, h, u, o, c, d, a);
                  break;
                default:
                  console.error("THREE.TGALoader: Format not supported.");
              }
            } else {
              switch (n.pixel_size) {
                case 8:
                  (function (e, t, i, a, r, s, o, l, c) {
                    const h = c;
                    let d;
                    let u;
                    let p;
                    let m = 0;
                    const f = n.width;
                    for (p = t; p !== a; p += i) {
                      for (u = r; u !== o; u += s, m++) {
                        d = l[m];
                        e[(u + f * p) * 4 + 3] = 255;
                        e[(u + f * p) * 4 + 2] = h[d * 3 + 0];
                        e[(u + f * p) * 4 + 1] = h[d * 3 + 1];
                        e[(u + f * p) * 4 + 0] = h[d * 3 + 2];
                      }
                    }
                  })(e, l, h, u, o, c, d, a, r);
                  break;
                case 16:
                  (function (e, t, i, a, r, s, o, l) {
                    let c;
                    let h;
                    let d;
                    let u = 0;
                    const p = n.width;
                    for (d = t; d !== a; d += i) {
                      for (h = r; h !== o; h += s, u += 2) {
                        c = l[u + 0] + (l[u + 1] << 8);
                        e[(h + p * d) * 4 + 0] = (c & 31744) >> 7;
                        e[(h + p * d) * 4 + 1] = (c & 992) >> 2;
                        e[(h + p * d) * 4 + 2] = (c & 31) << 3;
                        e[(h + p * d) * 4 + 3] = c & 32768 ? 0 : 255;
                      }
                    }
                  })(e, l, h, u, o, c, d, a);
                  break;
                case 24:
                  (function (e, t, i, a, r, s, o, l) {
                    let c;
                    let h;
                    let d = 0;
                    const u = n.width;
                    for (h = t; h !== a; h += i) {
                      for (c = r; c !== o; c += s, d += 3) {
                        e[(c + u * h) * 4 + 3] = 255;
                        e[(c + u * h) * 4 + 2] = l[d + 0];
                        e[(c + u * h) * 4 + 1] = l[d + 1];
                        e[(c + u * h) * 4 + 0] = l[d + 2];
                      }
                    }
                  })(e, l, h, u, o, c, d, a);
                  break;
                case 32:
                  (function (e, t, i, a, r, s, o, l) {
                    let c;
                    let h;
                    let d = 0;
                    const u = n.width;
                    for (h = t; h !== a; h += i) {
                      for (c = r; c !== o; c += s, d += 4) {
                        e[(c + u * h) * 4 + 2] = l[d + 0];
                        e[(c + u * h) * 4 + 1] = l[d + 1];
                        e[(c + u * h) * 4 + 0] = l[d + 2];
                        e[(c + u * h) * 4 + 3] = l[d + 3];
                      }
                    }
                  })(e, l, h, u, o, c, d, a);
                  break;
                default:
                  console.error("THREE.TGALoader: Format not supported.");
              }
            }
          })(o, n.width, n.height, l.pixel_data, l.palettes);
          return {
            data: o,
            width: n.width,
            height: n.height,
            flipY: true,
            generateMipmaps: true,
            minFilter: de
          };
        }
      }();
      let mh = performance.now();
      let fh = [];
      let gh = [];
      let _h = {
        $shoppingList: $("#shopping-item-list")
      };
      let vh = (e, t) => e + Math.floor(Math.random() * (t - e + 1));
      let bh = {
        box: new THREE.BoxBufferGeometry(1, 1, 1),
        sphere: new THREE.SphereBufferGeometry(0.65),
        line: new THREE.Geometry(),
        plane: new THREE.PlaneGeometry(2, 2)
      };
      let yh = {
        boat: new THREE.MeshLambertMaterial({
          color: 9064510,
          side: THREE.DoubleSide
        }),
        sail: new THREE.MeshLambertMaterial({
          color: 16777215,
          side: THREE.DoubleSide
        }),
        splinter: new THREE.MeshLambertMaterial({
          color: 13479055,
          flatShading: true
        }),
        boundary: new THREE.MeshLambertMaterial({
          color: 11856895,
          flatShading: true,
          opacity: 0.8,
          transparent: true
        }),
        impact_water: new THREE.MeshBasicMaterial({
          color: 15331839,
          flatShading: true,
          opacity: 0.9,
          transparent: true
        }),
        islandradius: new THREE.MeshBasicMaterial({
          color: 13957119,
          flatShading: false,
          opacity: 0.2,
          transparent: true
        }),
        smoke_enemy: new THREE.MeshBasicMaterial({
          color: 16763594,
          flatShading: true,
          opacity: 0.7,
          transparent: true
        }),
        smoke_friendly: new THREE.MeshBasicMaterial({
          color: 15204326,
          flatShading: true,
          opacity: 0.7,
          transparent: true
        }),
        smoke_player: new THREE.MeshBasicMaterial({
          color: 14687774,
          flatShading: true,
          opacity: 0.5,
          transparent: true
        }),
        sky: new THREE.MeshBasicMaterial({
          color: 50687,
          side: THREE.DoubleSide
        })
      };
      let xh = {
        dev: new THREE.Color(16261205),
        admin: new THREE.Color(2790137),
        mod: new THREE.Color(10306789),
        helper: new THREE.Color(6548733),
        myself: new THREE.Color(2945583),
        clan: new THREE.Color(16757777),
        alliance: new THREE.Color(3866044),
        captain: new THREE.Color(16732416),
        krewmate: new THREE.Color(16741952),
        player: new THREE.Color(16777215),
        boat: new THREE.Color(12952444),
        landmark: new THREE.Color(6198824),
        crosshair: new THREE.Color(16777215)
      };
      let wh = {
        sizePlayer: new THREE.Vector3(1, 1, 1),
        sizeProjectile: new THREE.Vector3(0.3, 0.3, 0.3)
      };
      let Mh = (e, t) => {
        if (wc[e] === undefined) {
          switch (t.n) {
            case 0:
              wc[e] = new Rd(t);
              wc[e].playerModel = t.playerModel ? t.playerModel : 0;
              wc[e].hatModel = t.hatModel ? t.hatModel : 0;
              if (e === Fc) {
                hc = wc[e];
                hc.isPlayer = true;
              }
              break;
            case 1:
              wc[e] = new Cd(t.t.b);
              break;
            case 2:
              wc[e] = new Pd();
              break;
            case 3:
              wc[e] = new kd(parseInt(t.t.a), parseFloat(t.x), parseFloat(t.z));
              break;
            case 4:
              wc[e] = new Ld(parseInt(t.t.s), parseFloat(t.x), parseFloat(t.z), parseInt(t.t.t));
              break;
            case 5:
              wc[e] = new Ad(parseInt(t.t.t), parseFloat(t.x), parseFloat(t.z), t.t);
          }
          if (wc[e] !== undefined) {
            wc[e].id = e;
            wc[e].createBody();
          }
        }
        if (wc[e] !== undefined) {
          wc[e].parseSnap(t, e);
        }
      };
      window.logoutUser = () => {
        Uh.invalidateCookie("username");
        Uh.invalidateCookie("token");
        window.location.pathname = "/auth/logout";
      };
      let Sh = () => {
        if (pc) {
          pc.setSize(window.innerWidth, window.innerHeight);
        }
        if (ec) {
          ec.aspect = window.innerWidth / window.innerHeight;
          ec.updateProjectionMatrix();
        }
      };
      window.addEventListener("resize", Sh, false);
      let Eh = () => {
        switch (parseInt($("#quality-list").val())) {
          case 0:
            if (lc !== undefined) {
              let e = sc / 3.5;
              let t = rc / 3.5;
              lc.canvas.height = t;
              lc.canvas.width = e;
              lc.viewport(0, 0, e, e);
              pc.setSize(e, e, false);
            }
            break;
          case 1:
            if (lc !== undefined) {
              let e = sc / 2.5;
              let t = rc / 2.5;
              lc.canvas.height = t;
              lc.canvas.width = e;
              lc.viewport(0, 0, e, e);
              pc.setSize(e, e, false);
            }
            break;
          case 2:
            if (lc !== undefined) {
              let e = sc / 1.45;
              let t = rc / 1.45;
              lc.canvas.height = t;
              lc.canvas.width = e;
              lc.viewport(0, 0, e, t);
              pc.setSize(e, e, false);
            }
            break;
          case 3:
            if (lc !== undefined) {
              let e = sc;
              let t = rc;
              lc.canvas.height = t;
              lc.canvas.width = e;
              lc.viewport(0, 0, e, t);
              pc.setSize(e, e, false);
            }
        }
      };
      window.updateInputRange = e => {
        let t = e.parent().find("output");
        let i = e.attr("min");
        let n = (e.attr("max") - i) / 100;
        let a = e.val();
        let r = (a - i) / n;
        t.html(a);
        e.attr("style", `--value:${r}`);
        t.attr("style", `left:${r}%; transform: translate(-${r}%);`);
      };
      window.inputRange = e => {
        e.on("input change", () => updateInputRange(e));
      };
      var Th = {
        ":woman_woman_girl_girl:": "",
        ":woman_woman_girl_boy:": "",
        ":woman_woman_boy_boy:": "",
        ":man_woman_girl_girl:": "",
        ":man_woman_girl_boy:": "",
        ":man_woman_boy_boy:": "",
        ":man_man_girl_girl:": "",
        ":man_man_girl_boy:": "",
        ":man_man_boy_boy:": "",
        ":woman_woman_girl:": "",
        ":woman_woman_boy:": "",
        ":woman_girl_girl:": "",
        ":woman_girl_boy:": "",
        ":woman_boy_boy:": "",
        ":man_woman_girl:": "",
        ":man_man_girl:": "",
        ":man_man_boy:": "",
        ":man_girl_girl:": "",
        ":man_girl_boy:": "",
        ":man_boy_boy:": "",
        ":woman_girl:": "",
        ":woman_boy:": "",
        ":man_girl:": "",
        ":man_boy:": "",
        ":joy:": "",
        ":heart:": "",
        ":heart_suit:": "",
        ":heart_eyes:": "",
        ":sob:": "",
        ":blush:": "",
        ":unamused:": "",
        ":kissing_heart:": "",
        ":two_hearts:": "",
        ":smiling:": "",
        ":weary:": "",
        ":dark_skin_tone:": "",
        ":mediumdark_skin_tone:": "",
        ":medium_skin_tone:": "",
        ":mediumlight_skin_tone:": "",
        ":light_skin_tone:": "",
        ":ok_hand:": "",
        ":pensive:": "",
        ":smirk:": "",
        ":grin:": "",
        ":recycle:": "",
        ":wink:": "",
        ":thumbsup:": "",
        ":pray:": "",
        ":relieved:": "",
        ":notes:": "",
        ":flushed:": "",
        ":raised_hands:": "",
        ":see_no_evil:": "",
        ":cry:": "",
        ":sunglasses:": "",
        ":v:": "",
        ":eyes:": "",
        ":sweat_smile:": "",
        ":sparkles:": "",
        ":sleeping:": "",
        ":smile:": "",
        ":purple_heart:": "",
        ":broken_heart:": "",
        ":hundred_points:": "",
        ":expressionless:": "",
        ":sparkling_heart:": "",
        ":blue_heart:": "",
        ":confused:": "",
        ":man_tipping_hand:": "",
        ":information_desk_person:": "",
        ":stuck_out_tongue_winking_eye:": "",
        ":disappointed:": "",
        ":yum:": "",
        ":neutral_face:": "",
        ":sleepy:": "",
        ":clap:": "",
        ":cupid:": "",
        ":heartpulse:": "",
        ":revolving_hearts:": "",
        ":arrow_left:": "",
        ":speak_no_evil:": "",
        ":raised_hand:": "",
        ":kiss:": "",
        ":point_right:": "",
        ":cherry_blossom:": "",
        ":scream:": "",
        ":fire:": "",
        ":rage:": "",
        ":smiley:": "",
        ":tada:": "",
        ":oncoming_fist:": "",
        ":tired_face:": "",
        ":camera:": "",
        ":rose:": "",
        ":stuck_out_tongue_closed_eyes:": "",
        ":muscle:": "",
        ":skull:": "",
        ":sunny:": "",
        ":yellow_heart:": "",
        ":triumph:": "",
        ":new_moon_with_face:": "",
        ":laughing:": "",
        ":sweat:": "",
        ":point_left:": "",
        ":heavy_check_mark:": "",
        ":heart_eyes_cat:": "",
        ":grinning:": "",
        ":mask:": "",
        ":green_heart:": "",
        ":wave:": "",
        ":persevere:": "",
        ":heartbeat:": "",
        ":arrow_forward:": "",
        ":arrow_backward:": "",
        ":arrow_right_hook:": "",
        ":leftwards_arrow_with_hook:": "",
        ":crown:": "",
        ":kissing_closed_eyes:": "",
        ":stuck_out_tongue:": "",
        ":disappointed_relieved:": "",
        ":innocent:": "",
        ":headphones:": "",
        ":white_check_mark:": "",
        ":confounded:": "",
        ":arrow_right:": "",
        ":angry:": "",
        ":grimacing:": "",
        ":star2:": "",
        ":gun:": "",
        ":man_raising_hand:": "",
        ":raising_hand:": "",
        ":thumbsdown:": "",
        ":dancer:": "",
        ":musical_note:": "",
        ":no_mouth:": "",
        ":dizzy:": "",
        ":fist:": "",
        ":point_down:": "",
        ":red_circle:": "",
        ":man_gesturing_NO:": "",
        ":no_good:": "",
        ":boom:": "",
        ":copyright:": "",
        ":thought_balloon:": "",
        ":tongue:": "",
        ":poop:": "",
        ":cold_sweat:": "",
        ":gem:": "",
        ":man_gesturing_OK:": "",
        ":ok_woman:": "",
        ":pizza:": "",
        ":joy_cat:": "",
        ":sun_with_face:": "",
        ":leaves:": "",
        ":sweat_drops:": "",
        ":penguin:": "",
        ":zzz:": "",
        ":woman_walking:": "",
        ":walking:": "",
        ":airplane:": "",
        ":balloon:": "",
        ":star:": "",
        ":ribbon:": "",
        ":ballot_box_with_check:": "",
        ":worried:": "",
        ":underage:": "",
        ":fearful:": "",
        ":four_leaf_clover:": "",
        ":hibiscus:": "",
        ":microphone:": "",
        ":open_hands:": "",
        ":ghost:": "",
        ":palm_tree:": "",
        ":bangbang:": "",
        ":nail_care:": "",
        ":x:": "",
        ":alien:": "",
        ":woman_bowing:": "",
        ":bow:": "",
        ":cloud:": "",
        ":soccer:": "",
        ":angel:": "",
        ":men_with_bunny_ears:": "",
        ":dancers:": "",
        ":exclamation:": "",
        ":snowflake:": "",
        ":point_up:": "",
        ":kissing_smiling_eyes:": "",
        ":rainbow:": "",
        ":crescent_moon:": "",
        ":heart_decoration:": "",
        ":gift_heart:": "",
        ":gift:": "",
        ":beers:": "",
        ":anguished:": "",
        ":earth_africa:": "",
        ":movie_camera:": "",
        ":anchor:": "",
        ":zap:": "",
        ":club_suit:": "",
        ":heavy_multiplication_x:": "",
        ":woman_running:": "",
        ":runner:": "",
        ":sunflower:": "",
        ":earth_americas:": "",
        ":bouquet:": "",
        ":dog:": "",
        ":moneybag:": "",
        ":herb:": "",
        ":couple:": "",
        ":fallen_leaf:": "",
        ":tulip:": "",
        ":birthday:": "",
        ":cat:": "",
        ":coffee:": "",
        ":dizzy_face:": "",
        ":point_up_2:": "",
        ":open_mouth:": "",
        ":hushed:": "",
        ":basketball:": "",
        ":christmas_tree:": "",
        ":ring:": "",
        ":full_moon_with_face:": "",
        ":astonished:": "",
        ":two_women_holding_hands:": "",
        ":money_with_wings:": "",
        ":crying_cat_face:": "",
        ":hear_no_evil:": "",
        ":dash:": "",
        ":cactus:": "",
        ":hotsprings:": "",
        ":telephone:": "",
        ":maple_leaf:": "",
        ":princess:": "",
        ":man_getting_massage:": "",
        ":massage:": "",
        ":love_letter:": "",
        ":trophy:": "",
        ":man_frowning:": "",
        ":person_frowning:": "",
        ":us:": "",
        ":confetti_ball:": "",
        ":blossom:": "",
        ":kitchen_knife:": "",
        ":lips:": "",
        ":fries:": "",
        ":doughnut:": "",
        ":frowning:": "",
        ":ocean:": "",
        ":bomb:": "",
        ":ok:": "",
        ":cyclone:": "",
        ":rocket:": "",
        ":umbrella:": "",
        ":couplekiss:": "",
        ":couple_woman_kiss:": "",
        ":couple_man_kiss:": "",
        ":couple_with_heart:": "",
        ":woman_woman:": "",
        ":man_man_love:": "",
        ":lollipop:": "",
        ":clapper:": "",
        ":pig:": "",
        ":smiling_imp:": "",
        ":imp:": "",
        ":bee:": "",
        ":kissing_cat:": "",
        ":anger:": "",
        ":musical_score:": "",
        ":santa:": "",
        ":earth_asia:": "",
        ":football:": "",
        ":guitar:": "",
        ":diamond_suit:": "",
        ":panda_face:": "",
        ":speech_balloon:": "",
        ":strawberry:": "",
        ":smirk_cat:": "",
        ":banana:": "",
        ":watermelon:": "",
        ":snowman:": "",
        ":smile_cat:": "",
        ":spade_suit:": "",
        ":top:": "",
        ":eggplant:": "",
        ":crystal_ball:": "",
        ":fork_and_knife:": "",
        ":calling:": "",
        ":iphone:": "",
        ":partly_sunny:": "",
        ":warning:": "",
        ":scream_cat:": "",
        ":small_orange_diamond:": "",
        ":baby:": "",
        ":feet:": "",
        ":footprints:": "",
        ":beer:": "",
        ":wine_glass:": "",
        ":o:": "",
        ":video_camera:": "",
        ":rabbit:": "",
        ":tropical_drink:": "",
        ":smoking:": "",
        ":space_invader:": "",
        ":choorka:": "",
        ":peach:": "",
        ":snake:": "",
        ":turtle:": "",
        ":cherries:": "",
        ":kissing:": "",
        ":frog:": "",
        ":milky_way:": "",
        ":rotating_light:": "",
        ":hatching_chick:": "",
        ":closed_book:": "",
        ":candy:": "",
        ":hamburger:": "",
        ":bear:": "",
        ":tiger:": "",
        ":automobile:": "",
        ":fast_forward:": "",
        ":icecream:": "",
        ":pineapple:": "",
        ":ear_of_rice:": "",
        ":syringe:": "",
        ":put_litter_in_its_place:": "",
        ":chocolate_bar:": "",
        ":black_small_square:": "",
        ":tv:": "",
        ":pill:": "",
        ":octopus:": "",
        ":jack_o_lantern:": "",
        ":grapes:": "",
        ":smiley_cat:": "",
        ":cd:": "",
        ":cocktail:": "",
        ":cake:": "",
        ":video_game:": "",
        ":trade_mark:": "",
        ":arrow_down:": "",
        ":no_entry_sign:": "",
        ":lipstick:": "",
        ":whale:": "",
        ":memo:": "",
        ":registered:": "",
        ":cookie:": "",
        ":dolphin:": "",
        ":loud_sound:": "",
        ":man:": "",
        ":hatched_chick:": "",
        ":monkey:": "",
        ":books:": "",
        ":japanese_ogre:": "",
        ":woman_guard:": "",
        ":guardsman:": "",
        ":loudspeaker:": "",
        ":scissors:": "",
        ":girl:": "",
        ":mortar_board:": "",
        ":fr:": "",
        ":baseball:": "",
        ":vertical_traffic_light:": "",
        ":woman:": "",
        ":fireworks:": "",
        ":stars:": "",
        ":sos:": "",
        ":mushroom:": "",
        ":pouting_cat:": "",
        ":left_luggage:": "",
        ":high_heel:": "",
        ":dart:": "",
        ":woman_swimming:": "",
        ":swimmer:": "",
        ":key:": "",
        ":bikini:": "",
        ":family:": "",
        ":pencil2:": "",
        ":elephant:": "",
        ":droplet:": "",
        ":seedling:": "",
        ":apple:": "",
        ":cool:": "",
        ":telephone_receiver:": "",
        ":dollar:": "",
        ":house_with_garden:": "",
        ":book:": "",
        ":man_getting_haircut:": "",
        ":haircut:": "",
        ":computer:": "",
        ":bulb:": "",
        ":question:": "",
        ":back:": "",
        ":boy:": "",
        ":closed_lock_with_key:": "",
        ":man_pouting:": "",
        ":person_with_pouting_face:": "",
        ":tangerine:": "",
        ":leftright_arrow:": "",
        ":sunrise:": "",
        ":poultry_leg:": "",
        ":blue_circle:": "",
        ":oncoming_automobile:": "",
        ":shaved_ice:": "",
        ":it:": "",
        ":bird:": "",
        ":gb:": "",
        ":first_quarter_moon_with_face:": "",
        ":eyeglasses:": "",
        ":goat:": "",
        ":night_with_stars:": "",
        ":older_woman:": "",
        ":black_circle:": "",
        ":new_moon:": "",
        ":two_men_holding_hands:": "",
        ":white_circle:": "",
        ":customs:": "",
        ":tropical_fish:": "",
        ":house:": "",
        ":arrows_clockwise:": "",
        ":last_quarter_moon_with_face:": "",
        ":round_pushpin:": "",
        ":full_moon:": "",
        ":athletic_shoe:": "",
        ":lemon:": "",
        ":baby_bottle:": "",
        ":artist_palette:": "",
        ":envelope:": "",
        ":spaghetti:": "",
        ":wind_chime:": "",
        ":fish_cake:": "",
        ":evergreen_tree:": "",
        ":up:": "",
        ":arrow_up:": "",
        ":arrow_upper_right:": "",
        ":arrow_lower_right:": "",
        ":arrow_lower_left:": "",
        ":performing_arts:": "",
        ":nose:": "",
        ":pig_nose:": "",
        ":fish:": "",
        ":woman_wearing_turban:": "",
        ":man_with_turban:": "",
        ":koala:": "",
        ":ear:": "",
        ":eight_spoked_asterisk:": "",
        ":small_blue_diamond:": "",
        ":shower:": "",
        ":bug:": "",
        ":ramen:": "",
        ":tophat:": "",
        ":bride_with_veil:": "",
        ":fuelpump:": "",
        ":checkered_flag:": "",
        ":horse:": "",
        ":watch:": "",
        ":monkey_face:": "",
        ":baby_symbol:": "",
        ":new:": "",
        ":free:": "",
        ":sparkler:": "",
        ":corn:": "",
        ":tennis:": "",
        ":alarm_clock:": "",
        ":battery:": "",
        ":grey_exclamation:": "",
        ":wolf:": "",
        ":moyai:": "",
        ":cow:": "",
        ":mega:": "",
        ":older_man:": "",
        ":dress:": "",
        ":link:": "",
        ":chicken:": "",
        ":cooking:": "",
        ":whale2:": "",
        ":arrow_upper_left:": "",
        ":deciduous_tree:": "",
        ":bento:": "",
        ":pushpin:": "",
        ":soon:": "",
        ":repeat:": "",
        ":dragon:": "",
        ":hamster:": "",
        ":golf:": "",
        ":woman_surfing:": "",
        ":surfer:": "",
        ":mouse:": "",
        ":waxing_crescent_moon:": "",
        ":blue_car:": "",
        ":a:": "",
        ":interrobang:": "",
        ":u5272:": "",
        ":electric_plug:": "",
        ":first_quarter_moon:": "",
        ":cancer:": "",
        ":trident:": "",
        ":bread:": "",
        ":woman_police_officer:": "",
        ":cop:": "",
        ":tea:": "",
        ":fishing_pole_and_fish:": "",
        ":waxing_gibbous_moon:": "",
        ":bike:": "",
        ":bust_in_silhouette:": "",
        ":rice:": "",
        ":radio:": "",
        ":baby_chick:": "",
        ":arrow_heading_down:": "",
        ":waning_crescent_moon:": "",
        ":arrow_up_down:": "",
        "": "#",
        ":last_quarter_moon:": "",
        ":radio_button:": "",
        ":sheep:": "",
        ":dark_skin_tone_blond_hair:": "",
        ":mediumdark_skin_tone_blond_hair:": "",
        ":medium_skin_tone_blond_hair:": "",
        ":mediumlight_skin_tone_blond_hair:": "",
        ":light_skin_tone_blond_hair:": "",
        ":blond_hair:": "",
        ":person_with_blond_hair:": "",
        ":waning_gibbous_moon:": "",
        ":lock:": "",
        ":green_apple:": "",
        ":japanese_goblin:": "",
        ":curly_loop:": "",
        ":triangular_flag_on_post:": "",
        ":arrows_counterclockwise:": "",
        ":racehorse:": "",
        ":fried_shrimp:": "",
        ":sunrise_over_mountains:": "",
        ":volcano:": "",
        ":rooster:": "",
        ":inbox_tray:": "",
        ":wedding:": "",
        ":sushi:": "",
        ":wavy_dash:": "",
        ":ice_cream:": "",
        ":rewind:": "",
        ":tomato:": "",
        ":rabbit2:": "",
        ":eight_pointed_black_star:": "",
        ":small_red_triangle:": "",
        ":high_brightness:": "",
        ":heavy_plus_sign:": "",
        ":man_with_gua_pi_mao:": "",
        ":convenience_store:": "",
        ":busts_in_silhouette:": "",
        ":beetle:": "",
        ":small_red_triangle_down:": "",
        ":ger:": "",
        ":arrow_heading_up:": "",
        ":name_badge:": "",
        ":bath:": "",
        ":no_entry:": "",
        ":crocodile:": "",
        ":chestnut:": "",
        ":dog2:": "",
        ":cat2:": "",
        ":hammer:": "",
        ":meat_on_bone:": "",
        ":shell:": "",
        ":sparkle:": "",
        ":sailboat:": "",
        ":b:": "",
        ":m:": "",
        ":poodle:": "",
        ":aquarius:": "",
        ":stew:": "",
        ":jeans:": "",
        ":honey_pot:": "",
        ":musical_keyboard:": "",
        ":unlock:": "",
        ":black_nib:": "",
        ":statue_of_liberty:": "",
        ":heavy_dollar_sign:": "",
        ":snowboarder:": "",
        ":white_flower:": "",
        ":necktie:": "",
        ":diamond_shape_with_a_dot_inside:": "",
        ":aries:": "",
        ":womens:": "",
        ":ant:": "",
        ":scorpius:": "",
        ":city_sunset:": "",
        ":hourglass_flowing_sand:": "",
        ":o2:": "",
        ":dragon_face:": "",
        ":snail:": "",
        ":dvd:": "",
        ":shirt:": "",
        ":game_die:": "",
        ":heavy_minus_sign:": "",
        ":dolls:": "",
        ":sagittarius:": "",
        ":8ball:": "",
        ":bus:": "",
        ":custard:": "",
        ":crossed_flags:": "",
        ":part_alternation_mark:": "",
        ":camel:": "",
        ":curry:": "",
        ":steam_locomotive:": "",
        ":hospital:": "",
        ":jp:": "",
        ":large_blue_diamond:": "",
        ":tanabata_tree:": "",
        ":bell:": "",
        ":leo:": "",
        ":gemini:": "",
        ":pear:": "",
        ":large_orange_diamond:": "",
        ":taurus:": "",
        ":globe_with_meridians:": "",
        ":door:": "",
        ":clock6:": "",
        ":oncoming_police_car:": "",
        ":envelope_with_arrow:": "",
        ":closed_umbrella:": "",
        ":saxophone:": "",
        ":church:": "",
        ":woman_biking:": "",
        ":bicyclist:": "",
        ":pisces:": "",
        ":dango:": "",
        ":capricorn:": "",
        ":office:": "",
        ":woman_rowing_boat:": "",
        ":rowboat:": "",
        ":womans_hat:": "",
        ":mans_shoe:": "",
        ":love_hotel:": "",
        ":mount_fuji:": "",
        ":dromedary_camel:": "",
        ":handbag:": "",
        ":hourglass:": "",
        ":negative_squared_cross_mark:": "",
        ":trumpet:": "",
        ":school:": "",
        ":cow2:": "",
        ":cityscape_at_dusk:": "",
        ":woman_construction_worker:": "",
        ":construction_worker:": "",
        ":toilet:": "",
        ":pig2:": "",
        ":grey_question:": "",
        ":beginner:": "",
        ":violin:": "",
        ":on:": "",
        ":credit_card:": "",
        ":id:": "",
        ":secret:": "",
        ":ferris_wheel:": "",
        ":bowling:": "",
        ":libra:": "",
        ":virgo:": "",
        ":barber:": "",
        ":purse:": "",
        ":roller_coaster:": "",
        ":rat:": "",
        ":date:": "",
        ":rugby_football:": "",
        ":ram:": "",
        ":arrow_up_small:": "",
        ":black_square_button:": "",
        ":mobile_phone_off:": "",
        ":tokyo_tower:": "",
        ":congratulations:": "",
        ":kimono:": "",
        ":ru:": "",
        ":ship:": "",
        ":mag_right:": "",
        ":mag:": "",
        ":fire_engine:": "",
        ":clock1130:": "",
        ":police_car:": "",
        ":black_joker:": "",
        ":bridge_at_night:": "",
        ":package:": "",
        ":oncoming_taxi:": "",
        ":calendar:": "",
        ":horse_racing:": "",
        ":tiger2:": "",
        ":boot:": "",
        ":ambulance:": "",
        ":white_square_button:": "",
        ":boar:": "",
        ":school_satchel:": "",
        ":loop:": "",
        ":pound:": "",
        ":information_source:": "",
        ":ox:": "",
        ":rice_ball:": "",
        ":vs:": "",
        ":end:": "",
        ":parking:": "",
        ":sandal:": "",
        ":tent:": "",
        ":seat:": "",
        ":taxi:": "",
        ":black_medium_small_square:": "",
        ":briefcase:": "",
        ":newspaper:": "",
        ":circus_tent:": "",
        ":six_pointed_star:": "",
        ":mens:": "",
        ":european_castle:": "",
        ":flashlight:": "",
        ":foggy:": "",
        ":arrow_double_up:": "",
        ":bamboo:": "",
        ":ticket:": "",
        ":helicopter:": "",
        ":minidisc:": "",
        ":oncoming_bus:": "",
        ":melon:": "",
        ":white_small_square:": "",
        ":european_post_office:": "",
        ":keycap_ten:": "",
        ":notebook:": "",
        ":no_bell:": "",
        ":oden:": "",
        ":flags:": "",
        ":carousel_horse:": "",
        ":blowfish:": "",
        ":chart_with_upwards_trend:": "",
        ":sweet_potato:": "",
        ":ski:": "",
        ":clock12:": "",
        ":signal_strength:": "",
        ":construction:": "",
        ":black_medium_square:": "",
        ":satellite:": "",
        ":euro:": "",
        ":womans_clothes:": "",
        ":ledger:": "",
        ":leopard:": "",
        ":low_brightness:": "",
        ":clock3:": "",
        ":department_store:": "",
        ":truck:": "",
        ":sake:": "",
        ":railway_car:": "",
        ":speedboat:": "",
        ":ko:": "",
        ":vhs:": "",
        ":clock1:": "",
        ":arrow_double_down:": "",
        ":water_buffalo:": "",
        ":arrow_down_small:": "",
        ":yen:": "",
        ":mute:": "",
        ":running_shirt_with_sash:": "",
        ":white_large_square:": "",
        ":wheelchair:": "",
        ":clock2:": "",
        ":paperclip:": "",
        ":atm:": "",
        ":cinema:": "",
        ":telescope:": "",
        ":rice_scene:": "",
        ":blue_book:": "",
        ":white_medium_square:": "",
        ":postbox:": "",
        ":e-mail:": "",
        ":mouse2:": "",
        ":bullettrain_side:": "",
        ":ideograph_advantage:": "",
        ":nut_and_bolt:": "",
        ":ng:": "",
        ":hotel:": "",
        ":wc:": "",
        ":izakaya_lantern:": "",
        ":repeat_one:": "",
        ":mailbox_with_mail:": "",
        ":chart_with_downwards_trend:": "",
        ":green_book:": "",
        ":tractor:": "",
        ":fountain:": "",
        ":metro:": "",
        ":clipboard:": "",
        ":no_mobile_phones:": "",
        ":clock4:": "",
        ":no_smoking:": "",
        ":black_large_square:": "",
        ":slot_machine:": "",
        ":clock5:": "",
        ":bathtub:": "",
        ":scroll:": "",
        ":station:": "",
        ":rice_cracker:": "",
        ":bank:": "",
        ":wrench:": "",
        ":u6307:": "",
        ":articulated_lorry:": "",
        ":page_facing_up:": "",
        ":ophiuchus:": "",
        ":bar_chart:": "",
        ":no_pedestrians:": "",
        ":cn:": "",
        ":vibration_mode:": "",
        ":clock10:": "",
        ":clock9:": "",
        ":bullettrain_front:": "",
        ":minibus:": "",
        ":tram:": "",
        ":clock8:": "",
        ":u7a7a:": "",
        ":traffic_light:": "",
        ":woman_mountain_biking:": "",
        ":mountain_bicyclist:": "",
        ":microscope:": "",
        ":japanese_castle:": "",
        ":bookmark:": "",
        ":bookmark_tabs:": "",
        ":pouch:": "",
        ":ab:": "",
        ":page_with_curl:": "",
        ":flower_playing_cards:": "",
        ":clock11:": "",
        ":fax:": "",
        ":clock7:": "",
        ":white_medium_small_square:": "",
        ":currency_exchange:": "",
        ":sound:": "",
        ":chart:": "",
        ":cl:": "",
        ":floppy_disk:": "",
        ":post_office:": "",
        ":speaker:": "",
        ":japan:": "",
        ":u55b6:": "",
        ":mahjong:": "",
        ":incoming_envelope:": "",
        ":orange_book:": "",
        ":restroom:": "",
        ":u7121:": "",
        ":u6709:": "",
        ":triangular_ruler:": "",
        ":train:": "",
        ":u7533:": "",
        ":trolleybus:": "",
        ":u6708:": "",
        ":input_numbers:": "",
        ":notebook_with_decorative_cover:": "",
        ":u7981:": "",
        ":u6e80:": "",
        ":postal_horn:": "",
        ":factory:": "",
        ":children_crossing:": "",
        ":train2:": "",
        ":straight_ruler:": "",
        ":pager:": "",
        ":accept:": "",
        ":u5408:": "",
        ":lock_with_ink_pen:": "",
        ":clock130:": "",
        ":sa:": "",
        ":outbox_tray:": "",
        ":twisted_rightwards_arrows:": "",
        ":mailbox:": "",
        ":light_rail:": "",
        ":clock930:": "",
        ":busstop:": "",
        ":open_file_folder:": "",
        ":file_folder:": "",
        ":potable_water:": "",
        ":card_index:": "",
        ":clock230:": "",
        ":monorail:": "",
        ":clock1230:": "",
        ":clock1030:": "",
        ":abc:": "",
        ":mailbox_closed:": "",
        ":clock430:": "",
        ":mountain_railway:": "",
        ":do_not_litter:": "",
        ":clock330:": "",
        ":heavy_division_sign:": "",
        ":clock730:": "",
        ":clock530:": "",
        ":capital_abcd:": "",
        ":mailbox_with_no_mail:": "",
        ":symbols:": "",
        ":aerial_tramway:": "",
        ":clock830:": "",
        ":clock630:": "",
        ":abcd:": "",
        ":mountain_cableway:": "",
        ":koko:": "",
        ":passport_control:": "",
        ":non-potable_water:": "",
        ":suspension_railway:": "",
        ":baggage_claim:": "",
        ":no_bicycles:": "",
        ":rainbow_flag:": "",
        ":woman_detective:": "",
        ":detective:": "",
        ":frowning_face:": "",
        ":skull_crossbones:": "",
        ":hugging:": "",
        ":robot:": "",
        ":face_with_headbandage:": "",
        ":thinking:": "",
        ":nerd:": "",
        ":face_with_thermometer:": "",
        ":moneymouth_face:": "",
        ":zipper_mouth:": "",
        ":rolling_eyes:": "",
        ":upside_down:": "",
        ":slight_smile:": "",
        ":slightly_frowning_face:": "",
        ":sign_of_the_horns:": "",
        ":vulcan_salute:": "",
        ":hand_with_fingers_splayed:": "",
        ":writing_hand:": "",
        ":dark_sunglasses:": "",
        ":eye_speachbubble:": "",
        ":eye:": "",
        ":weightlifter_woman_dt:": "",
        ":weightlifter_woman_mdt:": "",
        ":weightlifter_woman_mt:": "",
        ":weightlifter_woman_mlt:": "",
        ":weightlifter_woman_lt:": "",
        ":weightlifter_woman:": "",
        ":weightlifter_dt:": "",
        ":weightlifter_mdt:": "",
        ":weightlifter_mt:": "",
        ":weightlifter_mlt:": "",
        ":weightlifter_lt:": "",
        ":weightlifter:": "",
        ":basketballer_woman_dt:": "",
        ":basketballer_woman_mdt:": "",
        ":basketballer_woman_mt:": "",
        ":basketballer_woman_mlt:": "",
        ":basketballer_woman_lt:": "",
        ":woman_bouncing_ball:": "",
        ":basketballer_lt:": "",
        ":basketballer:": "",
        ":man_in_suit:": "",
        ":golfer:": "",
        ":golfer_woman:": "",
        "*": "*",
        ":heart_exclamation:": "",
        ":star_of_david:": "",
        ":cross:": "",
        ":fleur-de-lis:": "",
        ":atom:": "",
        ":wheel_of_dharma:": "",
        ":yin_yang:": "",
        ":peace:": "",
        ":star_and_crescent:": "",
        ":orthodox_cross:": "",
        ":biohazard:": "",
        ":radioactive:": "",
        ":place_of_worship:": "",
        ":anger_right:": "",
        ":menorah:": "",
        ":om_symbol:": "",
        ":funeral_urn:": "",
        ":coffin:": "",
        ":gear:": "",
        ":alembic:": "",
        ":scales:": "",
        ":crossed_swords:": "",
        ":keyboard:": "",
        ":oil_drum:": "",
        ":shield:": "",
        ":hammer_and_wrench:": "",
        ":bed:": "",
        ":bellhop_bell:": "",
        ":shopping_bags:": "",
        ":sleeping_accommodation:": "",
        ":couch_and_lamp:": "",
        ":ballot_box:": "",
        ":dagger:": "",
        ":rolledup_newspaper:": "",
        ":old_key:": "",
        ":compression:": "",
        ":spiral_calendar:": "",
        ":spiral_notepad:": "",
        ":wastebasket:": "",
        ":file_cabinet:": "",
        ":card_file_box:": "",
        ":card_index_dividers:": "",
        ":framed_picture:": "",
        ":trackball:": "",
        ":computer_mouse:": "",
        ":printer:": "",
        ":desktop_computer:": "",
        ":crayon:": "",
        ":paintbrush:": "",
        ":fountain_pen:": "",
        ":pen:": "",
        ":linked_paperclips:": "",
        ":joystick:": "",
        ":hole:": "",
        ":mantelpiece_clock:": "",
        ":candle:": "",
        ":prayer_beads:": "",
        ":film_projector:": "",
        ":camera_with_flash:": "",
        ":amphora:": "",
        ":label:": "",
        ":flag_black:": "",
        ":flag_white:": "",
        ":film_frames:": "",
        ":control_knobs:": "",
        ":level_slider:": "",
        ":studio_microphone:": "",
        ":thermometer:": "",
        ":passenger_ship:": "",
        ":airplane_arriving:": "",
        ":airplane_departure:": "",
        ":small_airplane:": "",
        ":motor_boat:": "",
        ":railway_track:": "",
        ":motorway:": "",
        ":world_map:": "",
        ":synagogue:": "",
        ":mosque:": "",
        ":kaaba:": "",
        ":stadium:": "",
        ":national_park:": "",
        ":desert_island:": "",
        ":desert:": "",
        ":classical_building:": "",
        ":derelict_house:": "",
        ":cityscape:": "",
        ":houses:": "",
        ":building_construction:": "",
        ":beach_with_umbrella:": "",
        ":camping:": "",
        ":snowcapped_mountain:": "",
        ":racing_car:": "",
        ":motorcycle:": "",
        ":bow_and_arrow:": "",
        ":badminton:": "",
        ":rosette:": "",
        ":ping_pong:": "",
        ":ice_hockey:": "",
        ":field_hockey:": "",
        ":volleyball:": "",
        ":cricket_game:": "",
        ":medal:": "",
        ":admission_tickets:": "",
        ":reminder_ribbon:": "",
        ":military_medal:": "",
        ":cheese_wedge:": "",
        ":popcorn:": "",
        ":champagne:": "",
        ":fork_and_knife_with_plate:": "",
        ":hot_pepper:": "",
        ":burrito:": "",
        ":taco:": "",
        ":hotdog:": "",
        ":shamrock:": "",
        ":comet:": "",
        ":unicorn:": "",
        ":turkey:": "",
        ":scorpion:": "",
        ":lion_face:": "",
        ":crab:": "",
        ":spider_web:": "",
        ":spider:": "",
        ":dove:": "",
        ":chipmunk:": "",
        ":wind_blowing_face:": "",
        ":fog:": "",
        ":tornado:": "",
        ":cloud_with_lightning:": "",
        ":cloud_with_snow:": "",
        ":cloud_with_rain:": "",
        ":sun_behind_rain_cloud:": "",
        ":sun_behind_large_cloud:": "",
        ":sun_behind_small_cloud:": "",
        ":speaking_head:": "",
        ":record_button:": "",
        ":stop_button:": "",
        ":pause_button:": "",
        ":play_pause:": "",
        ":track_previous:": "",
        ":track_next:": "",
        ":beach_umbrella:": "",
        ":chains:": "",
        ":pick:": "",
        ":hammer_and_pick:": "",
        ":timer_clock:": "",
        ":stopwatch:": "",
        ":ferry:": "",
        ":mountain:": "",
        ":shinto_shrine:": "",
        ":ice_skate:": "",
        ":skier:": "",
        ":cloud_with_lightning_and_rain:": "",
        ":rescue_workers_helmet:": "",
        ":flag_ac:": "",
        ":flag_ad:": "",
        ":flag_ae:": "",
        ":flag_af:": "",
        ":flag_ag:": "",
        ":flag_ai:": "",
        ":flag_al:": "",
        ":flag_am:": "",
        ":flag-ao:": "",
        ":flag-aq:": "",
        ":flag-ar:": "",
        ":flag-as:": "",
        ":flag-at:": "",
        ":flag-au:": "",
        ":flag-aw:": "",
        ":flag-ax:": "",
        ":flag-az:": "",
        ":flag-ba:": "",
        ":flag-bb:": "",
        ":flag-bd:": "",
        ":flag-be:": "",
        ":flag-bf:": "",
        ":flag-bg:": "",
        ":flag-bh:": "",
        ":flag-bi:": "",
        ":flag-bj:": "",
        ":flag-bl:": "",
        ":flag-bm:": "",
        ":flag-bn:": "",
        ":flag-bo:": "",
        ":flag-bq:": "",
        ":flag-br:": "",
        ":flag-bs:": "",
        ":flag-bt:": "",
        ":flag-bv:": "",
        ":flag-bw:": "",
        ":flag-by:": "",
        ":flag-bz:": "",
        ":flag-ca:": "",
        ":flag-cc:": "",
        ":flag-cd:": "",
        ":flag-cf:": "",
        ":flag-cg:": "",
        ":flag-ch:": "",
        ":flag-ci:": "",
        ":flag-ck:": "",
        ":flag-cl:": "",
        ":flag-cm:": "",
        ":flag-cn:": "",
        ":flag-co:": "",
        ":flag-cp:": "",
        ":flag-cr:": "",
        ":flag-cu:": "",
        ":flag-cv:": "",
        ":flag-cw:": "",
        ":flag-cx:": "",
        ":flag-cy:": "",
        ":flag-cz:": "",
        ":flag-de:": "",
        ":flag-dg:": "",
        ":flag-dj:": "",
        ":flag-dk:": "",
        ":flag-dm:": "",
        ":flag-do:": "",
        ":flag-dz:": "",
        ":flag-ea:": "",
        ":flag-ec:": "",
        ":flag-ee:": "",
        ":flag-eg:": "",
        ":flag-eh:": "",
        ":flag-er:": "",
        ":flag-es:": "",
        ":flag-et:": "",
        ":flag-eu:": "",
        ":flag-fi:": "",
        ":flag-fj:": "",
        ":flag-fk:": "",
        ":flag-fm:": "",
        ":flag-fo:": "",
        ":flag-fr:": "",
        ":flag-ga:": "",
        ":flag-gb:": "",
        ":flag-gd:": "",
        ":flag-ge:": "",
        ":flag-gf:": "",
        ":flag-gg:": "",
        ":flag-gh:": "",
        ":flag-gi:": "",
        ":flag-gl:": "",
        ":flag-gm:": "",
        ":flag-gn:": "",
        ":flag-gp:": "",
        ":flag-gq:": "",
        ":flag-gr:": "",
        ":flag-gs:": "",
        ":flag-gt:": "",
        ":flag-gu:": "",
        ":flag-gw:": "",
        ":flag-gy:": "",
        ":flag-hk:": "",
        ":flag-hm:": "",
        ":flag-hn:": "",
        ":flag-hr:": "",
        ":flag-ht:": "",
        ":flag-hu:": "",
        ":flag-ic:": "",
        ":flag-id:": "",
        ":flag-ie:": "",
        ":flag-il:": "",
        ":flag-im:": "",
        ":flag-in:": "",
        ":flag-io:": "",
        ":flag-iq:": "",
        ":flag-ir:": "",
        ":flag-is:": "",
        ":flag-it:": "",
        ":flag-je:": "",
        ":flag-jm:": "",
        ":flag-jo:": "",
        ":flag-jp:": "",
        ":flag-ke:": "",
        ":flag-kg:": "",
        ":flag-kh:": "",
        ":flag-ki:": "",
        ":flag-km:": "",
        ":flag-kn:": "",
        ":flag-kp:": "",
        ":flag-kr:": "",
        ":flag-kw:": "",
        ":flag-ky:": "",
        ":flag-kz:": "",
        ":flag-la:": "",
        ":flag-lb:": "",
        ":flag-lc:": "",
        ":flag-li:": "",
        ":flag-lk:": "",
        ":flag-lr:": "",
        ":flag-ls:": "",
        ":flag-lt:": "",
        ":flag-lu:": "",
        ":flag-lv:": "",
        ":flag-ly:": "",
        ":flag-ma:": "",
        ":flag-mc:": "",
        ":flag-md:": "",
        ":flag-me:": "",
        ":flag-mf:": "",
        ":flag-mg:": "",
        ":flag-mh:": "",
        ":flag-mk:": "",
        ":flag-ml:": "",
        ":flag-mm:": "",
        ":flag-mn:": "",
        ":flag-mo:": "",
        ":flag-mp:": "",
        ":flag-mq:": "",
        ":flag-mr:": "",
        ":flag-ms:": "",
        ":flag-mt:": "",
        ":flag-mu:": "",
        ":flag-mv:": "",
        ":flag-mw:": "",
        ":flag-mx:": "",
        ":flag-my:": "",
        ":flag-mz:": "",
        ":flag-na:": "",
        ":flag-nc:": "",
        ":flag-ne:": "",
        ":flag-nf:": "",
        ":flag-ng:": "",
        ":flag-ni:": "",
        ":flag-nl:": "",
        ":flag-no:": "",
        ":flag-np:": "",
        ":flag-nr:": "",
        ":flag-nu:": "",
        ":flag-nz:": "",
        ":flag-om:": "",
        ":flag-pa:": "",
        ":flag-pe:": "",
        ":flag-pf:": "",
        ":flag-pg:": "",
        ":flag-ph:": "",
        ":flag-pk:": "",
        ":flag-pl:": "",
        ":flag-pm:": "",
        ":flag-pn:": "",
        ":flag-pr:": "",
        ":flag-ps:": "",
        ":flag-pt:": "",
        ":flag-pw:": "",
        ":flag-py:": "",
        ":flag-qa:": "",
        ":flag-re:": "",
        ":flag-ro:": "",
        ":flag-rs:": "",
        ":flag-ru:": "",
        ":flag-rw:": "",
        ":flag-sa:": "",
        ":flag-sb:": "",
        ":flag-sc:": "",
        ":flag-sd:": "",
        ":flag-se:": "",
        ":flag-sg:": "",
        ":flag-sh:": "",
        ":flag-si:": "",
        ":flag-sj:": "",
        ":flag-sk:": "",
        ":flag-sl:": "",
        ":flag-sm:": "",
        ":flag-sn:": "",
        ":flag-so:": "",
        ":flag-sr:": "",
        ":flag-ss:": "",
        ":flag-st:": "",
        ":flag-sv:": "",
        ":flag-sx:": "",
        ":flag-sy:": "",
        ":flag-sz:": "",
        ":flag-ta:": "",
        ":flag-tc:": "",
        ":flag-td:": "",
        ":flag-tf:": "",
        ":flag-tg:": "",
        ":flag-th:": "",
        ":flag-tj:": "",
        ":flag-tk:": "",
        ":flag-tl:": "",
        ":flag-tm:": "",
        ":flag-tn:": "",
        ":flag-to:": "",
        ":flag-tr:": "",
        ":flag-tt:": "",
        ":flag-tv:": "",
        ":flag-tw:": "",
        ":flag-tz:": "",
        ":flag-ua:": "",
        ":flag-ug:": "",
        ":flag-um:": "",
        ":flag-us:": "",
        ":flag-uy:": "",
        ":flag-uz:": "",
        ":flag-va:": "",
        ":flag-vc:": "",
        ":flag-ve:": "",
        ":flag-vg:": "",
        ":flag-vi:": "",
        ":flag-vn:": "",
        ":flag_vu:": "",
        ":flag_wf:": "",
        ":flag_ws:": "",
        ":flag_xk:": "",
        ":flag_ye:": "",
        ":flag_yt:": "",
        ":flag_za:": "",
        ":flag_zm:": "",
        ":flag_zw:": "",
        ":black_heart:": "",
        ":speech_left:": "",
        ":egg:": "",
        ":octagonal_sign:": "",
        ":spades:": "",
        ":hearts:": "",
        ":diamonds:": "",
        ":clubs:": "",
        ":drum:": "",
        ":left_right_arrow:": "",
        ":tm:": "",
        ":0:": "0",
        ":1:": "1",
        ":2:": "2",
        ":3:": "3",
        ":4:": "4",
        ":5:": "5",
        ":6:": "6",
        ":7:": "7",
        ":8:": "8",
        ":9:": "9",
        ":hash:": "#",
        ":asterisk:": "*",
        ":zero:": "0",
        ":one:": "1",
        ":two:": "2",
        ":three:": "3",
        ":four:": "4",
        ":five:": "5",
        ":six:": "6",
        ":seven:": "7",
        ":eight:": "8",
        ":nine:": "9",
        ":rolling_on_the_floor_laughing:": "",
        ":smiling_face_with_hearts:": "",
        ":starstruck:": "",
        ":smiling_face:": "",
        ":zany_face:": "",
        ":face_with_hand_over_mouth:": "",
        ":shushing_face:": "",
        ":face_with_raised_eyebrow:": "",
        ":lying_face:": "",
        ":drooling_face:": "",
        ":nauseated_face:": "",
        ":face_vomiting:": "",
        ":sneezing_face:": "",
        ":hot_face:": "",
        ":cold_face:": "",
        ":woozy_face:": "",
        ":exploding_head:": "",
        ":cowboy_hat_face:": "",
        ":partying_face:": "",
        ":face_with_monocle:": "",
        ":pleading_face:": "",
        ":yawning_face:": "",
        ":face_with_symbols_on_mouth:": "",
        ":skull_and_crossbones:": "",
        ":clown_face:": "",
        ":red_heart:": "",
        ":orange_heart:": "",
        ":brown_heart:": "",
        ":white_heart:": "",
        ":eye_in_speech_bubble:": "",
        ":left_speech_bubble:": "",
        ":right_anger_bubble:": "",
        ":raised_back_of_hand:": "",
        ":pinching_hand:": "",
        ":victory_hand:": "",
        ":crossed_fingers:": "",
        ":loveyou_gesture:": "",
        ":call_me_hand:": "",
        ":index_pointing_up:": "",
        ":leftfacing_fist:": "",
        ":rightfacing_fist:": "",
        ":palms_up_together:": "",
        ":handshake:": "",
        ":selfie:": "",
        ":mechanical_arm:": "",
        ":mechanical_leg:": "",
        ":leg:": "",
        ":foot:": "",
        ":ear_with_hearing_aid:": "",
        ":brain:": "",
        ":tooth:": "",
        ":bone:": "",
        ":child:": "",
        ":person:": "",
        ":beard:": "",
        ":light_skin_tone_beard:": "",
        ":mediumlight_skin_tone_beard:": "",
        ":medium_skin_tone_beard:": "",
        ":mediumdark_skin_tone_beard:": "",
        ":dark_skin_tone_beard:": "",
        ":red_hair:": "",
        ":light_skin_tone_red_hair:": "",
        ":mediumlight_skin_tone_red_hair:": "",
        ":medium_skin_tone_red_hair:": "",
        ":mediumdark_skin_tone_red_hair:": "",
        ":dark_skin_tone_red_hair:": "",
        ":curly_hair:": "",
        ":light_skin_tone_curly_hair:": "",
        ":mediumlight_skin_tone_curly_hair:": "",
        ":medium_skin_tone_curly_hair:": "",
        ":mediumdark_skin_tone_curly_hair:": "",
        ":dark_skin_tone_curly_hair:": "",
        ":white_hair:": "",
        ":light_skin_tone_white_hair:": "",
        ":mediumlight_skin_tone_white_hair:": "",
        ":medium_skin_tone_white_hair:": "",
        ":mediumdark_skin_tone_white_hair:": "",
        ":dark_skin_tone_white_hair:": "",
        ":bald:": "",
        ":light_skin_tone_bald:": "",
        ":mediumlight_skin_tone_bald:": "",
        ":medium_skin_tone_bald:": "",
        ":mediumdark_skin_tone_bald:": "",
        ":dark_skin_tone_bald:": "",
        ":older_person:": "",
        ":woman_frowning:": "",
        ":woman_pouting:": "",
        ":woman_gesturing_NO:": "",
        ":woman_gesturing_OK:": "",
        ":woman_tipping_hand:": "",
        ":woman_raising_hand:": "",
        ":deaf_person:": "",
        ":deaf_man:": "",
        ":deaf_woman:": "",
        ":man_bowing:": "",
        ":person_facepalming:": "",
        ":man_facepalming:": "",
        ":woman_facepalming:": "",
        ":person_shrugging:": "",
        ":man_shrugging:": "",
        ":woman_shrugging:": "",
        ":health_worker:": "",
        ":man_health_worker:": "",
        ":woman_health_worker:": "",
        ":student:": "",
        ":man_student:": "",
        ":woman_student:": "",
        ":teacher:": "",
        ":man_teacher:": "",
        ":woman_teacher:": "",
        ":judge:": "",
        ":man_judge:": "",
        ":woman_judge:": "",
        ":farmer:": "",
        ":man_farmer:": "",
        ":woman_farmer:": "",
        ":cook:": "",
        ":man_cook:": "",
        ":woman_cook:": "",
        ":mechanic:": "",
        ":man_mechanic:": "",
        ":woman_mechanic:": "",
        ":factory_worker:": "",
        ":man_factory_worker:": "",
        ":woman_factory_worker:": "",
        ":office_worker:": "",
        ":man_office_worker:": "",
        ":woman_office_worker:": "",
        ":scientist:": "",
        ":man_scientist:": "",
        ":woman_scientist:": "",
        ":technologist:": "",
        ":man_technologist:": "",
        ":woman_technologist:": "",
        ":singer:": "",
        ":man_singer:": "",
        ":woman_singer:": "",
        ":artist:": "",
        ":man_artist:": "",
        ":woman_artist:": "",
        ":pilot:": "",
        ":man_pilot:": "",
        ":woman_pilot:": "",
        ":astronaut:": "",
        ":man_astronaut:": "",
        ":woman_astronaut:": "",
        ":firefighter:": "",
        ":man_firefighter:": "",
        ":woman_firefighter:": "",
        ":man_police_officer:": "",
        ":man_detective:": "",
        ":man_guard:": "",
        ":man_construction_worker:": "",
        ":prince:": "",
        ":man_wearing_turban:": "",
        ":woman_with_headscarf:": "",
        ":man_in_tuxedo:": "",
        ":pregnant_woman:": "",
        ":breastfeeding:": "",
        ":Mrs_Claus:": "",
        ":superhero:": "",
        ":man_superhero:": "",
        ":woman_superhero:": "",
        ":supervillain:": "",
        ":man_supervillain:": "",
        ":woman_supervillain:": "",
        ":mage:": "",
        ":man_mage:": "",
        ":woman_mage:": "",
        ":fairy:": "",
        ":man_fairy:": "",
        ":woman_fairy:": "",
        ":vampire:": "",
        ":man_vampire:": "",
        ":woman_vampire:": "",
        ":merperson:": "",
        ":merman:": "",
        ":mermaid:": "",
        ":elf:": "",
        ":man_elf:": "",
        ":woman_elf:": "",
        ":genie:": "",
        ":man_genie:": "",
        ":woman_genie:": "",
        ":zombie:": "",
        ":man_zombie:": "",
        ":woman_zombie:": "",
        ":woman_getting_massage:": "",
        ":woman_getting_haircut:": "",
        ":man_walking:": "",
        ":person_standing:": "",
        ":man_standing:": "",
        ":woman_standing:": "",
        ":person_kneeling:": "",
        ":man_kneeling:": "",
        ":woman_kneeling:": "",
        ":person_with_probing_cane:": "",
        ":man_with_probing_cane:": "",
        ":woman_with_probing_cane:": "",
        ":person_in_motorized_wheelchair:": "",
        ":man_in_motorized_wheelchair:": "",
        ":woman_in_motorized_wheelchair:": "",
        ":person_in_manual_wheelchair:": "",
        ":man_in_manual_wheelchair:": "",
        ":woman_in_manual_wheelchair:": "",
        ":man_running:": "",
        ":man_dancing:": "",
        ":man_in_suit_levitating:": "",
        ":women_with_bunny_ears:": "",
        ":person_in_steamy_room:": "",
        ":man_in_steamy_room:": "",
        ":woman_in_steamy_room:": "",
        ":person_climbing:": "",
        ":man_climbing:": "",
        ":woman_climbing:": "",
        ":person_fencing:": "",
        ":person_golfing:": "",
        ":man_golfing:": "",
        ":woman_golfing:": "",
        ":man_surfing:": "",
        ":man_rowing_boat:": "",
        ":man_swimming:": "",
        ":person_bouncing_ball:": "",
        ":man_bouncing_ball:": "",
        ":person_lifting_weights:": "",
        ":man_lifting_weights:": "",
        ":woman_lifting_weights:": "",
        ":man_biking:": "",
        ":man_mountain_biking:": "",
        ":person_cartwheeling:": "",
        ":man_cartwheeling:": "",
        ":woman_cartwheeling:": "",
        ":people_wrestling:": "",
        ":men_wrestling:": "",
        ":women_wrestling:": "",
        ":person_playing_water_polo:": "",
        ":man_playing_water_polo:": "",
        ":woman_playing_water_polo:": "",
        ":person_playing_handball:": "",
        ":man_playing_handball:": "",
        ":woman_playing_handball:": "",
        ":person_juggling:": "",
        ":man_juggling:": "",
        ":woman_juggling:": "",
        ":person_in_lotus_position:": "",
        ":man_in_lotus_position:": "",
        ":woman_in_lotus_position:": "",
        ":people_holding_hands:": "",
        ":light_skin_tone_mediumlight_skin_tone:": "",
        ":light_skin_tone_medium_skin_tone:": "",
        ":light_skin_tone_mediumdark_skin_tone:": "",
        ":light_skin_tone_dark_skin_tone:": "",
        ":mediumlight_skin_tone_light_skin_tone:": "",
        ":mediumlight_skin_tone_medium_skin_tone:": "",
        ":mediumlight_skin_tone_medium-dark_skin_tone:": "",
        ":mediumlight_skin_tone_dark_skin_tone:": "",
        ":medium_skin_tone_light_skin_tone:": "",
        ":medium_skin_tone_mediumlight_skin_tone:": "",
        ":medium_skin_tone_mediumdark_skin_tone:": "",
        ":medium_skin_tone_dark_skin_tone:": "",
        ":mediumdark_skin_tone_light_skin_tone:": "",
        ":mediumdark_skin_tone_medium-light_skin_tone:": "",
        ":mediumdark_skin_tone_medium_skin_tone:": "",
        ":mediumdark_skin_tone_dark_skin_tone:": "",
        ":dark_skin_tone_light_skin_tone:": "",
        ":dark_skin_tone_mediumlight_skin_tone:": "",
        ":dark_skin_tone_medium_skin_tone:": "",
        ":dark_skin_tone_mediumdark_skin_tone:": "",
        ":woman_man:": "",
        ":man_man:": "",
        ":man_woman_boy:": "",
        ":gorilla:": "",
        ":orangutan:": "",
        ":guide_dog:": "",
        ":service_dog:": "",
        ":fox:": "",
        ":raccoon:": "",
        ":zebra:": "",
        ":deer:": "",
        ":llama:": "",
        ":giraffe:": "",
        ":rhinoceros:": "",
        ":hippopotamus:": "",
        ":hedgehog:": "",
        ":bat:": "",
        ":sloth:": "",
        ":otter:": "",
        ":skunk:": "",
        ":kangaroo:": "",
        ":badger:": "",
        ":eagle:": "",
        ":duck:": "",
        ":swan:": "",
        ":owl:": "",
        ":flamingo:": "",
        ":peacock:": "",
        ":parrot:": "",
        ":lizard:": "",
        ":sauropod:": "",
        ":TRex:": "",
        ":shark:": "",
        ":butterfly:": "",
        ":cricket:": "",
        ":mosquito:": "",
        ":microbe:": "",
        ":wilted_flower:": "",
        ":mango:": "",
        ":kiwi_fruit:": "",
        ":coconut:": "",
        ":avocado:": "",
        ":potato:": "",
        ":carrot:": "",
        ":cucumber:": "",
        ":leafy_green:": "",
        ":broccoli:": "",
        ":garlic:": "",
        ":onion:": "",
        ":peanuts:": "",
        ":croissant:": "",
        ":baguette_bread:": "",
        ":pretzel:": "",
        ":bagel:": "",
        ":pancakes:": "",
        ":waffle:": "",
        ":cut_of_meat:": "",
        ":bacon:": "",
        ":sandwich:": "",
        ":stuffed_flatbread:": "",
        ":falafel:": "",
        ":shallow_pan_of_food:": "",
        ":bowl_with_spoon:": "",
        ":green_salad:": "",
        ":butter:": "",
        ":salt:": "",
        ":canned_food:": "",
        ":moon_cake:": "",
        ":dumpling:": "",
        ":fortune_cookie:": "",
        ":takeout_box:": "",
        ":lobster:": "",
        ":shrimp:": "",
        ":squid:": "",
        ":oyster:": "",
        ":cupcake:": "",
        ":pie:": "",
        ":glass_of_milk:": "",
        ":clinking_glasses:": "",
        ":tumbler_glass:": "",
        ":cup_with_straw:": "",
        ":beverage_box:": "",
        ":mate:": "",
        ":ice:": "",
        ":chopsticks:": "",
        ":spoon:": "",
        ":compass:": "",
        ":brick:": "",
        ":hindu_temple:": "",
        ":hot_springs:": "",
        ":motor_scooter:": "",
        ":manual_wheelchair:": "",
        ":motorized_wheelchair:": "",
        ":auto_rickshaw:": "",
        ":kick_scooter:": "",
        ":skateboard:": "",
        ":canoe:": "",
        ":parachute:": "",
        ":flying_saucer:": "",
        ":luggage:": "",
        ":sun:": "",
        ":ringed_planet:": "",
        ":wind_face:": "",
        ":umbrella_on_ground:": "",
        ":firecracker:": "",
        ":red_envelope:": "",
        ":1st_place_medal:": "",
        ":2nd_place_medal:": "",
        ":3rd_place_medal:": "",
        ":softball:": "",
        ":flying_disc:": "",
        ":lacrosse:": "",
        ":boxing_glove:": "",
        ":martial_arts_uniform:": "",
        ":goal_net:": "",
        ":diving_mask:": "",
        ":sled:": "",
        ":curling_stone:": "",
        ":yoyo:": "",
        ":kite:": "",
        ":nazar_amulet:": "",
        ":puzzle_piece:": "",
        ":teddy_bear:": "",
        ":chess_pawn:": "",
        ":thread:": "",
        ":yarn:": "",
        ":goggles:": "",
        ":lab_coat:": "",
        ":safety_vest:": "",
        ":scarf:": "",
        ":gloves:": "",
        ":coat:": "",
        ":socks:": "",
        ":sari:": "",
        ":onepiece_swimsuit:": "",
        ":briefs:": "",
        ":shorts:": "",
        ":hiking_boot:": "",
        ":flat_shoe:": "",
        ":ballet_shoes:": "",
        ":billed_cap:": "",
        ":banjo:": "",
        ":abacus:": "",
        ":diya_lamp:": "",
        ":receipt:": "",
        ":ballot_box_with_ballot:": "",
        ":pencil:": "",
        ":axe:": "",
        ":clamp:": "",
        ":balance_scale:": "",
        ":probing_cane:": "",
        ":toolbox:": "",
        ":magnet:": "",
        ":test_tube:": "",
        ":petri_dish:": "",
        ":dna:": "",
        ":drop_of_blood:": "",
        ":adhesive_bandage:": "",
        ":stethoscope:": "",
        ":chair:": "",
        ":razor:": "",
        ":lotion_bottle:": "",
        ":safety_pin:": "",
        ":broom:": "",
        ":basket:": "",
        ":roll_of_paper:": "",
        ":soap:": "",
        ":sponge:": "",
        ":fire_extinguisher:": "",
        ":shopping_cart:": "",
        ":up_arrow:": "",
        ":upright_arrow:": "",
        ":right_arrow:": "",
        ":downright_arrow:": "",
        ":down_arrow:": "",
        ":downleft_arrow:": "",
        ":left_arrow:": "",
        ":upleft_arrow:": "",
        ":updown_arrow:": "",
        ":right_arrow_curving_left:": "",
        ":left_arrow_curving_right:": "",
        ":right_arrow_curving_up:": "",
        ":right_arrow_curving_down:": "",
        ":atom_symbol:": "",
        ":om:": "",
        ":star_of_David:": "",
        ":latin_cross:": "",
        ":peace_symbol:": "",
        ":play_button:": "",
        ":next_track_button:": "",
        ":play_or_pause_button:": "",
        ":reverse_button:": "",
        ":last_track_button:": "",
        ":eject_button:": "",
        ":female_sign:": "",
        ":male_sign:": "",
        ":medical_symbol:": "",
        ":infinity:": "",
        ":recycling_symbol:": "",
        ":fleurde-lis:": "",
        ":check_box_with_check:": "",
        ":check_mark:": "",
        ":multiplication_sign:": "",
        ":eightspoked_asterisk:": "",
        ":eightpointed_star:": "",
        ":double_exclamation_mark:": "",
        ":exclamation_question_mark:": "",
        ":#:": "#",
        ":A_button_blood_type:": "",
        ":B_button_blood_type:": "",
        ":information:": "",
        ":circled_M:": "",
        ":O_button_blood_type:": "",
        ":P_button:": "",
        ":Japanese_service_charge_button:": "",
        ":Japanese_monthly_amount_button:": "",
        ":Japanese_reserved_button:": "",
        ":Japanese_free_of_charge_button:": "",
        ":Japanese_congratulations_button:": "",
        ":Japanese_secret_button:": "",
        ":orange_circle:": "",
        ":yellow_circle:": "",
        ":green_circle:": "",
        ":purple_circle:": "",
        ":brown_circle:": "",
        ":red_square:": "",
        ":orange_square:": "",
        ":yellow_square:": "",
        ":green_square:": "",
        ":blue_square:": "",
        ":white_flag:": "",
        ":pirate_flag:": "",
        ":United_Nations:": "",
        ":England:": "",
        ":Scotland:": "",
        ":wales:": ""
      };
      let Ch = e => {
        let t = `${e}`;
        if (t.length < 2) {
          return `0${t}`;
        } else {
          return t;
        }
      };
      let kh = (e, t) => {
        t(e);
        let i = e.children;
        for (let e in i) {
          kh(i[e], t);
        }
      };
      let Ah = e => {
        let t;
        for (let i = 0, n = e.length; i < n; i++) {
          t = e.charCodeAt(i);
          if ((!(t > 47) || !(t < 58)) && (!(t > 64) || !(t < 91)) && (!(t > 96) || !(t < 123)) && t !== 190 && t !== 46) {
            return false;
          }
        }
        return true;
      };
      let Lh = () => {
        if (window?.CrazyGames?.SDK?.environment === "crazygames") {
          return {
            sid: CrazyGames.SDK.game.getInviteParam("sid"),
            bid: CrazyGames.SDK.game.getInviteParam("bid")
          };
        }
        let e = {};
        window.location.href.replace(/[?&]+([^=&]+)=([^&]*)/gi, (t, i, n) => {
          e[i] = n.replace("#", "");
        });
        return e;
      };
      let Rh = (e, t, i) => {
        let n = Math.round((t.r - e.r) * i + e.r);
        let a = Math.round((t.g - e.g) * i + e.g);
        let r = Math.round((t.b - e.b) * i + e.b);
        return 16777216 + (n < 255 ? n < 1 ? 0 : n : 255) * 65536 + (a < 255 ? a < 1 ? 0 : a : 255) * 256 + (r < 255 ? r < 1 ? 0 : r : 255);
      };
      setInterval(() => {
        Bd();
        ed();
      }, 30000);
      let Ph = e => e * (2 - e);
      let Dh = (e, t, i) => (1 - i) * e + i * t;
      let Ih = e => e === true || e === "true";
      let $h = (e, t) => {
        let i = t.x - e.x;
        let n = t.z - e.z;
        return Math.sqrt(i * i + n * n);
      };
      const zh = e => new THREE.Vector2(-Math.sin(e), -Math.cos(e));
      let Nh = e => {
        if (Object.keys(e).length === 0 && e.constructor === Object) {
          return true;
        }
        for (let t in e) {
          if (e.hasOwnProperty(t) && e[t] !== undefined) {
            return false;
          }
        }
        return true;
      };
      let Oh = function () {
        let e = new THREE.Frustum();
        return (t, i) => t.position !== undefined && (i.updateMatrix(), i.updateMatrixWorld(), e.setFromMatrix(new THREE.Matrix4().multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse)), e.containsPoint(t.position));
      }();
      let Uh = {
        username: undefined,
        password: undefined,
        setCookie: function (e, t, i) {
          let n = new Date();
          n.setTime(n.getTime() + i * 24 * 60 * 60 * 1000);
          let a = `expires=${n.toUTCString()}`;
          document.cookie = `${e}=${t};${a};path=/`;
        },
        getCookie: function (e) {
          let t = document.cookie.split(";");
          for (let i in t) {
            let n = t[i];
            let a = n.split("=")[0];
            let r = n.split("=")[1];
            if (a.trim() === e) {
              return r;
            }
          }
        },
        invalidateCookie: function (e) {
          let t = document.cookie.split(";");
          for (let i in t) {
            let n = t[i].split("=")[0];
            if (n.trim() === e) {
              document.cookie = `${n}=;expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            }
          }
        }
      };
      let Fh = 0;
      let Bh = 0;
      let Hh = () => {
        $("#login-msg").html(`Logged in as <b>${Uh.username}</b>.`);
      };
      let Vh = (e, t) => {
        if (e.message != null) {
          nd.showCenterMessage(e.message, 1, 60000);
        }
        if (e.accountDoesntExist !== true) {
          (e => {
            (async () => {
              let e = null;
              if (oh) {
                try {
                  e = await window.CrazyGames.SDK.user.getUserToken();
                } catch (e) {
                  return console.log("Error:", e);
                }
              }
              let t = {
                url: "/auth/account_game_settings",
                type: "POST",
                data: `token=${e}`
              };
              $.post(t).then(e => {
                if (e.fpMode) {
                  $("#account-fp-mode-button").prop("checked", true);
                  $("#fp-mode-button").prop("checked", true);
                } else {
                  $("#account-fp-mode-button").prop("checked", false);
                  $("#fp-mode-button").prop("checked", false);
                }
                $("#account-fov-control").val(e.fov ?? 10);
                $("#account-fov-control-2").val(typeof e.fov == "number" ? Math.round((e.fov - 10) / 65 * 100) / 100 : 0);
                $("#fov-control").val(e.fov ?? 10);
                $("#fov-control-2").val(typeof e.fov == "number" ? Math.round((e.fov - 10) / 65 * 100) / 100 : 0);
                $("#account-music-control").val(e.musicVolume ?? 50);
                $("#music-control").val(e.musicVolume ?? 50);
                $("#account-sfx-control").val(e.sfxVolume ?? 50);
                $("#sfx-control").val(e.sfxVolume ?? 50);
                if (e.viewSails) {
                  $("#account-view-sails-button").prop("checked", true);
                  $("#view-sails-button").prop("checked", true);
                  Kc = true;
                } else {
                  $("#account-view-sails-button").prop("checked", false);
                  $("#view-sails-button").prop("checked", false);
                  Kc = false;
                }
                if (e.blockNotifications) {
                  $("#account-block-notifications-button").prop("checked", true);
                  $("#block-notifications-button").prop("checked", true);
                  Yc = true;
                } else {
                  $("#account-block-notifications-button").prop("checked", false);
                  $("#block-notifications-button").prop("checked", false);
                  Yc = false;
                }
                if (e.showAllies) {
                  $("#account-show-allies-on-minimap-button").prop("checked", true);
                  $("#show-allies-on-minimap-button").prop("checked", true);
                  ch = true;
                } else {
                  $("#account-show-allies-on-minimap-button").prop("checked", false);
                  $("#show-allies-on-minimap-button").prop("checked", false);
                  ch = false;
                }
                $("#account-quality-list").val(e.qualityMode ?? 2);
                $("#quality-list").val(e.qualityMode ?? 2);
                Fh = e.hatModel ?? 0;
                Bh = e.playerModel ?? 4;
                if (!e.errors) {
                  $("#account-game-settings-save-notice").removeClass("hidden");
                }
                if ($("#fp-mode-button").is(":checked")) {
                  $("#fp-mode-text").removeClass("lock-text-info").addClass("lock-text-error").text("FP Camera (Enabled)");
                } else {
                  $("#fp-mode-text").removeClass("lock-text-error").addClass("lock-text-info").text("FP Camera (Disabled)");
                }
                if ($("#view-sails-button").is(":checked")) {
                  $("#view-sails-text").removeClass("lock-text-info").addClass("lock-text-error").text("View Sails (Enabled)");
                } else {
                  $("#view-sails-text").removeClass("lock-text-error").addClass("lock-text-info").text("View Sails (Disabled)");
                }
                Hc = document.getElementById("fov-control").value >= 10 && document.getElementById("fov-control").value <= 100 ? document.getElementById("fov-control").value / 10 : 1;
                Ud.updateMusicVolume();
                Eh();
              }).catch(e => {
                $("#account-fp-mode-button").prop("checked", false);
                $("#fp-mode-button").prop("checked", false);
                $("#account-fov-control").val(10);
                $("#account-fov-control-2").val(0);
                $("#fov-control").val(10);
                $("#fov-control-2").val(0);
                $("#account-music-control").val(50);
                $("#music-control").val(50);
                $("#account-sfx-control").val(50);
                $("#sfx-control").val(50);
                $("#account-quality-list").val(2);
                $("#quality-list").val(2);
                $("#account-view-sails-button").prop("checked", false);
                $("#view-sails-button").prop("checked", false);
                Kc = false;
                $("#account-block-notifications-button").prop("checked", false);
                $("#block-notifications-button").prop("checked", false);
                Yc = false;
                if ($("#fp-mode-button").is(":checked")) {
                  $("#fp-mode-text").removeClass("lock-text-info").addClass("lock-text-error").text("FP Camera (Enabled)");
                } else {
                  $("#fp-mode-text").removeClass("lock-text-error").addClass("lock-text-info").text("FP Camera (Disabled)");
                }
                if ($("#view-sails-button").is(":checked")) {
                  $("#view-sails-text").removeClass("lock-text-info").addClass("lock-text-error").text("View Sails (Enabled)");
                } else {
                  $("#view-sails-text").removeClass("lock-text-error").addClass("lock-text-info").text("View Sails (Disabled)");
                }
                Hc = document.getElementById("fov-control").value >= 10 && document.getElementById("fov-control").value <= 100 ? document.getElementById("fov-control").value / 10 : 1;
                Ud.updateMusicVolume();
                Eh();
              });
            })();
            Uh.username = e.isLoggedIn ? e.username : undefined;
            Uh.password = e.isLoggedIn ? e.password : undefined;
            if (Uh.username === undefined) {
              $("#login-btn").prop("disabled", false).prop("hidden", false);
              $("#login-btn").on("click", () => {
                $("#login-box").modal("show");
              });
              $("#open-register").on("click", () => {
                $("#login-box").modal("hide");
                $("#register-box").modal("show");
                $("#register-error").addClass("hidden");
              });
              $("#open-login").on("click", () => {
                $("#register-box").modal("hide");
                $("#login-box").modal("show");
                $("#login-error").addClass("hidden");
              });
              $("#open-reset-password").on("click", () => {
                $("#login-box").modal("hide");
                $("#reset-password-box").modal("show");
                $("#reset-password-error").addClass("hidden");
              });
              $("#submit-login").on("click", e => {
                e.preventDefault();
                $("#submit-login").attr("disabled", true);
                $("#login-error").addClass("hidden");
                $.ajax({
                  type: "post",
                  url: "/auth/login",
                  data: $("#login-form").serialize()
                }).then(e => e.errors ? ($("#submit-login").attr("disabled", false), $("#login-error").removeClass("hidden"), $("#login-err-msg").text(e.errors), false) : e.success ? ($("#submit-login").attr("disabled", false), $("#login-box").modal("hide"), window.location.reload(), true) : undefined);
              });
              $("#submit-register").on("click", e => {
                e.preventDefault();
                $("#submit-register").attr("disabled", true);
                $("#register-error").addClass("hidden");
                $.ajax({
                  type: "post",
                  url: "/auth/register",
                  data: $("#register-form").serialize()
                }).then(e => {
                  if (e.errors) {
                    $("#submit-register").attr("disabled", false);
                    $("#register-error").removeClass("hidden");
                    $("#register-err-msg").text(e.errors);
                    grecaptcha.reset();
                    return false;
                  }
                  if (e.success) {
                    $("#register-success-msg").text(e.success);
                    $("#register-success").removeClass("hidden");
                    setTimeout(() => {
                      $("#register-box").modal("hide");
                      if (navigator.credentials) {
                        let e = new PasswordCredential($("#register-form"));
                        navigator.credentials.store(e);
                        window.location.reload();
                        return true;
                      }
                    }, 10000);
                  }
                });
              });
            } else if (Uh.username !== undefined) {
              Uh.setCookie("username", e.username, 1);
              Uh.setCookie("password", e.password, 1);
              Hh();
              $("#settings-btn").prop("disabled", false).prop("hidden", false);
              $("#customize-btn").prop("disabled", false).prop("hidden", false);
              if (e.crazyGames) {
                $("#logout-btn-2").prop("hidden", true);
                $("#reset-password-button").prop("hidden", true);
              } else {
                $("#logout-btn").prop("disabled", false).prop("hidden", false);
              }
              $("#login-btn").prop("disabled", true).prop("hidden", true);
              $("#settings-btn").on("click", () => {
                $("#manage-account-box").modal("show");
              });
              $("#username-edit-button").on("click", () => {
                $("#change-username").removeClass("hidden");
                $("#change-username-error").addClass("hidden");
                $("#change-username-button-container").addClass("hidden");
                $("#change-email").addClass("hidden");
                $("#change-email-error").addClass("hidden");
                $("#change-email-button-container").removeClass("hidden");
                $("#change-account-game-settings").addClass("hidden");
                $("#change-account-game-settings-error").addClass("hidden");
                $("#change-account-game-settings-button-container").removeClass("hidden");
                $("#change-default-krew-name").addClass("hidden");
                $("#change-default-krew-name-error").addClass("hidden");
                $("#change-default-krew-name-button-container").removeClass("hidden");
              });
              $("#email-edit-button").on("click", () => {
                $("#change-username").addClass("hidden");
                $("#change-username-error").addClass("hidden");
                $("#change-username-button-container").removeClass("hidden");
                $("#change-email").removeClass("hidden");
                $("#change-email-error").addClass("hidden");
                $("#change-email-button-container").addClass("hidden");
                $("#change-account-game-settings").addClass("hidden");
                $("#change-account-game-settings-error").addClass("hidden");
                $("#change-account-game-settings-button-container").removeClass("hidden");
                $("#change-default-krew-name").addClass("hidden");
                $("#change-default-krew-name-error").addClass("hidden");
                $("#change-default-krew-name-button-container").removeClass("hidden");
              });
              $("#change-account-game-settings-button").on("click", () => {
                $("#change-username").addClass("hidden");
                $("#change-username-error").addClass("hidden");
                $("#change-username-button-container").removeClass("hidden");
                $("#change-email").addClass("hidden");
                $("#change-email-error").addClass("hidden");
                $("#change-email-button-container").removeClass("hidden");
                $("#change-account-game-settings").removeClass("hidden");
                $("#change-account-game-settings-error").addClass("hidden");
                $("#change-account-game-settings-button-container").addClass("hidden");
                $("#change-default-krew-name").addClass("hidden");
                $("#change-default-krew-name-error").addClass("hidden");
                $("#change-default-krew-name-button-container").removeClass("hidden");
              });
              $("#change-default-krew-name-button").on("click", () => {
                $("#change-username").addClass("hidden");
                $("#change-username-error").addClass("hidden");
                $("#change-username-button-container").removeClass("hidden");
                $("#change-email").addClass("hidden");
                $("#change-email-error").addClass("hidden");
                $("#change-email-button-container").removeClass("hidden");
                $("#change-account-game-settings").addClass("hidden");
                $("#change-account-game-settings-error").addClass("hidden");
                $("#change-account-game-settings-button-container").removeClass("hidden");
                $("#change-default-krew-name").removeClass("hidden");
                $("#change-default-krew-name-error").addClass("hidden");
                $("#change-default-krew-name-button-container").addClass("hidden");
              });
              $("#customize-btn").on("click", () => {
                $("#hat-model-image").attr("src", `/assets/img/hats/hat${Fh}.png`);
                const [e, t, i] = Uc[Bh];
                $("#player-model-image").attr("src", `/assets/img/dogs/${e}/${t}/${i}.png`);
                $("#customization-box").modal("show");
                $("#customization-error").addClass("hidden");
              });
              $("#customization-button-2").on("click", () => {
                $("#hat-model-image").attr("src", `/assets/img/hats/hat${Fh}.png`);
                const [e, t, i] = Uc[Bh];
                $("#player-model-image").attr("src", `/assets/img/dogs/${e}/${t}/${i}.png`);
                $("#manage-account-box").modal("hide");
                $("#customization-box").modal("show");
                $("#customization-error").addClass("hidden");
              });
              $("#reset-password-button").on("click", () => {
                $("#manage-account-box").modal("hide");
                $("#reset-password-box").modal("show");
                $("#reset-password-error").addClass("hidden");
              });
              $("#delete-account-button").on("click", () => {
                $("#manage-account-box").modal("hide");
                $("#delete-account-box").modal("show");
                $("#delete-account-error").addClass("hidden");
              });
              $("#account-fov-control").on("input", () => {
                let e = document.getElementById("account-fov-control").value;
                document.getElementById("account-fov-control-2").value = Math.round((e - 10) / 65 * 100) / 100;
              });
              $("#account-fov-control-2").on("input", () => {
                let e = Math.min(1, Math.max(0, document.getElementById("account-fov-control-2").value));
                document.getElementById("account-fov-control").value = e * 65 + 10;
              });
              $("#submit-change-username").on("click", async e => {
                e.preventDefault();
                $("#submit-change-username").attr("disabled", true);
                $("#change-username-error").addClass("hidden");
                let t = null;
                if (oh) {
                  try {
                    t = await window.CrazyGames.SDK.user.getUserToken();
                  } catch (e) {
                    return console.log("Error:", e);
                  }
                }
                let i = t == null ? $("#change-username-form").serialize() : `${$("#change-username-form").serialize()}&token=${t}`;
                $.ajax({
                  type: "post",
                  url: "/auth/change_username",
                  data: i
                }).then(e => e.errors ? ($("#submit-change-username").attr("disabled", false), $("#change-username-error").removeClass("hidden"), $("#change-username-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
              });
              $("#submit-change-email").on("click", e => {
                e.preventDefault();
                $("#submit-change-email").attr("disabled", true);
                $("#change-email-error").addClass("hidden");
                $.ajax({
                  type: "post",
                  url: "/auth/change_email",
                  data: $("#change-email-form").serialize()
                }).then(e => e.errors ? ($("#submit-change-email").attr("disabled", false), $("#change-email-error").removeClass("hidden"), $("#change-email-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
              });
              $("#submit-change-account-game-settings").on("click", async e => {
                e.preventDefault();
                $("#submit-change-account-game-settings").attr("disabled", true);
                $("#change-account-game-settings-error").addClass("hidden");
                let t = null;
                if (oh) {
                  try {
                    t = await window.CrazyGames.SDK.user.getUserToken();
                  } catch (e) {
                    return console.log("Error:", e);
                  }
                }
                let i = t == null ? $("#change-account-game-settings-form").serialize() : `${$("#change-account-game-settings-form").serialize()}&token=${t}`;
                $.ajax({
                  type: "post",
                  url: "/auth/change_account_game_settings",
                  data: i
                }).then(e => e.errors ? ($("#submit-change-account-game-settings").attr("disabled", false), $("#change-account-game-settings-error").removeClass("hidden"), $("#change-account-game-settings-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
              });
              $("#submit-change-default-krew-name").on("click", async e => {
                e.preventDefault();
                $("#submit-change-default-krew-name").attr("disabled", true);
                $("#change-default-krew-name-error").addClass("hidden");
                let t = null;
                if (oh) {
                  try {
                    t = await window.CrazyGames.SDK.user.getUserToken();
                  } catch (e) {
                    return console.log("Error:", e);
                  }
                }
                let i = t == null ? $("#change-default-krew-name-form").serialize() : `${$("#change-default-krew-name-form").serialize()}&token=${t}`;
                $.ajax({
                  type: "post",
                  url: "/auth/change_default_krew_name",
                  data: i
                }).then(e => e.errors ? ($("#submit-change-default-krew-name").attr("disabled", false), $("#change-default-krew-name-error").removeClass("hidden"), $("#change-default-krew-name-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
              });
              $("#hat-model-left").on("click", () => {
                Fh--;
                if (Fh < 0) {
                  Fh = 3;
                }
                $("#hat-model-image").attr("src", `/assets/img/hats/hat${Fh}.png`);
              });
              $("#hat-model-right").on("click", () => {
                Fh++;
                if (Fh > 3) {
                  Fh = 0;
                }
                $("#hat-model-image").attr("src", `/assets/img/hats/hat${Fh}.png`);
              });
              $("#player-model-image").attr("src", `/assets/img/dogs/${Uc[0][0]}/${Uc[0][1]}/${Uc[0][2]}.png`);
              $("#player-model-left").on("click", () => {
                Bh--;
                if (Bh < 0) {
                  Bh = Uc.length - 1;
                }
                const [e, t, i] = Uc[Bh];
                $("#player-model-image").attr("src", `/assets/img/dogs/${e}/${t}/${i}.png`);
              });
              $("#player-model-right").on("click", () => {
                Bh++;
                if (Bh > Uc.length - 1) {
                  Bh = 0;
                }
                if (Bh < 0) {
                  Bh = Uc.length - 1;
                }
                const [e, t, i] = Uc[Bh];
                $("#player-model-image").attr("src", `/assets/img/dogs/${e}/${t}/${i}.png`);
              });
              $("#submit-customization").on("click", async e => {
                e.preventDefault();
                $("#submit-customization").attr("disabled", true);
                $("#customization-error").addClass("hidden");
                let t = null;
                if (oh) {
                  try {
                    t = await window.CrazyGames.SDK.user.getUserToken();
                  } catch (e) {
                    return console.log("Error:", e);
                  }
                }
                let i = {
                  playerModel: Bh.toString(),
                  hatModel: Fh.toString()
                };
                if (t != null) {
                  i.token = t;
                }
                $.ajax({
                  type: "post",
                  url: "/auth/customization",
                  data: i
                }).then(e => e.errors ? ($("#submit-customization").attr("disabled", false), $("#customization-error").removeClass("hidden"), $("#customization-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
              });
              $("#submit-delete-account").on("click", e => {
                e.preventDefault();
                $("#submit-delete-account").attr("disabled", true);
                $("#delete-account-error").addClass("hidden");
                $.ajax({
                  type: "post",
                  url: "/auth/delete_account",
                  data: $("#delete-account-form").serialize()
                }).then(e => {
                  if (e.errors) {
                    $("#submit-delete-account").attr("disabled", false);
                    $("#delete-account-error").removeClass("hidden");
                    $("#delete-account-err-msg").text(e.errors);
                    return false;
                  }
                  if (e.success) {
                    window.location.reload();
                  }
                });
              });
            }
            $("#submit-reset-password").on("click", e => {
              e.preventDefault();
              $("#submit-reset-password").attr("disabled", true);
              $("#reset-password-error").addClass("hidden");
              $.ajax({
                type: "post",
                url: "/auth/reset_password",
                data: $("#reset-password-form").serialize()
              }).then(e => e.errors ? ($("#submit-reset-password").attr("disabled", false), $("#reset-password-error").removeClass("hidden"), $("#reset-password-err-msg").text(e.errors), false) : e.success ? (window.location.reload(), true) : undefined);
            });
          })(e);
        } else {
          $.ajax({
            type: "post",
            url: "/auth/crazyRegister",
            data: `token=${t}`
          }).then(e => {
            if (e.success) {
              Gh();
            }
          });
        }
      };
      let Gh = async e => {
        if (typeof e != "string" && (e = await (async () => {
          if (window?.CrazyGames?.SDK?.environment !== "crazygames" || window?.CrazyGames?.SDK?.user?.isUserAccountAvailable === false) {
            $("#merch-btn").attr("hidden", false);
            $("#remove-gap").attr("hidden", false);
            return;
          }
          $("#merch-btn").attr("hidden", true);
          if ((await window.CrazyGames.SDK.user.getUser()) == null) {
            $("#login-btn").attr("hidden", false);
            $("#login-btn").text("Login with CrazyGames");
            return new Promise(e => {
              $("#login-btn").off("click").on("click", async () => {
                try {
                  if ((await window.CrazyGames.SDK.user.showAuthPrompt()) == null) {
                    return e("stop");
                  }
                } catch (t) {
                  console.log("Error:", t);
                  return e("stop");
                }
              });
            });
          }
          let e = null;
          try {
            e = await window.CrazyGames.SDK.user.getUserToken();
          } catch (e) {
            return console.log("Error:", e);
          }
          if (e != null) {
            oh = true;
          }
          return e;
        })()) === "stop") {
          return;
        }
        let t = {
          type: "post",
          url: "/auth/authenticated"
        };
        if (typeof e == "string") {
          t.data = `token=${e}`;
        }
        $.ajax(t).then(t => Vh(t, e));
      };
      let Wh = false;
      window.initAuth = () => {
        if (!Wh && window?.CrazyGames?.SDK?.environment === "crazygames" && window?.CrazyGames?.SDK?.user?.isUserAccountAvailable !== false) {
          CrazyGames.SDK.user.addAuthListener(async e => {
            if (hc) {
              location.reload();
              if (gc) {
                gc.disconnect();
              }
              return nd.showCenterMessage("You must reload the page to continue playing", 1, 6000000);
            }
            let t = null;
            try {
              t = await window.CrazyGames.SDK.user.getUserToken();
            } catch (e) {
              return console.log("Error:", e);
            }
            Gh(t);
          });
          Wh = true;
        }
        if (Uh.getCookie("username") && Uh.getCookie("token")) {
          Uh.username = Uh.getCookie("username");
          Hh();
        } else {
          Gh();
        }
      };
      $("#login-btn").on("click", async () => {
        if (window?.CrazyGames?.SDK?.environment === "crazygames" && window?.CrazyGames?.SDK?.user?.isUserAccountAvailable !== false) {
          initAuth();
        }
      });
      let qh = () => {
        $("#chat-message").on("keyup", () => {
          let e = Jl.Admins.includes(hc.name) || Jl.Mods.includes(hc.name) || Jl.Helpers.includes(hc.name);
          if (e) {
            $("#chat-message").prop("maxlength", 1000);
          }
          if ($("#chat-message").val().trim().length > (e ? 1000 : 150)) {
            $("#chat-message").val($("#chat-message").val().slice(0, e ? 1000 : 150));
          }
        });
        $("#chat-message").on("keypress", e => {
          if (e.keyCode === 13) {
            if (!(e => {
              if (!e.startsWith("/") || !e.includes(" ")) {
                return false;
              }
              var [t, i] = e.split(" ");
              i = i.toLowerCase();
              if (t === "/block") {
                if (!fh.includes(i)) {
                  fh.push(i);
                }
                return true;
              }
              if (t === "/unblock") {
                const e = fh.indexOf(i);
                if (e !== -1) {
                  fh.splice(e, 1);
                }
                return true;
              }
              return false;
            })($("#chat-message").val())) {
              gc.emit("chat message", {
                message: $("#chat-message").val(),
                recipient: eh ? "local" : Qc ? "clan" : Jc ? "staff" : Zc ? "alliance" : "global"
              });
            }
            $("#chat-message").val("").focus();
          }
        });
        $("#chat-global").on("click", () => {
          jh();
        });
        $("#chat-local").on("click", () => {
          Xh();
        });
        $("#chat-clan").on("click", () => {
          Yh();
        });
        $("#chat-alliance").on("click", () => {
          Kh();
        });
        $("#chat-staff").on("click", () => {
          Jh();
        });
      };
      let jh = () => {
        $("#chat-global").addClass("active");
        $("#chat-local").removeClass("active");
        $("#chat-clan").removeClass("active");
        $("#chat-staff").removeClass("active");
        $("#chat-alliance").removeClass("active");
        $(".global-chat").show();
        $(".local-chat").hide();
        $(".clan-chat").hide();
        $(".alliance-chat").hide();
        $(".staff-chat").hide();
        Jc = false;
        Qc = false;
        Zc = false;
        eh = false;
        th = true;
        $("#global-chat-alert").hide();
      };
      let Xh = () => {
        $("#chat-global").removeClass("active");
        $("#chat-clan").removeClass("active");
        $("#chat-alliance").removeClass("active");
        $("#chat-local").addClass("active");
        $("#chat-staff").removeClass("active");
        $(".global-chat").hide();
        $(".local-chat").show();
        $(".clan-chat").hide();
        $(".alliance-chat").hide();
        $(".staff-chat").hide();
        Jc = false;
        Qc = false;
        Zc = false;
        eh = true;
        th = false;
        $("#local-chat-alert").hide();
      };
      let Kh = () => {
        $("#chat-global").removeClass("active");
        $("#chat-local").removeClass("active");
        $("#chat-clan").removeClass("active");
        $("#chat-staff").removeClass("active");
        $("#chat-alliance").addClass("active");
        $(".global-chat").hide();
        $(".local-chat").hide();
        $(".alliance-chat").show();
        $(".clan-chat").hide();
        $(".staff-chat").hide();
        Jc = false;
        Zc = true;
        Qc = false;
        eh = false;
        th = false;
        $("#alliance-chat-alert").hide();
      };
      let Yh = () => {
        $("#chat-global").removeClass("active");
        $("#chat-local").removeClass("active");
        $("#chat-clan").addClass("active");
        $("#chat-staff").removeClass("active");
        $("#chat-alliance").removeClass("active");
        $(".global-chat").hide();
        $(".local-chat").hide();
        $(".alliance-chat").hide();
        $(".clan-chat").show();
        $(".staff-chat").hide();
        Jc = false;
        Qc = true;
        Zc = false;
        eh = false;
        th = false;
        $("#clan-chat-alert").hide();
      };
      let Jh = () => {
        $("#chat-global").removeClass("active");
        $("#chat-local").removeClass("active");
        $("#chat-clan").removeClass("active");
        $("#chat-alliance").removeClass("active");
        $("#chat-staff").addClass("active");
        $(".alliance-chat").hide();
        $(".global-chat").hide();
        $(".local-chat").hide();
        $(".clan-chat").hide();
        $(".staff-chat").show();
        Jc = true;
        Qc = false;
        Zc = false;
        eh = false;
        th = false;
        $("#staff-chat-alert").hide();
      };
      let Zh = () => {
        ic.scrollTop = dc;
        dc += 0.25;
        _c = ic.scrollTop >= ic.scrollHeight - ic.offsetHeight;
      };
      ic = document.querySelector("#chat-history");
      _c = false;
      ic.scrollTop = 0;
      dc = 0;
      fc = setInterval(Zh, 1);
      ic.addEventListener("mouseover", () => {
        clearInterval(fc);
      });
      ic.addEventListener("mouseout", () => {
        dc = ic.scrollTop;
        fc = setInterval(Zh, 1);
      });
      let Qh = {
        keys: {
          53: "fireRate",
          54: "distance",
          55: "damage"
        },
        getList: () => {
          Qh.removeListeners().clearStore().setStore(() => {
            Qh.setContent().setListeners();
          });
        },
        removeListeners: () => {
          if (_h.$html !== undefined) {
            _h.$html.children().off();
            _h.$html.off();
          }
          return Qh;
        },
        clearStore: () => {
          Object.assign(_h, {
            $html: undefined,
            points: {},
            originalPoints: 0,
            availablePoints: 0,
            usedPoints: 0,
            allocatedPoints: {},
            pointsTr: {},
            experience: hc ? hc.experience : 0
          });
          return Qh;
        },
        setStore: e => {
          if (gc?.connected) {
            gc.emit("getExperiencePoints", (t, i) => {
              if (!t) {
                Object.assign(_h, i);
                if (hc) {
                  hc.experience = i.experience;
                  hc.points = i.points;
                }
                for (let e in _h.points) {
                  _h.allocatedPoints[e] = 0;
                }
                _h.originalPoints = _h.availablePoints;
                if (e && e.call) {
                  e(_h);
                }
              }
            });
          }
        },
        setContent: () => {
          $("<div/>").append(Qh.getPointsList());
          if (_h.originalPoints === 0) {
            $("<div/>").find(".btn-allocate-points").attr("disabled", true);
          }
          _h.$html = $("<div/>");
          _h.$shoppingList.html(_h.$html);
          return Qh;
        },
        setListeners: () => {
          $("input[type=range]").each(function () {
            inputRange($(this));
          });
          for (let e in _h.pointsTr) {
            Qh.setInputRangeListeners(_h.pointsTr[e], e);
          }
          _h.$html.find(".btn-allocate-points").one("click", e => {
            e.preventDefault();
            Qh.allocatePoints(() => {
              Qh.getList();
            });
          });
          return Qh;
        },
        allocatePoints: (e, t) => {
          gc.emit("allocatePoints", e, e => {
            if (e === true) {
              t();
            }
          });
        },
        setInputRangeListeners: (e, t) => {
          let i = e.find("input");
          i.on("change input", () => {
            Qh.updateAvailablePoints();
            let e = parseInt(i.val()) - _h.points[t];
            if (e <= 0) {
              e = 0;
            }
            if (e > _h.allocatedPoints[t] + _h.availablePoints) {
              e = _h.allocatedPoints[t] + _h.availablePoints;
            }
            if (_h.availablePoints <= 0 && e >= _h.allocatedPoints[t]) {
              e = _h.allocatedPoints[t];
            }
            _h.allocatedPoints[t] = e;
            e += _h.points[t];
            i.val(e);
            updateInputRange(i);
            Qh.updateAvailablePoints();
            _h.$html.find("h6").html(`Available points: ${_h.originalPoints}<span class="float-right">Points left: ${_h.availablePoints}</span>`);
            ed();
          }).trigger("change");
        },
        updateAvailablePoints: () => {
          _h.usedPoints = 0;
          for (let e in _h.allocatedPoints) {
            _h.usedPoints += _h.allocatedPoints[e];
          }
          _h.availablePoints = _h.originalPoints - _h.usedPoints;
          return Qh;
        },
        getPointsList: () => {
          let e;
          let t;
          let i = "";
          i += "<div>";
          i += `    <h6>Available points: ${_h.originalPoints}<span class="float-right">Points left: ${_h.availablePoints}</span></h6>`;
          i += "    <table class=\"table table-sm\">";
          i += "        <thead><tr><th>Name</th><th>Quantity</th></tr></thead>";
          i += "        <tbody></tbody>";
          i += "    </table>";
          i += "    <button class=\"btn btn-primary float-right btn-allocate-points\">Allocate points</button>";
          i += "</div>";
          e = $(i);
          t = e.find("tbody");
          for (let e in _h.points) {
            let i = "";
            i += "<tr>";
            i += `    <td>${e}</td>`;
            i += "    <td>";
            i += "        <div class=\"range-group\">";
            i += `            <input type="range" min="0" max="50" step="1" value="${_h.points[e]}">`;
            i += "            <output></output>";
            i += "        </div>";
            i += "    </td>";
            i += "</tr>";
            _h.pointsTr[e] = $(i);
            t.append(_h.pointsTr[e]);
          }
          return e;
        },
        checkButtonTab: () => {
          Qh.clearStore().setStore(e => {
            if (e.originalPoints > 0) {
              $("#experience-points").show(0);
            } else {
              $("#experience-points").hide(0);
            }
          });
        }
      };
      let ed = () => {
        $(".level-up-button").off();
        Qh.clearStore().setStore(e => {
          if (e.originalPoints > 0) {
            $(".level-up-button").show(0);
            $(".level-up-button").one("click", function () {
              e.allocatedPoints[$(this).attr("data-attribute")] = 1;
              Qh.allocatePoints(() => {
                ed();
              });
            });
          }
          if (e.originalPoints <= 0) {
            $(".level-up-button").hide(0);
          }
          let t = hc?.experience;
          if (t == null) {
            return;
          }
          let i = parseInt(hc.level);
          let n = i + 1;
          let a = hc.experienceNeededForLevels[i].total;
          let r = hc.experienceNeededForLevels[n].total;
          let s = Math.min(100, parseInt((t - a) / (r - a) * 100));
          $("#experience-bar").attr("data-info", `Level ${i}`);
          $("#fireRatePoints").html(hc.points.fireRate);
          $("#damagePoints").html(hc.points.damage);
          $("#distancePoints").html(hc.points.distance);
          if (hc?.itemId != null && typeof hc?.itemId == "number" && yc[hc?.itemId] != null) {
            let e = yc.find(e => e.id == hc?.itemId);
            $("#fireRateItemPoints").html(`+${e.attributes.attackSpeed || 0}`);
            $("#damageItemPoints").html(`+${e.attributes.attackDamage || 0}`);
            $("#distanceItemPoints").html(`+${e.attributes.attackDistance || 0}`);
          } else {
            $("#fireRateItemPoints").html("+0");
            $("#damageItemPoints").html("+0");
            $("#distanceItemPoints").html("+0");
          }
          if (i === hc.experienceMaxLevel) {
            $("#experience-bar").find("div").attr("style", "width: 100%");
          } else {
            $("#experience-bar").find("div").attr("style", `width: ${s}%`);
          }
        });
      };
      let td = e => {
        if (window?.CrazyGames?.SDK?.environment === "crazygames") {
          window.CrazyGames.SDK.game.gameplayStop();
        }
        nc.unLockMouseLook();
        $(".local-chat").remove();
        $("#game-over-modal").show();
        id(e);
        hc.state = 1;
      };
      let id = e => {
        $("#gold-cut").html((e * 0.3).toFixed(0));
        if ($("#docking-modal").is(":visible")) {
          $("#docking-modal").hide();
        }
      };
      let nd = {
        showCenterMessage: function (e, t, i, n = "") {
          if (Yc) {
            return;
          }
          let a = "";
          switch (t) {
            case undefined:
              a = "info";
              break;
            case 1:
              a = "danger";
              break;
            case 3:
              a = "success";
              break;
            case 4:
              a = "info";
          }
          Eo.notify({
            title: n,
            description: e,
            closeTimeout: i ?? 10000,
            position: "top-center",
            animationOpen: "slide-in",
            animationClose: "fade-out",
            type: a,
            imageVisible: true,
            imageCustom: `../assets/img/notifications/${a}-new.png`
          });
        },
        showAdminMessage: function (e) {
          if (!Yc) {
            Eo.notify({
              title: "Admin Message",
              description: e,
              closeTimeout: 16000,
              position: "top-center",
              animationOpen: "slide-in",
              animationClose: "fade-out",
              type: "info",
              imageVisible: true,
              imageCustom: "../assets/img/notifications/info-new.png"
            });
          }
        },
        showKillMessage: function (e) {
          if (!Yc) {
            Eo.notify({
              description: e,
              closeTimeout: 5000,
              position: "top-right",
              animationOpen: "slide-in",
              animationClose: "fade-out",
              type: "danger",
              imageVisible: true,
              imageCustom: "../assets/img/notifications/explosion.png"
            });
          }
        },
        showDamageMessage: function (e, t) {
          let i;
          switch (t) {
            case undefined:
            case 1:
              i = "#a94442";
              break;
            case 2:
              i = "#3c763d";
          }
          let n = $("<div/>", {
            class: "text-xs-center",
            text: e,
            style: `color: ${i}`
          }).delay(3000).fadeOut("slow");
          if ($("#center-div div").length > 3) {
            $("#center-div div:last-child").remove();
          }
          $("#center-div").prepend(n);
        }
      };
      let ad = () => {
        let e = +$("#make-deposit").val();
        let t = parseInt($("#my-deposits").text()) + e;
        if (e <= hc.gold && t <= 150000) {
          gc.emit("bank", {
            deposit: e,
            adBlockEnabled: jc
          });
          Ud.playAudioFile(false, false, 1, "deposit");
          $("#make-deposit").val("").focus();
          $("#successMakeDepoMess").show();
          $("#errorMakeDepoMess").hide();
          $("#successTakeDepoMess").hide();
          $("#errorTakeDepoMess").hide();
          $("#errorFullDepoMess").hide();
        } else if (t > 150000) {
          $("#errorFullDepoMess").show();
          $("#successMakeDepoMess").hide();
          $("#errorMakeDepoMess").hide();
          $("#successTakeDepoMess").hide();
          $("#errorTakeDepoMess").hide();
        } else {
          $("#errorMakeDepoMess").show();
          $("#successMakeDepoMess").hide();
          $("#successTakeDepoMess").hide();
          $("#errorTakeDepoMess").hide();
          $("#errorFullDepoMess").hide();
        }
      };
      let rd = () => {
        let e = +$("#take-deposit").val();
        if (e <= +$("#my-deposits").text()) {
          gc.emit("bank", {
            takedeposit: e,
            adBlockEnabled: jc
          });
          $("#take-deposit").val("").focus();
          $("#successTakeDepoMess").show();
          $("#successMakeDepoMess").hide();
          $("#errorMakeDepoMess").hide();
          $("#errorTakeDepoMess").hide();
          $("#errorFullDepoMess").hide();
        } else {
          $("#errorTakeDepoMess").show();
          $("#successTakeDepoMess").hide();
          $("#successMakeDepoMess").hide();
          $("#errorMakeDepoMess").hide();
          $("#errorFullDepoMess").hide();
        }
      };
      let sd = {
        setClanData: function (e) {
          if (hc.clan !== "" && hc.clan !== undefined) {
            $("#li-clan-chat").show();
          } else {
            $("#li-clan-chat").hide();
          }
          if (hc.alliance !== "" && hc.alliance !== undefined) {
            $("#li-alliance-chat").show();
          } else {
            $("#li-alliance-chat").hide();
          }
          if (hc.clan !== undefined && hc.clan !== "" || hc.clanRequest && hc.clanRequest !== "") {
            if (hc.clanRequest && hc.clanRequest !== "") {
              $("#clan-name").text("You already requested to join a clan");
              $("#yes-clan").hide();
              $("#no-clan").hide();
              $("#request-clan").show();
              let e = $("#player-request-table");
              let t = "<tr><th>Request</th><th>Action</th></tr>";
              e.html(t);
              let i = `<tr><td>${hc.clanRequest}</td><td><div data-tooltip="Cancel request" data-tooltip-location="bottom" style="display: inline-block"><i data-event="cancel-request" class="icofont icofont-close btn btn-danger clan-button"></i></div></td></tr>`;
              e.append(i);
            } else {
              if ($("#clan-name")[0]?.innerHTML == null) {
                $("#clan-name").text(`Your clan: [${hc.clan}]`);
              }
              $("#yes-clan").show();
              $("#request-clan").hide();
              $("#no-clan").hide();
              $("#request-clan-button").hide();
              if (!$("#yes-clan").is(":visible") || e === "force") {
                gc.emit("clan", "get-data", e => {
                  $("#clan-name").text(`Your clan: [${hc.clan}] Members: ${e.clanMembers.length}`);
                  let t = $("#clan-table");
                  let i = `<tr><th>Player name</th><th>Clan Role</th>${hc.clanLeader === true || hc.clanOwner === true ? "<th>Action</th>" : ""}</tr>`;
                  t.html(i);
                  for (let i in e.clanLeader) {
                    let n;
                    n = e.clanLeader[i] === e.clanOwner ? `<tr><td>${e.clanLeader[i]}</td><td>Owner</td></tr>` : `<tr><td>${e.clanLeader[i]}</td><td>Leader</td>${hc.clanOwner === true ? `<td><div data-tooltip="Demote to a clan member" data-tooltip-location="top" style="display: inline-block"><i data-event="demote-clan" data-id="${e.clanLeader[i]}" class="icofont icofont-arrow-down btn btn-success clan-button"></i></div><div data-tooltip="Kick from clan" data-tooltip-location="top" style="display: inline-block"><i data-event="kick-clan" data-id="${e.clanLeader[i]}" class="icofont icofont-delete btn btn-danger clan-button"></i></div></td>` : ""}</tr>`;
                    t.append(n);
                  }
                  for (let i in e.clanMembers) {
                    if (!e.clanLeader.includes(e.clanMembers[i])) {
                      let n = `<tr><td>${e.clanMembers[i]}</td><td>Member</td>${hc.clanOwner === true ? `<td><div data-tooltip="Promote to clan leader" data-tooltip-location="top" style="display: inline-block"><i data-event="promote-clan" data-id="${e.clanMembers[i]}" class="icofont icofont-arrow-up btn btn-success clan-button"></i></div><div data-tooltip="Kick from clan" data-tooltip-location="top" style="display: inline-block"><i data-event="kick-clan" data-id="${e.clanMembers[i]}" class="icofont icofont-delete btn btn-danger clan-button"></i></div></td>` : hc.clanLeader === true ? `<td><div data-tooltip="Kick from clan" data-tooltip-location="top" style="display: inline-block"><i data-event="kick-clan" data-id="${e.clanMembers[i]}" class="icofont icofont-delete btn btn-danger clan-button"></i></div></td>` : ""}</tr>`;
                      t.append(n);
                    }
                  }
                  let n = $("#request-clan-button");
                  if ((hc.clanLeader === true || hc.clanOwner === true) && ($("#request-clan-button").show(), n.show(), e.clanRequests)) {
                    if (e.clanRequests.length > 0) {
                      n.removeClass("btn-warning disabled").addClass("btn-success").text(`View requests (${e.clanRequests.length})`).attr("disabled", false);
                    } else if (e.clanRequests.length === 0) {
                      n.removeClass("btn-success").addClass("btn-warning disabled").text(`View requests (${e.clanRequests.length})`).prop("disabled", true);
                    }
                    let t = $("#clan-request-table");
                    let i = "<tr><th>Player name</th><th>Action</th></tr>";
                    t.html(i);
                    for (let i in e.clanRequests) {
                      let n = `<tr><td>${e.clanRequests[i]}<td><div data-tooltip="Accept request" data-tooltip-location="bottom" style="display: inline-block"><i data-event="accept-request" data-id="${e.clanRequests[i]}" class="icofont icofont-check btn btn-success clan-button"></i></div><div data-tooltip="Reject request" data-tooltip-location="bottom" style="display: inline-block"><i data-event="decline-request" data-id="${e.clanRequests[i]}" class="icofont icofont-close btn btn-danger clan-button"></i></div></td></tr>`;
                      t.append(n);
                    }
                  }
                });
              }
            }
          } else {
            $("#clan-name").text("You don't have any clan yet");
            $("#yes-clan").hide();
            $("#request-clan").hide();
            $("#no-clan").show();
            sd.hideAllClanErrors();
          }
        },
        hideAllClanErrors: function () {
          $("#errorInput").hide();
          $("#errorLength").hide();
          $("#error404").hide();
          $("#errorExists").hide();
          $("#errorUndefined").hide();
          $("#errorUnauthorized").hide();
        }
      };
      let od = {
        setAllianceData: e => {
          if (hc.clan !== "" && hc.clan !== undefined) {
            $("#li-clan-chat").show();
          } else {
            $("#li-clan-chat").hide();
          }
          if (hc.alliance !== "" && hc.alliance !== undefined) {
            $("#li-alliance-chat").show();
          } else {
            $("#li-alliance-chat").hide();
          }
          if (hc.clan !== undefined && hc.clan !== "" && hc.clanOwner) {
            if (hc.alliance === undefined || hc.alliance === "") {
              $("#alliance-name").text("You don't have any alliance yet.");
              $("#yes-alliance").hide();
              $("#request-alliance").hide();
              $("#no-alliance").show();
              return od.hideAllAllianceErrors();
            } else {
              $("#clan-name").text(`Your alliance: [${hc.alliance}]`);
              $("#yes-alliance").show();
              $("#request-alliance").hide();
              $("#no-alliance").hide();
              if (hc.allianceOwner) {
                $("#request-alliance-button").show();
                $("#request-alliance-button").removeClass("hidden");
              }
              if (!$("#yes-clan").is(":visible") || e === "force") {
                gc.emit("alliance", {
                  id: "get-data"
                }, e => {
                  if (e.name == hc.name) {
                    hc.allianceOwner = true;
                  } else {
                    hc.allianceOwner = false;
                  }
                  if (e.clans.includes(hc.clan)) {
                    hc.alliance = e.name;
                  }
                  $("#alliance-name").text(`Your alliance: [${hc.alliance}] Members: ${e.clans.length}`);
                  let t = $("#alliance-table");
                  let i = `<tr><th>Clan name</th><th>Alliance Role</th>${hc.allianceOwner ? "<th>Action</th>" : ""}</tr>`;
                  t.html(i);
                  for (let i in e.clans) {
                    let n = `<tr><td>[${e.clans[i]}]</td><td>${e.clans[i] == e.name ? "Owner" : "Member"}</td>${hc.allianceOwner && hc.clan != e.clans[i] ? `<td><div data-tooltip="Kick from alliance" data-tooltip-location="top" style="display: inline-block"><i data-event="kick-alliance" data-id="${e.clans[i]}" class="icofont icofont-delete btn btn-danger alliance-button"></i></div></td>` : ""}</tr>`;
                    t.append(n);
                  }
                });
              }
              return;
            }
          } else {
            $("#alliance-name").text("You aren't a clan owner.");
            $("#yes-alliance").hide();
            $("#request-alliance").hide();
            $("#no-alliance").hide();
            return od.hideAllAllianceErrors();
          }
        },
        hideAllAllianceErrors: () => {
          $("#errorInput-alliance").hide();
          $("#errorLength-alliance").hide();
          $("#errorInput-invite-alliance").hide();
          $("#errorLength-invite-alliance").hide();
          $("#error404-alliance").hide();
          $("#errorExists-alliance").hide();
          $("#errorUndefined-alliance").hide();
          $("#errorUnauthorized-alliance").hide();
        }
      };
      (function (e) {
        let t = {
          boats: []
        };
        let i = {
          boats: () => function (e) {
            let t;
            let i = [];
            if (typeof wc == "object" && wc !== null) {
              for (let e in wc) {
                t = wc[e];
                if (hc && t && t.anchorIslandId && (t.shipState === 3 || t.shipState === 2 || t.shipState === -1 || t.shipState === 4) && t.recruiting === true && (hc.parent.netType === 1 && t.anchorIslandId === hc.parent.anchorIslandId || t.anchorIslandId === hc.parent.id)) {
                  i.push(t);
                  $("#docked-krews-count").html(i.length);
                }
              }
            }
            i.sort((e, t) => e.departureTime === t.departureTime ? e.id < t.id ? -1 : e.id === t.id ? 0 : 1 : e.departureTime - t.departureTime);
            if (i.length === 0) {
              $("#toggle-krew-list-modal-button").popover("hide");
            }
            return {
              boats: i
            };
          }
        };
        let n = (e, t) => To("div", {}, [To("table", {
          class: "table table-sm"
        }, [To("thead", {
          class: "thead-inverse"
        }, [To("tr", {}, [To("th", {}, "Krew Name"), To("th", {}, "Capacity"), To("th")])]), To("tbody", {}, e.boats.map(e => {
          if (hc !== undefined && hc.parent !== undefined && e !== undefined && wc[e.captainId] !== undefined) {
            e.id;
            $(document).on("click", `#${e.id}`, () => {
              let t = e.id;
              if (wc[t] !== undefined && wc[t].maxKrewCapacity !== wc[t].krewCount && wc[t].captainId !== Fc) {
                gc.emit("joinKrew", t, e => {
                  if (e === 0) {
                    $("#exit-island-button").hide();
                    $("#toggle-invite-link-button").hide();
                    $("#invite-div").hide();
                    if ($("#departure-modal").is(":visible")) {
                      $("#departure-modal").hide();
                    }
                    $("#krew-hud").show();
                    $("#abandon-ship-button").show();
                  }
                });
              }
            });
            return To("tr", {
              key: e.id
            }, [To("td", {}, [`${e.crewName}(${Zl[e.shipclassId].name})`, To("br"), To("small", {}, e.shipState === 4 ? `Departing in ${Math.round(e.departureTime)} seconds` : "")]), To("td", {}, `${e.krewCount}/${Zl[e.shipclassId].maxKrewCapacity}`), To("td", {}, e.id === hc.parent.id ? "My Krew" : To("button", {
              id: e.id,
              class: "btn btn-primary btn-md",
              role: "button",
              disabled: wc[e.id] === undefined || wc[e.id].maxKrewCapacity === wc[e.id].krewCount || wc[e.id].captainId === Fc
            }, "Join"))]);
          }
        }))])]);
        e.KREWLISTCOMPONENT = Co(t, i, n, document.querySelector("#krews-list"));
        e.DEPARTINGKREWLISTCOMPONENT = Co(t, i, n, document.querySelector("#departing-krews-list"));
      })(window);
      let ld = ((e, t) => {
        e = e || 5;
        let i = performance.now();
        let n = performance.now();
        return function () {
          i = performance.now();
          if (i - n > 1000 / e) {
            n = i;
            requestAnimationFrame(t.bind(this));
          }
        };
      })(2, () => {
        KREWLISTCOMPONENT.boats();
        DEPARTINGKREWLISTCOMPONENT.boats();
      });
      let cd = {
        getList: () => {
          cd.removeListeners().clearStore().setStore(() => {
            cd.setContent().setListeners();
          });
        },
        removeListeners: () => {
          if (_h.$html !== undefined) {
            _h.$html.children().off();
            _h.$html.off();
          }
          return cd;
        },
        clearStore: () => {
          Object.assign(_h, {
            goodsPrice: {},
            goods: {},
            cargo: 0,
            cargoUsed: 0,
            gold: 0,
            $html: undefined,
            inventory: {},
            stock: {}
          });
          return cd;
        },
        setStore: e => {
          if (hc && hc.parent && (hc.parent.netType === 5 || hc.parent.shipState !== 1 && hc.parent.shipState !== 0)) {
            gc.emit("getGoodsStore", (t, i) => {
              if (!t) {
                Object.assign(_h, i);
              }
              if (e && e.call) {
                e();
              }
            });
          }
        },
        setContent: () => {
          let e = $("<div class=\"stock d-flex\"/>");
          if (Object.keys(_h.goodsPrice).length === 0 && hc.parent && hc.parent.netType !== 1) {
            e.append("<div class=\"col-xs-12 trading\"><h5 class=\"text-warning\">You must own a ship, or join a krew before buying supplies</h5></div>");
          }
          if (Object.keys(_h.goodsPrice).length > 0) {
            e.append(cd.getInventory());
            e.append(cd.getGoods());
          }
          _h.$html = e;
          _h.$shoppingList.html(_h.$html);
          return cd;
        },
        setListeners: () => {
          $("input[type=range]").each(function () {
            inputRange($(this));
          });
          for (let e in _h.inventory) {
            cd.setInputRangeListeners(_h.inventory[e], e, "sell");
          }
          for (let e in _h.stock) {
            cd.setInputRangeListeners(_h.stock[e], e, "buy");
          }
          return cd;
        },
        setInputRangeListeners: (e, t, i) => {
          let n = e.find(`.btn-${i}`);
          let a = e.find(".ui-slider");
          let r = a.find(".ui-slider-handle");
          let s = {
            create: function () {
              r.text(a.slider("value"));
            },
            slide: function (e, a) {
              r.text(a.value);
              let s = +a.value * _h.goodsPrice[t];
              let o = i === "sell" ? "+" : "-";
              n.html((s > 0 ? o : "") + s);
            }
          };
          if (i === "sell") {
            s.max = _h.goods[t];
          }
          if (i === "buy") {
            let e = parseInt(_h.gold / _h.goodsPrice[t]);
            let i = (_h.cargo - _h.cargoUsed) / Ql[t].cargoSpace;
            if (e > i) {
              e = i;
            }
            e = Math.floor(e);
            s.max = e;
          }
          a.slider(s);
          n.one("click", e => {
            e.preventDefault();
            if (a.slider("value") > 0) {
              gc.emit("buy-goods", {
                quantity: a.slider("value"),
                action: i,
                good: t
              }, (e, t) => {
                if (!e) {
                  hc.gold = t.gold;
                  hc.goods = t.goods;
                }
                cd.getList();
              });
            }
          });
        },
        getInventory: () => {
          let e;
          let t;
          let i = "";
          i += "<div class=\"col-xs-12 col-sm-6 trading\">";
          i += `    <h6>Your ship's cargo ${_h.cargoUsed}/${_h.cargo}</h6>`;
          i += "    <table class=\"table table-sm\">";
          i += "        <thead><tr><th>Name</th><th>Quantity</th><th></th><th>Sell</th></tr></thead>";
          i += "        <tbody></tbody>";
          i += "    </table>";
          i += "    <br>";
          i += "</div>";
          e = $(i);
          t = e.find("tbody");
          for (let e in _h.goods) {
            if (_h.goods[e] > 0 && _h.goodsPrice[e] !== undefined) {
              let i = "";
              i += "<tr>";
              i += "    <td>";
              i += `        ${e}`;
              i += `        <label>$${_h.goodsPrice[e]} each</label>`;
              i += `        <label>${Ql[e].cargoSpace} cargo</label>`;
              i += "    </td>";
              i += "    <td>";
              i += "        <div class=\"ui-slider\" style=\"margin-top: 10px\">";
              i += "            <div class=\"ui-slider-handle\" style=\"width: 3em;height: 1.6em;top: 50%;margin-top: -.8em;text-align: center;line-height: 1.6em;\"></div>";
              i += "        </div>";
              i += "    </td>";
              i += `    <td style="padding-top: 5px">${_h.goods[e]}</td>`;
              i += "    <td>";
              i += "        <button class=\"btn btn-success btn-sm btn-sell\">0</button>";
              i += "    </td>";
              i += "</tr>";
              _h.inventory[e] = $(i);
              t.append(_h.inventory[e]);
            }
          }
          return e;
        },
        getGoods: () => {
          let e;
          let t;
          let i = "";
          i += "<div class=\"col-xs-12 col-sm-6 trading\">";
          i += "    <h6>Merchant</h6>";
          i += "    <table class=\"table table-sm\">";
          i += "        <thead><tr><th>Name</th><th>Quantity</th><th></th><th>Buy</th></tr></thead>";
          i += "        <tbody></tbody>";
          i += "    </table>";
          i += "    <br>";
          i += "</div>";
          e = $("<div class=\"col-xs-12 col-sm-6 trading\">    <h6>Merchant</h6>    <table class=\"table table-sm\">        <thead><tr><th>Name</th><th>Quantity</th><th></th><th>Buy</th></tr></thead>        <tbody></tbody>    </table>    <br></div>");
          t = e.find("tbody");
          for (let e in _h.goodsPrice) {
            if (_h.goods[e] !== undefined) {
              let i = parseInt(_h.gold / _h.goodsPrice[e]);
              let n = (_h.cargo - _h.cargoUsed) / Ql[e].cargoSpace;
              let a = "";
              if (i > n) {
                i = n;
              }
              i = Math.floor(i);
              a += "<tr>";
              a += "    <td>";
              a += `        ${e}`;
              a += `        <label>$${_h.goodsPrice[e]} each</label>`;
              a += `        <label>${Ql[e].cargoSpace} cargo</label>`;
              a += "    </td>";
              a += "    <td>";
              a += "        <div class=\"ui-slider\" style=\"margin-top: 10px\">";
              a += "            <div class=\"ui-slider-handle\" style=\"width: 3em;height: 1.6em;top: 50%;margin-top: -.8em;text-align: center;line-height: 1.6em;\"></div>";
              a += "        </div>";
              a += "    </td>";
              a += `    <td style="padding-top: 5px">${i}</td>`;
              a += "    <td>";
              a += "        <button class=\"btn btn-success btn-sm btn-buy\">0</button>";
              a += "    </td>";
              a += "</tr>";
              _h.stock[e] = $(a);
              t.append(_h.stock[e]);
            }
          }
          return e;
        }
      };
      let hd = e => {
        if (hc.parent.shipState !== 1 && hc.parent.shipState !== 0) {
          gc.emit("getItems", (t, i) => {
            if (t) {
              return;
            }
            let n = $("<div/>");
            let a = "<table class=\"table\">";
            a += "<thead class=\"thead-inverse\">";
            a += "<tr>";
            a += "<th> Item Name </th>";
            a += "<th> Description </th>";
            a += "<th> Price </th>";
            a += "<th> Buy Item </th>";
            a += "</tr>";
            a += "</thead>";
            a += "<tbody></tbody>";
            a += "</table>";
            let r = $("<table class=\"table\"><thead class=\"thead-inverse\"><tr><th> Item Name </th><th> Description </th><th> Price </th><th> Buy Item </th></tr></thead><tbody></tbody></table>");
            let s = r.find("tbody");
            for (let e in i) {
              let t = i[e];
              let n = "<tr>";
              n += `<td>${t.name}</td>`;
              n += `<td>${t.Description}</td>`;
              n += `<td>${t.price}</td>`;
              n += "<td></td>";
              n += "</tr>";
              let a = $(n);
              s.append(a);
              let r = $("<button/>", {
                id: t.id,
                class: "btn btn-primary btn-sm",
                role: "button",
                disabled: hc && hc.itemId === t.id || t.purchasable !== true,
                html: hc && hc.itemId === t.id ? "Equipped" : "Buy"
              }).on("click", function () {
                let e = $(this).attr("id");
                gc.emit("purchase", {
                  type: 1,
                  id: e
                }, e => {
                  if (e === "16") {
                    ed();
                    $("#shopping-modal").hide();
                  }
                });
              });
              a.find("td").eq(3).append(r);
            }
            n.append(r);
            if (typeof e == "function") {
              e(n);
            }
          });
        }
      };
      let dd = e => {
        if (hc && hc?.parent?.shipState !== 1 && hc?.parent?.shipState !== 0) {
          gc.emit("getShips", (t, i) => {
            if (t) {
              return;
            }
            let n = $("<div/>", {
              style: "font-size: 15px;text-align: center;"
            });
            let a = "<table class=\"table ship-table\">";
            a += "<thead class=\"thead-inverse\">";
            a += "<tr>";
            a += "<th> Ship Image </th>";
            a += "<th> Ship Type </th>";
            a += "<th> HP</th>";
            a += "<th> Regen</th>";
            a += "<th> Max Capacity </th>";
            a += "<th> Max Cargo </th>";
            a += "<th> Speed </th>";
            a += "<th> Price </th>";
            a += "<th> Buy </th>";
            a += "</tr>";
            a += "</thead>";
            a += "<tbody></tbody>";
            a += "</table>";
            let r = $("<table class=\"table ship-table\"><thead class=\"thead-inverse\"><tr><th> Ship Image </th><th> Ship Type </th><th> HP</th><th> Regen</th><th> Max Capacity </th><th> Max Cargo </th><th> Speed </th><th> Price </th><th> Buy </th></tr></thead><tbody></tbody></table>");
            let s = r.find("tbody");
            for (let e in i) {
              let t = i[e];
              let n = "<tr>";
              n += `<td ${typeof t?.specialInfo == "string" ? `data-tooltip="${t.specialInfo}" data-tooltip-location="right" style="font-weight: 700;" ` : "data-tooltip=\"This ship has no special bonuses.\" data-tooltip-location=\"right\" style=\"font-weight: 700;\""}>${t.image}</td>`;
              n += `<td>${t.name}</td>`;
              n += `<td>${t.hp}</td>`;
              n += `<td>${t.regeneration}</td>`;
              n += `<td>${t.maxKrewCapacity}</td>`;
              n += `<td>${t.cargoSize}</td>`;
              n += `<td>${t.speed}</td>`;
              n += `<td>${t.price}</td>`;
              n += "<td></td>";
              n += "</tr>";
              let a = $(n);
              s.append(a);
              let r = $("<button/>", {
                id: t.id,
                class: "btn btn-primary btn-sm",
                role: "button",
                disabled: hc.parent !== undefined && t.id == hc.parent.shipclassId && hc.parent.captainId === Fc || !t.purchasable,
                html: hc.parent !== undefined && t.id == hc.parent.shipclassId && hc.parent.captainId === Fc ? "Purchased" : "Buy"
              }).on("click", function () {
                if ($("#abandon-existing-krew").is(":visible")) {
                  $("#abandon-existing-krew").hide();
                }
                let e = $(this).attr("id");
                if (hc !== undefined) {
                  hc.position.x = 0;
                  hc.position.z = 0;
                }
                gc.emit("purchase", {
                  type: 0,
                  id: e
                }, e => {
                  if (["01", "02", "03", "04", "05", "06", "09"].includes(e)) {
                    $("#shopping-modal").hide();
                    $("#completed-quest-table").append($("#other-quest-2").last());
                    $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    $("#other-quest-3").show();
                  }
                  if (["07", "08", "010", "011", "012", "013", "014", "015", "016", "017", "018"].includes(e)) {
                    $("#shopping-modal").hide();
                    $("#completed-quest-table").append($("#other-quest-3").last());
                    $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    $("#other-quest-4").show();
                  }
                  if (["019", "020", "021"].includes(e)) {
                    $("#shopping-modal").hide();
                    $("#completed-quest-table").append($("#other-quest-4").last());
                    $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    $("#other-quest-5").show();
                  }
                  if (["022", "023"].includes(e)) {
                    $("#shopping-modal").hide();
                    $("#completed-quest-table").append($("#other-quest-5").last());
                    $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                  }
                });
                $("#krew-hud").show();
                if (hc !== undefined && hc.parent !== undefined && hc.parent.netType !== 1) {
                  $("#raft-shop-div").hide();
                  if (!bd.hideSuggestionBox) {
                    $("#toggle-shop-modal-button").popover("show");
                  }
                }
              });
              a.find("td").eq(8).append(r);
            }
            n.append(r);
            if (typeof e == "function") {
              e(n);
            }
          });
        }
      };
      let ud = (e = false) => {
        if (window?.CrazyGames?.SDK?.environment === "crazygames") {
          if (e) {
            return Promise.resolve();
          } else {
            return new Promise((e, t) => {
              const i = {
                adFinished: () => {
                  console.log("End midgame ad");
                  Ud?.updateMusicVolume();
                  lh = false;
                  e();
                },
                adError: t => {
                  console.log("Error midgame ad", t);
                  Ud?.updateMusicVolume();
                  lh = false;
                  e();
                },
                adStarted: () => {
                  console.log("Start midgame ad");
                  nc?.unLockMouseLook();
                  Ud?.turnOffMusic();
                  lh = true;
                  ih = false;
                  nh = false;
                  ah = false;
                  rh = false;
                  sh = false;
                }
              };
              window.CrazyGames.SDK.ad.requestAd("midgame", i);
            });
          }
        }
        if (window.adplayerCentered !== undefined) {
          window.adplayerCentered.startPreRoll();
        } else if (typeof aipPlayer == "undefined") {
          console.warn("[ADS]: Ad loader has not initialized yet. Skipping video ad.");
        } else {
          console.log("[ADS]: Ad loader failed to initialize. Skipping video ad.");
        }
      };
      const pd = () => {
        window.requestAnimationFrame(() => {
          const e = performance.now();
          while ($c.length > 0 && $c[0] <= e - 1000) {
            $c.shift();
          }
          $c.push(e);
          pd();
        });
      };
      pd();
      setInterval(() => {
        document.querySelector("#fps-wrapper > span").innerHTML = `${$c.length} FPS`;
      }, 1000);
      let md = () => {
        $("#toggle-shop-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button");
        $("#toggle-krew-list-modal-button").removeClass("btn btn-md disabled toggle-krew-list-modal-button").addClass("btn btn-md enabled toggle-krew-list-modal-button");
        if (wc[hc?.parent?.anchorIslandId]?.name === "Labrador") {
          $("#toggle-bank-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
        }
        bd.closeAllPagesExcept("#shopping-modal");
        nc.unLockMouseLook();
        fd();
        ld();
      };
      setInterval(() => {
        (() => {
          ++Wc;
          $("#seconds").html(Ch(Wc % 60));
          $("#minutes").html(Ch(parseInt(Wc % 3600 / 60)));
          $("#hours").html(Ch(parseInt(Wc / 3600)));
          if (hc && hc.parent) {
            if (hc.parent.shipState === -1 || hc.parent.shipState === 3) {
              $("#docking-modal-button").removeClass("btn btn-primary disabled btn-lg").addClass("btn btn-primary enabled btn-lg");
              $(".port-name").text(wc[hc.parent.anchorIslandId].name);
              $("#docking-modal-button").find("span").text("Countdown...");
              $("#cancel-exit-button").find("span").text("Sail (c)");
              return;
            }
            if (hc.parent.netType === 5) {
              $(".port-name").text(hc.parent.name);
              if ($("#docking-modal").is(":visible")) {
                $("#docking-modal").hide();
                md();
              }
            }
            if ($("#docking-modal").hasClass("initial")) {
              $("#docking-modal").removeClass("initial").find("#you-are-docked-message").remove();
            }
            if (hc.parent.shipState !== 1) {
              Bc = 10;
            }
            if (hc.parent.shipState === 1) {
              $("#cancel-exit-button").find("span").text("Cancel (c)");
              if (Bc !== 0 && Bc > 0) {
                $("#docking-modal-button").find("span").text(`Docking in ${Bc} seconds`);
              } else {
                $("#docking-modal-button").find("span").text("Dock (z)");
                $("#docking-modal-button").removeClass("btn btn-primary disabled btn-lg").addClass("btn btn-primary enabled btn-lg");
              }
              Bc--;
            }
            if (hc.parent.shipState === 4) {
              $("#docking-modal").hide();
              if (!$("#departure-modal").is(":visible")) {
                $("#departure-modal").show(0);
              }
              $("#cancel-departure-button").find("span").text((hc && hc.isCaptain ? "Departing in " : "Krew departing in ") + wc[hc.id].parent.departureTime + " seconds");
            }
            if ((!hc.isCaptain && hc.parent.shipState !== 4 || hc.isCaptain && hc.parent.shipState === 0) && $("#departure-modal").is(":visible")) {
              $("#departure-modal").hide();
            }
          }
        })();
      }, 1000);
      let fd = () => {
        $("#shopping-item-list").html("");
        if ($("#buy-items").hasClass("active")) {
          if ($("#abandon-existing-krew").is(":visible")) {
            $("#abandon-existing-krew").hide();
          }
          hd(e => $("#shopping-item-list").html(e));
          return;
        } else if ($("#buy-ships").hasClass("active")) {
          if (hc !== undefined && hc.parent !== undefined && hc.parent.captainId !== hc.id && hc.parent.netType === 1) {
            $("#abandon-existing-krew").show();
          }
          dd(e => $("#shopping-item-list").html(e));
          return;
        } else {
          if ($("#buy-goods").hasClass("active")) {
            if ($("#abandon-existing-krew").is(":visible")) {
              $("#abandon-existing-krew").hide();
            }
            cd.getList();
          }
          return;
        }
      };
      let gd = async () => {
        if (hc && wc[hc.id] && wc[hc.id].parent) {
          Ud.playAudioFile(false, false, 1, "sail");
          $("#docking-modal").hide();
          if (hc.isCaptain) {
            await ud();
          }
          gc.emit("departure");
        }
      };
      let _d = e => {
        if (e === "show") {
          $("#loading-wheel").show();
        } else {
          $("#loading-wheel").hide();
        }
      };
      let vd = () => {
        let e = $("#spawn-select").val();
        if (e === "sea" || e === "krew") {
          Ud.musicPlaying = "ocean-music";
          Ud.playAudioFile(true, false, 1, "ocean-music");
        } else {
          Ud.musicPlaying = "island-music";
          Ud.playAudioFile(true, false, 1, "island-music");
        }
        return e;
      };
      let bd = {
        hideSuggestionBox: false,
        serverList: {},
        lastGold: 0,
        markerMapCount: performance.now(),
        allPagesId: ["#ship-status-modal", "#shopping-modal", "#krew-list-modal", "#bank-modal", "#quests-modal", "#help-modal", "#cargo-modal", "#reactions-modal"],
        captainUiConfiguration: {
          editingName: false,
          active: false
        },
        setListeners: () => {
          $("#global-chat-alert").hide();
          bd.setQualitySettings();
          $("#music-control").on("change", () => Ud.updateMusicVolume());
          $("#splash-modal").modal({
            backdrop: "static",
            keyboard: false
          });
          $("#splash-modal").modal("show");
          $("#show-wof-clans").on("click", () => {
            $("#wall-of-fame")[0].hidden = true;
            $("#wall-of-fame-clans")[0].hidden = false;
          });
          $("#show-wof").on("click", () => {
            $("#wall-of-fame")[0].hidden = false;
            $("#wall-of-fame-clans")[0].hidden = true;
          });
          $("#show-more").on("click", () => {
            if ($("#show-more").text().indexOf("Show more") > -1) {
              $(".top50").show();
              $("#show-more").html("<i class=\"icofont icofont-medal\"></i> Show less");
            } else {
              $(".top50").hide();
              $("#show-more").html("<i class=\"icofont icofont-medal\"></i> Show more");
            }
          });
          $("#show-more-clans").on("click", () => {
            if ($("#show-more-clans").text().indexOf("Show more") > -1) {
              $(".top50-clans").show();
              $("#show-more-clans").html("<i class=\"icofont icofont-medal\"></i> Show less");
            } else {
              $(".top50-clans").hide();
              $("#show-more-clans").html("<i class=\"icofont icofont-medal\"></i> Show more");
            }
          });
          if (Lh().sid && Lh().bid) {
            $("#invite-is-used").show();
            $("#server-select").hide();
            $("#spawn-select").hide();
          }
          $("#play-btn").on("click", async () => {
            if (Xc) {
              if (window?.CrazyGames?.SDK?.environment === "crazygames") {
                window.CrazyGames.SDK.game.gameplayStart();
              }
              await ud();
              Hd($("#server-select").val());
              qh();
              $("#play-again-button").on("click", async () => {
                if (Xc) {
                  if (window?.CrazyGames?.SDK?.environment === "crazygames") {
                    window.CrazyGames.SDK.game.gameplayStart();
                  }
                  ud(true);
                  Wc = 0;
                  gc.emit("respawn");
                  hc.itemId = undefined;
                  hc.state = 2;
                  $("#toggle-shop-modal-button").removeClass("btn btn-md enabled toggle-shop-modal-button").addClass("btn btn-md disabled toggle-shop-modal-button");
                  $("#toggle-krew-list-modal-button").removeClass("btn btn-md enabled toggle-krew-list-modal-button").addClass("btn btn-md disabled toggle-krew-list-modal-button");
                  $("#toggle-bank-modal-button").removeClass("btn btn-md enabled toggle-shop-modal-button").addClass("btn btn-md disabled toggle-shop-modal-button").attr("data-tooltip", "Bank is available at Labrador");
                  $("#game-over-modal").hide();
                }
              });
              $("#quality-list").on("change", () => Eh());
              $("#crew_count, #ship_health, #food").slider();
              $("#crew_count").on("slide", e => {
                $("#crew_count_val").text(e.value);
              });
              $("#ship_health").on("slide", e => {
                $("#ship_health_val").text(e.value);
              });
              $("#docking-modal-button").on("click", () => {
                if ($("#docking-modal-button").hasClass("enabled")) {
                  if (hc && hc.parent) {
                    Ud.playAudioFile(false, false, 1, "dock");
                    gc.emit("anchor", e => {
                      if (e === true) {
                        $("#docking-modal").hide();
                      }
                    });
                    $(".btn-shopping-modal").eq(2).trigger("click");
                    if (wc[hc.parent.anchorIslandId].name === "Labrador") {
                      $("#toggle-bank-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
                    }
                    if (hc.parent.netType === 1 && !$("#exit-island-button").is(":visible")) {
                      $("#exit-island-button").show();
                    }
                  }
                  nc.unLockMouseLook();
                  $("#toggle-shop-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button");
                  $("#toggle-krew-list-modal-button").removeClass("btn btn-md disabled toggle-krew-list-modal-button").addClass("btn btn-md enabled toggle-krew-list-modal-button");
                  fd();
                  $("#recruiting-div").fadeIn("slow");
                }
              });
              $("#game-over-modal").modal({
                show: false,
                backdrop: "static",
                keyboard: false
              });
              $("#toggle-invite-link-button").on("click", () => {
                if ($("#invite-div").is(":visible")) {
                  $("#invite-div").hide();
                } else {
                  $("#invite-link").val(bd.getInviteLink());
                  $("#invite-div").show();
                  $("#invite-link").focus().select();
                }
              });
              $("#exit-island-button").on("click", () => gd());
              $("#toggle-help-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#help-modal").is(":visible")) {
                  $("#help-modal").hide();
                } else {
                  bd.closeAllPagesExcept("#help-modal");
                  $("#help-modal").show();
                }
              });
              $("#toggle-cargo-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#cargo-modal").is(":visible")) {
                  $("#cargo-modal").hide();
                } else {
                  bd.closeAllPagesExcept("#cargo-modal");
                  $("#cargo-modal").show();
                }
              });
              $("#toggle-quest-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#quests-modal").is(":visible")) {
                  $("#quests-modal").hide();
                } else {
                  gc.emit("get-stats", e => {
                    let t = JSON.parse(e);
                    $(".pirate-progress").text(t.shipsSank);
                    $(".pirate-progress-2").text(t.scores);
                    $(".crew-pirate-progress").text(t.overall_kills);
                    $(".crew-pirate-progress-2").text(t.overall_scores);
                    if (t.shipsSank >= 1) {
                      $("#completed-quest-table").append($("#pirate-quest-1").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#pirate-quest-2").show();
                      $("#crew-pirate-quest-1").show();
                    }
                    if (t.shipsSank >= 5 && t.scores >= 1000) {
                      $("#completed-quest-table").append($("#pirate-quest-2").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#pirate-quest-3").show();
                    }
                    if (t.shipsSank >= 10 && t.scores >= 2500) {
                      $("#completed-quest-table").append($("#pirate-quest-3").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#pirate-quest-4").show();
                    }
                    if (t.shipsSank >= 25 && t.scores >= 7500) {
                      $("#completed-quest-table").append($("#pirate-quest-4").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#pirate-quest-5").show();
                    }
                    if (t.shipsSank >= 50 && t.scores >= 50000) {
                      $("#completed-quest-table").append($("#pirate-quest-5").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    }
                    if (t.overall_kills >= 10 && t.overall_scores >= 2500) {
                      $("#completed-quest-table").append($("#crew-pirate-quest-1").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-pirate-quest-2").show();
                    }
                    if (t.overall_kills >= 25 && t.overall_scores >= 15000) {
                      $("#completed-quest-table").append($("#crew-pirate-quest-2").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-pirate-quest-3").show();
                    }
                    if (t.overall_kills >= 40 && t.overall_scores >= 30000) {
                      $("#completed-quest-table").append($("#crew-pirate-quest-3").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-pirate-quest-4").show();
                    }
                    if (t.overall_kills >= 75 && t.overall_scores >= 100000) {
                      $("#completed-quest-table").append($("#crew-pirate-quest-4").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    }
                    $(".trade-progress").text(t.overall_cargo);
                    $(".crew-trade-progress").text(t.crew_overall_cargo);
                    if (t.overall_cargo >= 5000) {
                      $("#completed-quest-table").append($("#trade-quest-1").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#trade-quest-2").show();
                      $("#crew-trade-quest-1").show();
                    }
                    if (t.overall_cargo >= 20000) {
                      $("#completed-quest-table").append($("#trade-quest-2").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#trade-quest-3").show();
                    }
                    if (t.overall_cargo >= 125000) {
                      $("#completed-quest-table").append($("#trade-quest-3").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#trade-quest-4").show();
                    }
                    if (t.overall_cargo >= 250000) {
                      $("#completed-quest-table").append($("#trade-quest-4").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#trade-quest-5").show();
                    }
                    if (t.overall_cargo >= 3000000) {
                      $("#completed-quest-table").append($("#trade-quest-5").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    }
                    if (t.crew_overall_cargo >= 25000) {
                      $("#completed-quest-table").append($("#crew-trade-quest-1").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-trade-quest-2").show();
                    }
                    if (t.crew_overall_cargo >= 75000) {
                      $("#completed-quest-table").append($("#crew-trade-quest-2").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-trade-quest-3").show();
                    }
                    if (t.crew_overall_cargo >= 500000) {
                      $("#completed-quest-table").append($("#crew-trade-quest-3").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#crew-trade-quest-4").show();
                    }
                    if (t.crew_overall_cargo >= 5000000) {
                      $("#completed-quest-table").append($("#crew-trade-quest-4").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                    }
                    $("#other-progress-1").text(hc.jump_count);
                    if (hc.jump_count >= 50) {
                      $("#completed-quest-table").append($("#other-quest-1").last());
                      $("#completed-quest-table .quest-progress").html("<i class=\"icofont icofont-check-circled\"></i>");
                      $("#other-quest-2").show();
                    }
                  });
                  bd.closeAllPagesExcept("#quests-modal");
                  $("#quests-modal").show();
                }
              });
              $("#close-quests-button").on("click", () => {
                $("#quests-modal").css("display", "none");
              });
              $("#close-reactions-button").on("click", () => {
                $("#reactions-modal").hide();
              });
              $("#close-help-button").on("click", () => {
                $("#help-modal").css("display", "none");
              });
              $("#close-cargo-button").on("click", () => {
                $("#cargo-modal").css("display", "none");
              });
              $("#cancel-exit-button").on("click", () => {
                if ($("#cancel-exit-button").find("span").text() === "Cancel (c)") {
                  gc.emit("exitIsland");
                  $("#docking-modal-button").find("span").text("Countdown...");
                }
              });
              $("#abandon-ship-button").on("click", () => {
                if (!(hc.parent.hp <= 0)) {
                  gc.emit("abandonShip");
                  $("#abandon-ship-button").hide();
                  if (hc.parent !== undefined) {
                    if (hc.parent.shipState === 3 || hc.parent.shipState === -1 || hc.parent.shipState === 4) {
                      $("#toggle-shop-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button");
                      $("#toggle-krew-list-modal-button").removeClass("btn btn-md disabled toggle-krew-list-modal-button").addClass("btn btn-md enabled toggle-krew-list-modal-button");
                      if (wc[hc.parent.anchorIslandId].name === "Labrador") {
                        $("#toggle-bank-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
                      }
                      fd();
                    } else if (hc.parent.shipState === 1) {
                      $("#docking-modal").show();
                    }
                  }
                }
              });
              $("#lock-krew-button").on("click", () => {
                if ($("#lock-krew-button").is(":checked")) {
                  $("#lock-krew-text").removeClass("lock-text-info").addClass("lock-text-error").text("Unlock krew...");
                  gc.emit("lock-krew", true);
                } else {
                  $("#lock-krew-text").removeClass("lock-text-error").addClass("lock-text-info").text("Lock krew...");
                  gc.emit("lock-krew", false);
                }
              });
              $("#lock-cargo-button").on("click", () => {
                if ($("#lock-cargo-button").is(":checked")) {
                  $("#lock-cargo-text").removeClass("lock-text-info").addClass("lock-text-error").text("Unlock cargo...");
                  gc.emit("lock-cargo", true);
                } else {
                  $("#lock-cargo-text").removeClass("lock-text-error").addClass("lock-text-info").text("Lock cargo...");
                  gc.emit("lock-cargo", false);
                }
              });
              $("#fp-mode-button").on("click", () => {
                if ($("#fp-mode-button").is(":checked")) {
                  $("#fp-mode-text").removeClass("lock-text-info").addClass("lock-text-error").text("FP Camera (Enabled)");
                } else {
                  $("#fp-mode-text").removeClass("lock-text-error").addClass("lock-text-info").text("FP Camera (Disabled)");
                }
              });
              $("#view-sails-button").on("click", () => {
                if ($("#view-sails-button").is(":checked")) {
                  $("#view-sails-text").removeClass("lock-text-info").addClass("lock-text-error").text("View Sails (Enabled)");
                } else {
                  $("#view-sails-text").removeClass("lock-text-error").addClass("lock-text-info").text("View Sails (Disabled)");
                }
                Kc = $("#view-sails-button").is(":checked");
              });
              $("#block-notifications-button").on("click", () => {
                if ($("#block-notifications-button").is(":checked")) {
                  $("#block-notifications-text").removeClass("lock-text-info").addClass("lock-text-error").text("Block Notifications (Enabled)");
                } else {
                  $("#block-notifications-text").removeClass("lock-text-error").addClass("lock-text-info").text("Block Notifications (Disabled)");
                }
                Yc = $("#block-notifications-button").is(":checked");
              });
              $("#show-allies-on-minimap").on("click", () => {
                if ($("#show-allies-on-minimap-button").is(":checked")) {
                  $("#show-allies-on-minimap-text").removeClass("lock-text-info").addClass("lock-text-error").text("View allies on minimap (Enabled)");
                } else {
                  $("#show-allies-on-minimap-text").removeClass("lock-text-error").addClass("lock-text-info").text("View allies on minimap (Disabled)");
                }
                ch = $("#show-allies-on-minimap-button").is(":checked");
              });
              $(".toggle-krew-list-modal-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#toggle-krew-list-modal-button").hasClass("enabled")) {
                  if ($("#krew-list-modal").is(":visible")) {
                    $("#krew-list-modal").hide();
                  } else {
                    $("#toggle-shop-modal-button").popover("hide");
                    $("#krew-list-modal").show();
                    bd.closeAllPagesExcept("#krew-list-modal");
                  }
                }
              });
              $("#crew-name-edit-button").on("click", () => {
                $("#crew-name-edit-button").addClass("hidden");
                if (bd.captainUiConfiguration.active) {
                  $("#crew-name").addClass("hidden");
                  bd.captainUiConfiguration.editingName = true;
                  $("#crew-name-edit-input").val($("#crew-name").html()).removeClass("hidden").focus();
                }
              });
              $("#krew-name-form").on("submit", e => {
                bd.captainUiConfiguration.editingName = false;
                $("#crew-name").removeClass("hidden");
                $("#crew-name-edit-input").addClass("hidden");
                if (bd.captainUiConfiguration.active) {
                  $("#crew-name-edit-button").removeClass("hidden");
                  let e = $("#crew-name-edit-input").val().trim().slice(0, 20);
                  if (e.length > 0 && !e.includes("")) {
                    hc.parent.setName(e);
                    $("#crew-name").text(hc.parent.crewName);
                    gc.emit("updateKrewName", hc.parent.crewName);
                  }
                }
                $("#crew-name-edit-input").val("");
                e.preventDefault();
              });
              $(".toggle-bank-modal-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#toggle-bank-modal-button").hasClass("enabled")) {
                  if ($("#bank-modal").is(":visible")) {
                    $("#bank-modal").hide();
                  } else {
                    bd.closeAllPagesExcept("#bank-modal");
                    $("#bank-modal").show();
                    $("#successTakeDepoMess").hide();
                    $("#successMakeDepoMess").hide();
                    $("#errorMakeDepoMess").hide();
                    $("#errorTakeDepoMess").hide();
                    gc.emit("bank");
                  }
                }
              });
              $(".toggle-ship-status-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#ship-status-modal").is(":visible")) {
                  $("#ship-status-modal").hide();
                } else {
                  bd.closeAllPagesExcept("#ship-status-button");
                  $("#ship-status").addClass("active");
                  $("#clan-management").removeClass("active");
                  $("#alliance-management").removeClass("active");
                  $("#game-settings").removeClass("active");
                  if (!$("#ship-status-container").is(":visible")) {
                    $("#ship-status-container").show();
                    $("#clan-management-container").hide();
                    $("#alliance-management-container").hide();
                    $("#notLoggedIn-container").hide();
                    $("#not-clan-owner-container").hide();
                    $("#game-settings-container").hide();
                  }
                  $("#ship-status-modal").show();
                  if (hc.isCaptain !== true) {
                    $("#lock-krew-label").hide();
                    $("#lock-cargo-label").hide();
                  } else {
                    $("#lock-krew-label").show();
                    if (hc.parent && hc.parent.isLocked !== true) {
                      $("#lock-krew-button").prop("checked", false);
                      $("#lock-krew-text").removeClass("lock-text-error").addClass("lock-text-info").text("Lock krew...");
                    } else {
                      $("#lock-krew-button").prop("checked", true);
                      $("#lock-krew-text").removeClass("lock-text-info").addClass("lock-text-error").text("Unlock krew...");
                    }
                    $("#lock-cargo-label").show();
                    if (hc.parent && hc.parent.cargoLocked !== true) {
                      $("#lock-cargo-button").prop("checked", false);
                      $("#lock-cargo-text").removeClass("lock-text-error").addClass("lock-text-info").text("Lock cargo...");
                    } else {
                      $("#lock-cargo-button").prop("checked", true);
                      $("#lock-cargo-text").removeClass("lock-text-info").addClass("lock-text-error").text("Unlock cargo...");
                    }
                  }
                }
              });
              $("#ship-status").on("click", () => {
                $("#ship-status").addClass("active");
                $("#clan-management").removeClass("active");
                $("#game-settings").removeClass("active");
                if (!$("#ship-status-container").is(":visible")) {
                  $("#ship-status-container").show();
                  $("#clan-management-container").hide();
                  $("#alliance-management-container").hide();
                  $("#notLoggedIn-container").hide();
                  $("#not-clan-owner-container").hide();
                  $("#game-settings-container").hide();
                }
              });
              $("#clan-management").on("click", () => {
                $("#ship-status").removeClass("active");
                $("#clan-management").addClass("active");
                $("#alliance-management").removeClass("active");
                $("#game-settings").removeClass("active");
                if (hc.isLoggedIn === true) {
                  sd.setClanData();
                  if (!$("#clan-management-container").is(":visible")) {
                    $("#ship-status-container").hide();
                    $("#clan-management-container").show();
                    $("#alliance-management-container").hide();
                    $("#notLoggedIn-container").hide();
                    $("#not-clan-owner-container").hide();
                    $("#game-settings-container").hide();
                    sd.setClanData("force");
                  }
                } else {
                  $("#ship-status-container").hide();
                  $("#clan-management-container").hide();
                  $("#alliance-management-container").hide();
                  $("#notLoggedIn-container").show();
                  $("#not-clan-owner-container").hide();
                  $("#game-settings-container").hide();
                }
              });
              $("#alliance-management").on("click", () => {
                $("#ship-status").removeClass("active");
                $("#clan-management").removeClass("active");
                $("#alliance-management").addClass("active");
                $("#game-settings").removeClass("active");
                if (hc?.isLoggedIn === true) {
                  od.setAllianceData();
                  if (!$("#alliance-management-container").is(":visible")) {
                    $("#ship-status-container").hide();
                    $("#clan-management-container").hide();
                    $("#alliance-management-container").show();
                    $("#notLoggedIn-container").hide();
                    $("#game-settings-container").hide();
                    od.setAllianceData("force");
                  }
                } else {
                  $("#ship-status-container").hide();
                  $("#clan-management-container").hide();
                  $("#alliance-management-container").hide();
                  $("#notLoggedIn-container").hide();
                  $("#not-clan-owner-container").show();
                  $("#game-settings-container").hide();
                }
              });
              $("#game-settings").on("click", () => {
                $("#ship-status").removeClass("active");
                $("#clan-management").removeClass("active");
                $("#alliance-management").removeClass("active");
                $("#game-settings").addClass("active");
                if (!$("#game-settings-container").is(":visible")) {
                  $("#ship-status-container").hide();
                  $("#clan-management-container").hide();
                  $("#alliance-management-container").hide();
                  $("#notLoggedIn-container").hide();
                  $("#not-clan-owner-container").hide();
                  $("#game-settings-container").show();
                  if (typeof Dc.name == "string") {
                    $(".bounty-name").text(`${Dc.bounty} bounty is on: ${Dc.name}`);
                  } else {
                    $(".bounty-name").text("There is no bounty right now.");
                  }
                }
              });
              $("#leave-clan-button").on("click", () => {
                $("#leave-clan-request-modal").removeClass("hidden");
                $("#leave-clan-request-modal").show();
                $("#leave-clan-request-name").text(`Leave Clan [${hc.clan}]`);
              });
              $("#accept-leave-clan-request-button").on("click", () => {
                gc.emit("clan", "leave", e => {
                  if (e === true) {
                    sd.setClanData("force");
                  }
                });
                hc.clan = "";
                hc.alliance = "";
                hc.allianceOwner = false;
                sd.setClanData();
                $("#leave-clan-request-modal").addClass("hidden");
                $("#leave-clan-request-modal").hide();
              });
              $("#decline-leave-clan-request-button").on("click", () => {
                $("#leave-clan-request-modal").addClass("hidden");
                $("#leave-clan-request-modal").hide();
              });
              $("#accept-transfer-ship-request-button").on("click", () => {
                gc.emit("transferShip", gh[0]);
                if ($("#buy-goods").hasClass("active")) {
                  cd.getList();
                }
                $("#transfer-ship-request-modal").addClass("hidden");
                $("#transfer-ship-request-modal").hide();
              });
              $("#decline-transfer-ship-request-button").on("click", () => {
                $("#transfer-ship-request-modal").addClass("hidden");
                $("#transfer-ship-request-modal").hide();
              });
              $("#accept-leave-request-button").on("click", () => {
                gc.emit("leaveGame");
                $("#leave-request-modal").addClass("hidden");
                $("#leave-request-modal").hide();
                location.reload(true);
              });
              $("#decline-leave-request-button").on("click", () => {
                $("#leave-request-modal").addClass("hidden");
                $("#leave-request-modal").hide();
              });
              $("#leave-alliance-button").on("click", () => {
                gc.emit("alliance", {
                  id: "leave-from-alliance"
                }, e => {
                  if (e === true) {
                    hc.alliance = "";
                    hc.allianceOwner = false;
                    od.setAllianceData("force");
                  }
                });
                od.setAllianceData();
              });
              $("#request-alliance-button").on("click", () => {
                if ($("#alliance-table").hasClass("hidden")) {
                  $("#alliance-table").removeClass("hidden");
                  $("#invite-to-alliance").addClass("hidden");
                  $("#invite-to-alliance").hide();
                  $("#request-alliance-button").text("Add clan to alliance ");
                } else {
                  $("#alliance-table").addClass("hidden");
                  $("#invite-to-alliance").removeClass("hidden");
                  $("#invite-to-alliance").show();
                  $("#request-alliance-button").text("Show alliance members ");
                }
              });
              $("#request-clan-button").on("click", () => {
                $("#clan-table").hide();
                $("#clan-request-table").show();
                $("#view-clan-button").show();
              });
              $("#view-clan-button").on("click", () => {
                $("#clan-table").show();
                $("#clan-request-table").hide();
                $("#view-clan-button").hide();
              });
              $("#clan-request").on("click", () => {
                sd.hideAllClanErrors();
              });
              $("#join-clan-button").on("click", () => {
                sd.hideAllClanErrors();
                let e = $("#clan-request").val();
                if (Ah(e) !== true) {
                  $("#errorInput").show();
                } else if (e.length < 1 || e.length > 4) {
                  $("#errorLength").show();
                } else if (!hc.clanRequest || hc.clanRequest === "") {
                  gc.emit("clan", {
                    action: "join",
                    id: e
                  }, t => {
                    if (t === true) {
                      hc.clanRequest = e;
                      sd.setClanData("force");
                    } else if (t === 404) {
                      $("#error404").show();
                    } else {
                      $("#errorUndefined").show();
                    }
                  });
                }
              });
              $("#create-clan-button").on("click", () => {
                sd.hideAllClanErrors();
                let e = $("#clan-request").val();
                if (Ah(e) !== true) {
                  $("#errorInput").show();
                } else if (e.length < 1 || e.length > 4) {
                  $("#errorLength").show();
                } else {
                  gc.emit("clan", {
                    action: "create",
                    id: e
                  }, t => {
                    if (t === true) {
                      hc.clan = e;
                      hc.clanLeader = true;
                      sd.setClanData("force");
                    } else if (t === 409) {
                      $("#errorExists").show();
                    } else if (t === 403) {
                      $("#errorUnauthorized").show();
                    } else if (t == 400) {
                      $("#errorInput").show();
                    } else {
                      $("#errorUndefined").show();
                    }
                  });
                }
              });
              $("#create-alliance-button").on("click", () => {
                od.hideAllAllianceErrors();
                gc.emit("alliance", {
                  id: "create-alliance"
                }, e => {
                  if (e !== true) {
                    return nd.showCenterMessage("Something went wrong.", 1, 20000);
                  }
                  hc.alliance = hc.clan;
                  hc.allianceOwner = true;
                  od.setAllianceData("force");
                });
              });
              $("#invite-to-alliance-button").on("click", () => {
                od.hideAllAllianceErrors();
                let e = $("#invite-to-alliance-input").val();
                if (Ah(e) !== true) {
                  $("#errorInput-invite-alliance").show();
                } else if (e.length < 1 || e.length > 4) {
                  $("#errorLength-invite-alliance").show();
                } else {
                  let t = Object.values(wc).find(t => t.clan != null && t.clan != "" && t.clan == e && t.clanOwner === true);
                  let i = t?.name;
                  if (i == "" || i == null || i == hc.name) {
                    return nd.showCenterMessage("You entered an incorrect clan name, or the other clan owner is offline.", 1, 20000);
                  }
                  gc.emit("alliance", {
                    nick: i,
                    id: "send-invite-to-alliance"
                  }, e => {
                    if (e !== true) {
                      return nd.showCenterMessage("Something went wrong.", 1, 20000);
                    }
                    od.setAllianceData("force");
                    $("#request-alliance-button").click();
                  });
                }
              });
              $("#clan-table").on("click", e => {
                let t = e.target.getAttribute("data-event");
                let i = e.target.getAttribute("data-id");
                if (t === "promote-clan") {
                  gc.emit("clan", {
                    action: "promote",
                    id: i
                  }, e => {
                    if (e === true) {
                      sd.setClanData("force");
                    }
                  });
                  sd.setClanData();
                } else if (t === "demote-clan") {
                  gc.emit("clan", {
                    action: "demote",
                    id: i
                  }, e => {
                    if (e === true) {
                      sd.setClanData("force");
                    }
                  });
                  sd.setClanData();
                } else if (t === "kick-clan") {
                  gc.emit("clan", {
                    action: "kick",
                    id: i
                  }, e => {
                    if (e === true) {
                      sd.setClanData("force");
                    }
                  });
                }
              });
              $("#alliance-table").on("click", e => {
                let t = e.target.getAttribute("data-event");
                let i = e.target.getAttribute("data-id");
                if (t === "kick-alliance") {
                  gc.emit("alliance", {
                    id: "kick-from-alliance",
                    clan: i
                  }, e => {
                    if (e === true) {
                      od.setAllianceData("force");
                    }
                  });
                }
              });
              $("#accept-alliance-request-button").on("click", e => {
                gc.emit("alliance", {
                  id: "accept-alliance-request"
                }, e => {});
                $("#accept-alliance-request-modal").addClass("hidden");
                $("#accept-alliance-request-modal").hide();
              });
              $("#decline-alliance-request-button").on("click", e => {
                hc.allianceRequest = undefined;
                $("#accept-alliance-request-modal").addClass("hidden");
                $("#accept-alliance-request-modal").hide();
              });
              $("#clan-request-table").on("click", e => {
                let t = e.target.getAttribute("data-event");
                let i = e.target.getAttribute("data-id");
                if (t === "accept-request") {
                  gc.emit("clan", {
                    action: "accept",
                    id: i
                  }, e => {
                    if (e === true) {
                      sd.setClanData("force");
                    }
                  });
                } else if (t === "decline-request") {
                  gc.emit("clan", {
                    action: "decline",
                    id: i
                  }, e => {
                    if (e === true) {
                      sd.setClanData("force");
                    }
                  });
                }
              });
              $("#player-request-table").on("click", e => {
                if (e.target.getAttribute("data-event") === "cancel-request" && hc.clanRequest && hc.clanRequest !== "") {
                  gc.emit("clan", {
                    action: "cancel-request",
                    id: hc.clanRequest
                  }, e => {
                    if (e === true) {
                      hc.clanRequest = "";
                      sd.setClanData("force");
                    }
                  });
                }
              });
              $("#minimap").on("click", e => {
                if (bd.markerMapCount < performance.now() - 5000) {
                  bd.markerMapCount = performance.now();
                  let t = ((e.offsetX === undefined ? e.layerX : e.offsetX) - 10) / 180 * Jl.worldsize;
                  let i = ((e.offsetY === undefined ? e.layerY : e.offsetY) - 10) / 180 * Jl.worldsize;
                  gc.emit("addMarker", {
                    x: t,
                    y: i
                  });
                }
              });
              $("#krew-list").on("click", e => {
                let t = e.target.getAttribute("data-event");
                if (t === "kick") {
                  let t = e.target.getAttribute("data-id");
                  if (typeof t == "string" && t.length > 0) {
                    gc.emit("bootMember", t);
                    $(e.target).closest(".player-list-item").remove();
                    if ($("#buy-goods").hasClass("active")) {
                      cd.getList();
                    }
                  }
                } else if (t === "transfer") {
                  let t = e.target.getAttribute("data-id");
                  let i = e.target.getAttribute("data-name");
                  if (typeof t == "string" && t.length > 0) {
                    gh = [t, i];
                    $("#transfer-ship-request-modal").removeClass("hidden");
                    $("#transfer-ship-request-modal").show();
                    $("#transfer-ship-request-name").text(`Transfer ship to ${gh[1]}`);
                  }
                }
              });
              $("#reactions-modal-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#reactions-modal").is(":visible")) {
                  $("#reactions-modal").hide();
                } else {
                  if ($("#reactions-container").is(":empty")) {
                    for (let e = 1; e <= 68; e++) {
                      $("#reactions-container").append(`<div class="reaction-card" style="width: 100px; height: 100px;">\n                        <img src="assets/img/reactions/_${e}.png" style="width: 100px; height: 100px; cursor: pointer;" />\n                        </div>`);
                      document.getElementById("reactions-container").lastChild.onclick = function () {
                        $("#reactions-modal").hide();
                        nc.lockMouseLook();
                        gc.emit("reaction", e);
                      };
                    }
                  }
                  bd.closeAllPagesExcept("#help-modal");
                  $("#reactions-modal").show();
                }
              });
              $("#discord-modal-button").on("click", () => window.open("https://discord.gg/VFY8exqy5t"));
              $("#wiki-modal-button").on("click", () => window.open("https://krew-io.fandom.com/wiki/Krew.io_Wiki"));
              $("#leave-modal-button").on("click", () => {
                $("#leave-request-modal").removeClass("hidden");
                $("#leave-request-modal").show();
              });
              $("#player-leaderboard").hide();
              $("#fov-control").on("input", () => {
                let e = document.getElementById("fov-control").value;
                Hc = e / 10;
                document.getElementById("fov-control-2").value = Math.round((e - 10) / 65 * 100) / 100;
              });
              $("#fov-control-2").on("input", () => {
                let e = Math.min(1, Math.max(0, document.getElementById("fov-control-2").value));
                Hc = (e * 65 + 10) / 10;
                document.getElementById("fov-control").value = Hc * 10;
              });
              $(".toggle-shop-modal-button").on("click", () => {
                nc.unLockMouseLook();
                if ($("#toggle-shop-modal-button").hasClass("enabled")) {
                  if ($("#shopping-modal").is(":visible")) {
                    $("#shopping-modal").hide();
                  } else {
                    $("#toggle-shop-modal-button").popover("hide");
                    $("#shopping-modal").show();
                  }
                }
                md();
              });
              $("#buy-items").on("click", () => {
                $(".btn-shopping-modal").removeClass("active");
                $("#buy-items").addClass("active");
                fd();
              });
              $("#buy-ships").on("click", () => {
                $(".btn-shopping-modal").removeClass("active");
                $("#buy-ships").addClass("active");
                fd();
              });
              $("#buy-goods").on("click", () => {
                $(".btn-shopping-modal").removeClass("active");
                $("#buy-goods").addClass("active");
                fd();
              });
              $("#make-deposit").on("keypress", e => {
                if (e.keyCode === 13) {
                  ad();
                }
              });
              $("#take-deposit").on("keypress", e => {
                if (e.keyCode === 13) {
                  rd();
                }
              });
              $("#close-bank-button").on("click", () => {
                $("#bank-modal").hide();
              });
              $("#btn-make-deposit").on("click", () => {
                ad();
              });
              $("#btn-take-deposit").on("click", () => {
                rd();
              });
              _d("show");
              Ud.playAudioFile(false, false, 1, "wheelspin");
              Ud.playAudioFile(true, false, 0.7, "ocean-ambience");
            }
          }).text("Loading...").attr("disabled", true);
          window.addEventListener("wheel", e => {
            if (!document.getElementById("splash-modal").contains(e.target) && !document.getElementById("krew-list-modal").contains(e.target) && !document.getElementById("ship-status-modal").contains(e.target) && !document.getElementById("chat-div").contains(e.target) && !document.getElementById("shopping-modal").contains(e.target) && !document.getElementById("quests-modal").contains(e.target) && !document.getElementById("help-modal").contains(e.target) && !document.getElementById("changelog").contains(e.target) && !document.getElementById("wall-of-fame").contains(e.target) && !document.getElementById("wall-of-fame-clans").contains(e.target) && !document.getElementById("reactions-modal").contains(e.target)) {
              e.preventDefault();
            }
          }, {
            passive: false
          });
          window.addEventListener("keydown", e => {
            if (["ArrowUp", "ArrowDown", " "].includes(e.key) && !bd.textFieldFocused()) {
              e.preventDefault();
            }
          });
        },
        getInviteLink: () => window?.CrazyGames?.SDK?.environment === "crazygames" ? window.CrazyGames.SDK.game.inviteLink({
          sid: $("#server-select").val(),
          bid: hc.parent.id
        }) : `${window.location.protocol}//${window.location.hostname}${window.location.hostname === "localhost" ? ":3000/?sid=" : "/?sid="}${$("#server-select").val()}&bid=${hc.parent.id}`,
        checkGoldDelta: e => {
          let t = e - bd.lastGold;
          bd.lastGold = e;
          if (t > 0) {
            let i;
            if (!Yc) {
              hc.notifiscationHeap[Math.random().toString(36).substring(6, 10)] = {
                text: `+ ${t} Gold!`,
                type: 1,
                isNew: true
              };
            }
            i = e > 99999 && e < 999999 ? `${Math.floor(e / 1000)} K` : e > 999999 ? Math.floor(e / 1000) / 1000 + " M" : e;
            $(".my-gold").text(i);
          } else if (t < 0) {
            let t;
            t = e > 99999 && e < 999999 ? `${Math.floor(e / 1000)} K` : e > 999999 ? Math.floor(e / 1000) / 1000 + " M" : e;
            $(".my-gold").text(t);
          }
        },
        closeAllPages: () => {
          for (let e of bd.allPagesId) {
            $(e).hide();
          }
        },
        closeAllPagesExcept: e => {
          for (let t of bd.allPagesId) {
            if (e !== t) {
              $(t).hide();
            }
          }
        },
        setQualitySettings: () => {
          let e;
          $("#quality-list").html("");
          e = $("<option/>", {
            html: "High Quality (slow)",
            value: 3
          });
          $("#quality-list").append(e);
          e = $("<option/>", {
            html: "Medium Quality (fast)",
            value: 2
          });
          $("#quality-list").append(e);
          e = $("<option/>", {
            html: "Low Quality (faster)",
            value: 1
          });
          $("#quality-list").append(e);
          e = $("<option/>", {
            html: "Lowest Quality (fastest)",
            value: 0
          });
          $("#quality-list").append(e);
          $("#account-quality-list").html("");
          e = $("<option/>", {
            html: "High Quality (slow)",
            value: 3
          });
          $("#account-quality-list").append(e);
          e = $("<option/>", {
            html: "Medium Quality (fast)",
            value: 2
          });
          $("#account-quality-list").append(e);
          e = $("<option/>", {
            html: "Low Quality (faster)",
            value: 1
          });
          $("#account-quality-list").append(e);
          e = $("<option/>", {
            html: "Lowest Quality (fastest)",
            value: 0
          });
          $("#account-quality-list").append(e);
        },
        updateCaptainUi: () => {
          if (bd.captainUiConfiguration.active && !bd.captainUiConfiguration.editingName) {
            $("#crew-name-edit-button").removeClass("hidden");
          } else {
            $("#crew-name-edit-button").addClass("hidden");
          }
        },
        textFieldFocused: () => document.activeElement !== null && ["input", "select", "textarea"].includes(document.activeElement.tagName.toLowerCase())
      };
      let yd = false;
      const xd = e => {
        if (!bd.textFieldFocused() && !lh) {
          switch (e.keyCode) {
            case 87:
            case 38:
              ah = true;
              break;
            case 65:
            case 37:
              ih = true;
              break;
            case 83:
            case 40:
              rh = true;
              break;
            case 68:
            case 39:
              nh = true;
              break;
            case 32:
              sh = true;
              break;
            case 49:
              if (hc && hc.geometry && hc.activeWeapon !== 0) {
                gc.emit("changeWeapon", 0);
                hc.isFishing = false;
                $("#cannon-item-div").css("border", "5px solid #f0ad4e");
                $("#rod-item-div").css("border", "none");
                $("#spyglass-item-div").css("border", "none");
              }
              break;
            case 50:
              if (hc && hc.geometry && hc.activeWeapon !== 1) {
                gc.emit("changeWeapon", 1);
                hc.isFishing = false;
                $("#cannon-item-div").css("border", "none");
                $("#rod-item-div").css("border", "5px solid #f0ad4e");
                $("#spyglass-item-div").css("border", "none");
              }
              break;
            case 51:
              if (hc && hc.geometry && hc.activeWeapon !== 2) {
                gc.emit("changeWeapon", 2);
                hc.isFishing = false;
                $("#cannon-item-div").css("border", "none");
                $("#rod-item-div").css("border", "none");
                $("#spyglass-item-div").css("border", "5px solid #f0ad4e");
                if (!yd) {
                  nd.showCenterMessage("Use the scroll wheel to zoom in and out with the spyglass", 4, 6000);
                  yd = true;
                }
              }
              break;
            case 16:
              $("#player-leaderboard").show();
              break;
            case 67:
              if (hc && hc.parent) {
                if (hc.parent.shipState !== 1 && hc.parent.shipState !== -1 || $("#cancel-exit-button").find("span").text() !== "Cancel (c)") {
                  if (hc.parent.shipState === 3) {
                    gd();
                  }
                } else {
                  gc.emit("exitIsland");
                  $("#docking-modal-button").find("span").text("Countdown...");
                }
              }
              break;
            case 72:
              if ($("#help-modal").is(":visible")) {
                $("#help-modal").hide();
              } else {
                document.getElementById("toggle-help-button").click();
              }
              break;
            case 77:
              if ($("#minimap-container").is(":visible")) {
                $("#minimap-container").hide();
              } else {
                $("#minimap-container").show();
              }
              break;
            case 84:
              if ($("#cargo-modal").is(":visible")) {
                $("#cargo-modal").hide();
              } else {
                document.getElementById("toggle-cargo-button").click();
              }
              break;
            case 78:
              hc.allianceRequest = undefined;
              break;
            case 89:
              if (hc.allianceRequest != null) {
                $("#accept-alliance-request-modal").removeClass("hidden");
                $("#accept-alliance-request-modal").show();
                $("#accept-alliance-request-name").text(`Accept [${hc.allianceRequest}] alliance request`);
              }
              break;
            case 81:
              if ($("#quests-modal").is(":visible")) {
                $("#quests-modal").hide();
              } else {
                document.getElementById("toggle-quest-button").click();
              }
              break;
            case 85:
              if ($("#game-ui").is(":hidden")) {
                $("#game-ui").show();
              } else {
                $("#game-ui").hide();
                nd.showCenterMessage("Press \"U\" again to show the game UI", 4, 4000);
              }
              break;
            case 90:
              if (hc && hc.parent && (hc.parent.shipState === 1 || hc.parent.shipState === -1) && $("#docking-modal-button").hasClass("enabled")) {
                Ud.playAudioFile(false, false, 1, "dock");
                gc.emit("anchor");
                $("#docking-modal").hide();
                if (wc[hc?.parent?.anchorIslandId]?.name === "Labrador") {
                  $("#toggle-bank-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
                }
                $("#toggle-shop-modal-button").removeClass("btn btn-md disabled toggle-shop-modal-button").addClass("btn btn-md enabled toggle-shop-modal-button");
                $("#toggle-krew-list-modal-button").removeClass("btn btn-md disabled toggle-krew-list-modal-button").addClass("btn btn-md enabled toggle-krew-list-modal-button");
                if (!$("#exit-island-button").is(":visible")) {
                  $("#exit-island-button").show();
                }
                $("#recruiting-div").fadeIn("slow");
                nc.unLockMouseLook();
              }
              break;
            case 69:
              if ($("#reactions-modal").is(":visible")) {
                $("#reactions-modal").hide();
              } else {
                document.getElementById("reactions-modal-button").click();
              }
              break;
            case 9:
              e.preventDefault();
              if ($("#li-staff-chat").is(":visible") && $("#li-alliance-chat").is(":visible") && $("#li-clan-chat").is(":visible")) {
                if (Jc) {
                  Kh();
                } else if (Zc) {
                  Yh();
                } else if (Qc) {
                  Xh();
                } else if (eh) {
                  jh();
                } else if (th) {
                  Jh();
                }
              } else if ($("#li-staff-chat").is(":visible") && $("#li-clan-chat").is(":visible")) {
                if (Jc) {
                  Yh();
                } else if (Qc) {
                  Xh();
                } else if (eh) {
                  jh();
                } else if (th) {
                  Jh();
                }
              } else if ($("#li-alliance-chat").is(":visible") && $("#li-clan-chat").is(":visible")) {
                if (Zc) {
                  Yh();
                } else if (Qc) {
                  Xh();
                } else if (eh) {
                  jh();
                } else if (th) {
                  Kh();
                }
              } else if ($("#li-staff-chat").is(":visible")) {
                if (Jc) {
                  Xh();
                } else if (eh) {
                  jh();
                } else if (th) {
                  Jh();
                }
              } else if ($("#li-clan-chat").is(":visible")) {
                if (Qc) {
                  Xh();
                } else if (eh) {
                  jh();
                } else if (th) {
                  Yh();
                }
              } else if (eh) {
                jh();
              } else if (th) {
                Xh();
              }
              break;
            case 188:
              if ($("#chat-div").is(":visible")) {
                $("#chat-div").hide();
              } else {
                $("#chat-div").show();
              }
              break;
            case 53:
            case 54:
            case 55:
              if (!e.repeat) {
                const t = Qh.keys[e.keyCode];
                Qh.clearStore().setStore(e => {
                  Qh.allocatePoints(t, () => {
                    ed();
                  });
                });
              }
          }
        }
      };
      const wd = e => {
        if (lh) {
          return;
        }
        const t = e.keyCode;
        switch (t) {
          case 27:
            if (hc) {
              hc.target = undefined;
            }
            break;
          case 13:
            if ($("#chat-message").is(":focus")) {
              $("#chat-message").blur();
            } else {
              $("#chat-message").focus();
            }
            break;
          default:
            if (!bd.textFieldFocused()) {
              switch (t) {
                case 87:
                case 38:
                  ah = false;
                  break;
                case 65:
                case 37:
                  ih = false;
                  break;
                case 83:
                case 40:
                  rh = false;
                  break;
                case 68:
                case 39:
                  nh = false;
                  break;
                case 32:
                  sh = false;
                  hc.jump_count++;
                  if (hc.jump_count === 50) {
                    nd.showCenterMessage("Jumping Hero! New quest available", 3);
                    if (window?.CrazyGames?.SDK?.environment === "crazygames") {
                      window.CrazyGames.SDK.game.happytime();
                    }
                  }
                  break;
                case 16:
                  $("#player-leaderboard").hide();
                  break;
                case 9:
                  e.preventDefault();
                  break;
                case 82:
                  if (!$("#toggle-shop-modal-button").hasClass("disabled")) {
                    document.getElementById("toggle-shop-modal-button").click();
                  }
                  break;
                case 70:
                  if (!$(".toggle-krew-list-modal-button").hasClass("disabled")) {
                    document.getElementById("toggle-krew-list-modal-button").click();
                  }
                  break;
                case 66:
                  if (!$(".toggle-bank-modal-button").hasClass("disabled")) {
                    document.getElementById("toggle-bank-modal-button").click();
                  }
                  break;
                case 74:
                  document.getElementsByClassName("toggle-ship-status-button")[0].click();
              }
            }
        }
      };
      class Md {
        constructor() {
          this.locked = false;
          this.lmb = false;
          this.rmb = false;
          this.cameraX = 0;
          this.cameraY = Math.PI;
          this.mouse = new THREE.Vector2();
          this.isMouseLookLocked = false;
          this.lastX = 0;
          this.lastY = 0;
          this.zoom = 0;
          if (Sd) {
            document.addEventListener("mousemove", this.mouseMoveUnlocked, false);
          } else {
            this.locked = true;
            document.addEventListener("mousemove", this.mouseMoveLocked, false);
          }
          this.mouseMoveUnlocked = e => {
            if (!lh) {
              this.mouse.x = e.clientX / window.innerWidth * 2 - 1;
              this.mouse.y = -e.clientY / window.innerHeight * 2 + 1;
              if (!Sd) {
                this.lastX = e.x;
                this.lastY = e.y;
              }
            }
          };
          this.mouseMoveLocked = e => {
            if (lh) {
              return;
            }
            e.preventDefault();
            let t = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
            let i = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
            if (Sd) {
              this.cameraX -= i * 0.0016;
              this.cameraY -= t * 0.0023;
            }
            if (!Sd) {
              t = e.x - this.lastX;
              i = e.y - this.lastY;
              this.cameraX -= i * 0.0082;
              this.cameraY -= t * 0.0064;
              this.lastX = e.x;
              this.lastY = e.y;
            }
            this.cameraX = Math.max(Math.PI / 2 * -1, Math.min(Math.PI / 2, this.cameraX));
          };
          this.onMouseDown = e => {
            switch (e.button) {
              case 0:
                if (nc.locked) {
                  this.lmb = true;
                }
                if (hc && e.target === pc.domElement) {
                  this.lockMouseLook();
                }
                break;
              case 2:
                if (nc.locked) {
                  this.rmb = true;
                }
                if (hc && e.target === pc.domElement) {
                  this.lockMouseLook();
                }
            }
          };
          this.onMouseUp = e => {
            switch (e.button) {
              case 0:
                this.lmb = false;
                break;
              case 2:
                this.rmb = false;
            }
            return false;
          };
          this.mouseWheelDown = e => {
            if (e.target === pc.domElement || e.target === document.body) {
              e.preventDefault();
            }
          };
          this.mouseWheelEvent = e => {
            if (hc && hc.geometry && hc.activeWeapon === 2 && (e.target === pc.domElement || e.target === document.body)) {
              this.zoom -= e.deltaY / 200;
              if (this.zoom > 10) {
                this.zoom = 10;
              }
              if (this.zoom < 0) {
                this.zoom = 0;
              }
            }
          };
          document.addEventListener("mousedown", this.onMouseDown);
          document.addEventListener("mouseup", this.onMouseUp);
          document.addEventListener("mouseweheel", this.mouseWheelDown);
          document.addEventListener("DOMouseScroll", this.mouseWheelDown);
          document.addEventListener("wheel", this.mouseWheelEvent);
          this.lockMouseLook = () => {
            if (!lh) {
              if (Sd) {
                let e = document.body;
                e.requestPointerLock = e.requestPointerLock || e.mozRequestPointerLock || e.webkitRequestPointerLock;
                e.requestPointerLock();
              }
              this.isMouseLookLocked = true;
            }
          };
          this.unLockMouseLook = () => {
            if (Sd) {
              document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock;
              document.exitPointerLock();
            }
            this.isMouseLookLocked = false;
          };
        }
      }
      window.oncontextmenu = () => false;
      let Sd = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
      if (Sd) {
        let e = document.body;
        let t = t => {
          if (document.pointerLockElement === e) {
            nc.locked = true;
            document.addEventListener("mousemove", nc.mouseMoveLocked, false);
            document.removeEventListener("mousemove", nc.mouseMoveUnlocked, false);
          } else {
            nc.locked = false;
            document.addEventListener("mousemove", nc.mouseMoveUnlocked, false);
            document.removeEventListener("mousemove", nc.mouseMoveLocked, false);
          }
        };
        document.addEventListener("pointerlockchange", t, false);
      } else {
        console.error("Your browser does not seem to support the pointer lock API.");
      }
      let Ed = e => {
        if (wc.hasOwnProperty(e.id)) {
          e.onDestroy();
          delete wc[e.id];
        }
      };
      class Td {
        constructor() {
          this.netType = -1;
          this.sendSnap = true;
          this.sendDelta = true;
          this.sendCreationSnapOnDelta = true;
          this.last = {};
          this.lastType = {};
          this.muted = [];
          this.parent = undefined;
          this.children = {};
          this.isNew = true;
          this.collisionRadius = 1;
          this.position = new THREE.Vector3(0, 0, 0);
          this.velocity = new THREE.Vector3(0, 0, 0);
          this.size = new THREE.Vector3(1, 1, 1);
          this.rotation = 0;
          this.modelscale = new THREE.Vector3(1, 1, 1);
          this.modeloffset = new THREE.Vector3(0, 0, 0);
          this.modelrotation = new THREE.Vector3(0, 0, 0);
          this.baseGeometry = undefined;
          this.baseMaterial = undefined;
        }
        addChildren(e) {
          this.children[e.id] = e;
          e.parent = this;
        }
        hasChild(e) {
          for (let t in this.children) {
            if (this.children[t].id === e) {
              return true;
            }
          }
          return false;
        }
        worldPos() {
          let e = new THREE.Vector3();
          e.copy(this.position);
          if (this.parent !== undefined) {
            e.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.parent.rotation);
            e.add(this.parent.worldPos());
          }
          return e;
        }
        toLocal(e) {
          let t = new THREE.Vector3();
          t.copy(e);
          t.sub(this.position);
          t.applyAxisAngle(new THREE.Vector3(0, 1, 0), -this.rotation);
          return t;
        }
        createBody() {
          this.geometry = new THREE.Object3D();
          mc.add(this.geometry);
          this.geometry.rotation.order = "YXZ";
          if (this.baseGeometry) {
            this.body = new THREE.Mesh(this.baseGeometry, this.baseMaterial);
            this.body.scale.set(this.modelscale.x, this.modelscale.y, this.modelscale.z);
            this.body.rotation.set(this.modelrotation.x, this.modelrotation.y, this.modelrotation.z);
            this.geometry.add(this.body);
            this.geometry.position.x = this.position.x;
            this.geometry.position.y = this.position.y;
            this.geometry.position.z = this.position.z;
          }
          if (this.baseModel) {
            this.body = this.baseModel.clone();
            this.body.rotation.set(this.modelrotation.x, this.modelrotation.y, this.modelrotation.z);
            this.geometry.add(this.body);
            this.geometry.position.x = this.position.x;
            this.geometry.position.y = this.position.y;
            this.geometry.position.z = this.position.z;
          }
          if (this.isPlayer) {
            if (ec.parent) {
              ec.parent.remove(ec);
            }
            ec.position.set(0, 1, 5);
            ec.rotation.z = 0;
            ec.rotation.y = 0;
            ec.rotation.x = -0.4;
            this.geometry.add(ec);
            this.geometry.add(this.crosshair);
          }
          if (this.netType === 0) {
            this.setPlayerBody(this.playerModel, this.hatModel);
          }
          this.clientlogic(0);
        }
        getDelta() {
          if (!this.sendDelta && !this.sendCreationSnapOnDelta) {
            return;
          }
          if (this.sendCreationSnapOnDelta) {
            this.sendCreationSnapOnDelta = false;
            return;
          }
          let e = {
            p: this.deltaCompare("p", this.parent ? this.parent.id : undefined),
            n: this.deltaCompare("n", this.netType),
            x: this.deltaCompare("x", Number(this.position.x.toFixed(2))),
            y: this.deltaCompare("y", Number(this.position.y.toFixed(2))),
            z: this.deltaCompare("z", Number(this.position.z.toFixed(2))),
            r: this.deltaCompare("r", Number(this.rotation.toFixed(2))),
            t: this.getTypeDelta()
          };
          if (Nh(e)) {
            e = undefined;
          }
          return e;
        }
        deltaCompare(e, t) {
          if (this.last[e] !== t && this.muted.indexOf(e) < 0) {
            this.last[e] = t;
            return t;
          }
        }
        deltaTypeCompare(e, t) {
          if (this.lastType[e] !== t) {
            this.lastType[e] = t;
            return t;
          }
        }
        clientlogic(e) {
          this.geometry.position.set(this.position.x, this.position.y, this.position.z);
          this.geometry.rotation.y = this.rotation;
        }
        parseSnap(e, t) {
          if (wc[e?.p]?.netType === 4) {
            wc[e.p].needsUpdate = true;
          }
          if (e.p && wc[e.p] && this.parent !== wc[e.p]) {
            let i;
            let n = wc[e.p];
            let a = this.parent;
            if (Fc === t && n !== a) {
              (e => {
                if (hc.clan !== "" && hc.clan !== undefined) {
                  $("#li-clan-chat").show();
                }
                if (hc.alliance !== "" && hc.alliance !== undefined) {
                  $("#li-alliance-chat").show();
                }
                if (Jl.Devs.includes(hc.name) || Jl.Admins.includes(hc.name) || Jl.Mods.includes(hc.name) || Jl.Helpers.includes(hc.name)) {
                  $("#li-staff-chat").show();
                }
                if (e != null) {
                  if (wc[e].netType === 5) {
                    $("#toggle-krew-list-modal-button").removeClass().addClass("btn btn-md enabled toggle-krew-list-modal-button");
                    $("#toggle-shop-modal-button").removeClass().addClass("btn btn-md enabled toggle-shop-modal-button");
                    if (wc[e].name === "Labrador") {
                      $("#toggle-bank-modal-button").removeClass().addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
                    } else {
                      $("#toggle-bank-modal-button").removeClass().addClass("btn btn-md disabled toggle-bank-modal-button").attr("data-tooltip", "Bank is available at Labrador");
                    }
                  } else if (wc[e].netType === 1 && wc[e].shipState === 3) {
                    $("#toggle-krew-list-modal-button").removeClass().addClass("btn btn-md enabled toggle-krew-list-modal-button");
                    $("#toggle-shop-modal-button").removeClass().addClass("btn btn-md enabled toggle-shop-modal-button");
                    if (wc[wc[e].anchorIslandId].name === "Labrador") {
                      $("#toggle-bank-modal-button").removeClass().addClass("btn btn-md enabled toggle-shop-modal-button").attr("data-tooltip", "Deposit or withdraw gold");
                    } else {
                      $("#toggle-bank-modal-button").removeClass().addClass("btn btn-md disabled toggle-bank-modal-button").attr("data-tooltip", "Bank is available at Labrador");
                    }
                  }
                }
              })(e.p);
            }
            if (n.netType !== 5) {
              i = this.geometry !== undefined && n.geometry !== undefined && a && a.geometry !== undefined ? n.geometry.worldToLocal(a.geometry.localToWorld(this.geometry.position)) : n.toLocal(this.worldPos());
              this.position.x = i.x;
              this.position.y = i.y;
              this.position.z = i.z;
            }
            n.addChildren(this);
            n.geometry.add(this.geometry);
            this.geometry.position.set(this.position.x, this.position.y, this.position.z);
            if (n.netType === 1) {
              n.krewMembers[this.id] = this.geometry.children[0];
            }
            if (hc && hc.isCaptain === false && hc.parent.netType === 5 && n.netType === 5 && a !== undefined && a.netType === 1 && a.shipState === 1) {
              $("#abandon-ship-button").hide();
              md();
            }
            if (this.isPlayer && this.parent && !this.isCaptain && this.parent.netType === 1) {
              if (this.parent.shipState === 3) {
                $("#exit-island-button").hide();
                $("#invite-div").hide();
              }
              $("#abandon-ship-button").show();
            }
          }
          if (e.t !== undefined) {
            this.parseTypeSnap(e.t);
          }
          if (!this.isPlayer) {
            if (e.x !== undefined) {
              this.position.x = parseFloat(e.x);
            }
            if (e.y !== undefined) {
              this.position.y = parseFloat(e.y);
            }
            if (e.z !== undefined) {
              this.position.z = parseFloat(e.z);
            }
            if (e.r !== undefined) {
              this.rotation = parseFloat(e.r);
            }
          }
          if (e.del !== undefined) {
            this.onDestroy();
            delete wc[this.id];
            delete kc[this.id];
          }
          if (e.t !== undefined && e.t.e !== undefined && e.t.e !== null) {
            if (e.t.e.l !== undefined && e.t.e.l !== this.level) {
              this.level = parseInt(e.t.e.l);
            }
            if (this.isPlayer) {
              if (e.t.e.e !== undefined && e.t.e.e !== this.experience) {
                this.experience = parseInt(e.t.e.e);
                this.experienceNeedsUpdate = true;
                this.updateExperience();
              }
              if (e.t.e.p.fr !== undefined && e.t.e.p.fr !== this.points.fireRate) {
                this.points.fireRate = parseInt(e.t.e.p.fr);
              }
              if (e.t.e.p.ds !== undefined && e.t.e.p.ds !== this.points.distance) {
                this.points.distance = parseInt(e.t.e.p.ds);
              }
              if (e.t.e.p.dm !== undefined && e.t.e.p.dm !== this.points.damage) {
                this.points.damage = parseInt(e.t.e.p.dm);
              }
            }
          }
        }
        onDestroy() {
          if (this.parent !== undefined) {
            let e = this.parent;
            if (e.children[this.id] !== undefined) {
              delete e.children[this.id];
            }
          }
          this.onClientDestroy();
          if (Lc[this.id] !== undefined) {
            delete Lc[this.id];
          }
          if (Rc[this.id] !== undefined) {
            delete Rc[this.id];
          }
        }
        onClientDestroy() {
          if (this.parent) {
            this.parent.geometry.remove(this.geometry);
          }
          mc.remove(this.geometry);
          if (this.line !== undefined) {
            mc.remove(this.line);
            this.line.geometry.dispose();
          }
          if (this.label !== undefined) {
            this.label.dispose();
            this.label.children[0].geometry.dispose();
            this.label.geometry.dispose();
          }
        }
        tick(e) {
          this.logic(e);
          this.position.x += this.velocity.x * e;
          this.position.z += this.velocity.z * e;
          this.clientlogic(e);
        }
      }
      class Cd extends Td {
        constructor(e, t) {
          let i;
          super();
          this.netType = 1;
          this.muted = ["x", "z", "y"];
          let n = "";
          if (wc[e] !== undefined) {
            n = wc[e].name;
            if (wc[e].parent !== undefined) {
              i = wc[e].parent.netType === 5 ? wc[e].parent.id : wc[e].parent.anchorIslandId;
            }
          }
          n = typeof n == "string" ? n : "";
          this.crewName = typeof t == "string" ? t : `${n}'${n.charAt(n.length - 1) === "s" ? "" : "s"} krew`;
          this.anchorIslandId = i;
          if (e && wc[e]) {
            this.captainId = e;
            this.clan = wc[e].clan;
          } else {
            this.captainId = "";
            this.clan = "";
          }
          this.setShipClass(0);
          this.arcFront = 0;
          this.arcBack = 0;
          this.krewMembers = {};
          this.krewCount = 0;
          this.recruiting = false;
          this.isLocked = false;
          this.departureTime = 5;
          this.steering = 0;
          this.shipState = -1;
          this.overall_kills = 0;
          this.overall_cargo = 0;
          this.overall_scores = 0;
          this.sinktimer = 0;
          this.rottimer = Math.random() * 5;
          this.leanvalue = 0;
          this.setName(this.crewName);
        }
        setName(e) {
          let t = "";
          if (wc[this.captainId]?.clan != null && wc[this.captainId]?.clan != "") {
            t = `[${wc[this.captainId].clan}] `;
          }
          if (this.geometry !== undefined) {
            if (this.label === undefined) {
              this.label = new THREE.TextSprite({
                textSize: 4,
                redrawInterval: Jl.Labels.redrawInterval,
                texture: {
                  text: t + e,
                  fontFamily: Jl.Labels.fontFamily
                },
                material: {
                  color: xh.boat,
                  fog: false,
                  depthTest: false
                }
              });
              this.label.name = "label";
              this.label.position.set(0, Zl[this.shipclassId].labelHeight, 0);
              for (let e = this.geometry.children.length; e--;) {
                if (this.geometry.children[e].isTextSprite && this.geometry.children[e].name === "label") {
                  this.geometry.remove(this.geometry.children[e]);
                }
              }
              this.geometry.add(this.label);
            } else {
              this.label.material.map.text = t + e;
            }
            this.label.visible = hc && hc.parent && this.id !== hc.parent.id && this[Jl.Labels.boats.useMethod];
          }
          this.crewName = e;
        }
        updateProps() {
          let e = 0;
          for (let t in this.children) {
            if (wc[t] === undefined || wc[t].parent === undefined || wc[t].parent.id !== this.id) {
              delete this.children[t];
              continue;
            }
            let i = this.children[t];
            if (i && i.netType === 0) {
              e += 1;
            }
          }
          this.krewCount = e;
          if (this.krewCount === 0) {
            Ed(this);
          }
        }
        setShipClass(e) {
          this.shipclassId = e;
          let t = Zl[e];
          this.maxHp = t.hp;
          this.hp = this.maxHp;
          this.turnspeed = t.turnspeed;
          this.maxKrewCapacity = t.maxKrewCapacity;
          this.size.set(t.width, t.height, t.depth);
          this.arcFront = t.arcFront;
          this.arcBack = t.arcBack;
          this.inertia = t.inertia;
          this.collisionRadius = t.radius;
          this.speed = t.speed;
          this.shipState = 2;
          this.speedOffset = 0;
          this.changeBoatModel(this.shipclassId);
          if (this.label !== undefined) {
            this.label.position.set(0, Zl[this.shipclassId].labelHeight, 0);
          }
          if (hc !== undefined && this === hc.parent) {
            nd.showCenterMessage(`Ship changed to ${Zl[this.shipclassId].name}`, 3);
            fd();
          }
        }
        getKrewOnBoard() {
          for (let e in this.children) {
            if (this.children[e].parent && this.children[e].parent.id === this.id) {
              this.geometry.add(this.children[e].geometry);
              this.children[e].position.x = 0;
              this.children[e].position.y = 0;
              this.children[e].position.z = 0;
            }
            if (this.children[e].parent === undefined || this.children[e].parent.id !== this.id) {
              delete this.children[e];
            }
          }
        }
        getHeightAboveWater() {
          return Zl[this.shipclassId].baseheight * (0.2 + this.hp / this.maxHp * 0.8) - this.sinktimer;
        }
        enterIsland(e) {
          if (this.shipState === 0) {
            this.shipState = 1;
          }
          this.anchorIslandId = e;
        }
        exitIsland() {
          this.shipState = 0;
          this.recruiting = false;
          this.departureTime = 5;
          if (this.anchorIslandId) {
            this.rotation = rotationToObject(this, wc[this.anchorIslandId]);
            let e = zh(this.rotation);
            this.position.x = wc[this.anchorIslandId].position.x - e.x * (wc[this.anchorIslandId].dockRadius + 5);
            this.position.z = wc[this.anchorIslandId].position.z - e.y * (wc[this.anchorIslandId].dockRadius + 5);
          }
          this.anchorIslandId = undefined;
        }
        exitMotherShip() {
          this.rotation = rotationToObject(this, mothership);
          let e = zh(this.rotation);
          this.position.x = mothership.position.x - e.x * (mothership.collisionRadius + 5);
          this.position.z = mothership.position.z - e.y * (mothership.collisionRadius + 5);
        }
        changeBoatModel(e) {
          if (this.geometry !== undefined && Zl[e] !== undefined) {
            if (this.body) {
              this.geometry.remove(this.body);
            }
            if (this.sail) {
              this.geometry.remove(this.sail);
            }
            if (this.mast) {
              this.geometry.remove(this.mast);
            }
            this.body = Zl[e].body.clone();
            this.body.material = Zl[e].body.material.clone();
            this.body.material.transparent = true;
            this.body.scale.set(Zl[e].scale[0], Zl[e].scale[1], Zl[e].scale[2]);
            this.body.position.set(Zl[e].offset[0], Zl[e].offset[1], Zl[e].offset[2]);
            this.body.rotation.set(Zl[e].rotation[0], Zl[e].rotation[1], Zl[e].rotation[2]);
            this.geometry.add(this.body);
            if (Zl[e].sail) {
              this.sail = Zl[e].sail.clone();
              this.sail.material = Zl[e].sail.material.clone();
              this.sail.material.transparent = true;
              this.sail.scale.set(Zl[e].scale[0], Zl[e].scale[1], Zl[e].scale[2]);
              this.sail.position.set(Zl[e].offset[0], Zl[e].offset[1], Zl[e].offset[2]);
              this.sail.rotation.set(Zl[e].rotation[0], Zl[e].rotation[1], Zl[e].rotation[2]);
              this.geometry.add(this.sail);
            }
            if (Zl[e].mast) {
              this.mast = Zl[e].mast.clone();
              this.mast.material = Zl[e].mast.material.clone();
              this.mast.material.transparent = true;
              this.mast.scale.set(Zl[e].scale[0], Zl[e].scale[1], Zl[e].scale[2]);
              this.mast.position.set(Zl[e].offset[0], Zl[e].offset[1], Zl[e].offset[2]);
              this.mast.rotation.set(Zl[e].rotation[0], Zl[e].rotation[1], Zl[e].rotation[2]);
              this.geometry.add(this.mast);
            }
          }
        }
        getTypeDelta() {
          let e = {
            h: this.deltaTypeCompare("h", this.hp),
            s: this.deltaTypeCompare("s", this.steering.toFixed(4)),
            c: this.deltaTypeCompare("c", this.shipclassId),
            b: this.deltaTypeCompare("b", this.captainId),
            t: this.deltaTypeCompare("t", this.shipState),
            a: this.deltaTypeCompare("a", this.anchorIslandId),
            k: this.deltaTypeCompare("k", this.krewCount),
            e: this.deltaTypeCompare("e", this.speed),
            sO: this.deltaTypeCompare("sO", this.speedOffset),
            r: this.deltaTypeCompare("r", this.recruiting),
            l: this.deltaTypeCompare("l", this.isLocked),
            cD: this.deltaTypeCompare("cD", this.cargoLocked),
            d: this.deltaTypeCompare("d", this.departureTime)
          };
          if (Nh(e)) {
            e = undefined;
          }
          return e;
        }
        logic(e) {
          let t = false;
          if (this.position.x > Jl.worldsize) {
            this.position.x = Jl.worldsize;
            t = true;
          }
          if (this.position.z > Jl.worldsize) {
            this.position.z = Jl.worldsize;
            t = true;
          }
          if (this.position.x < 0) {
            this.position.x = 0;
            t = true;
          }
          if (this.position.z < 0) {
            this.position.z = 0;
            t = true;
          }
          let i = wc[this.captainId];
          if (i !== undefined && this.crewName !== undefined) {
            this.speed = Zl[this.shipclassId].speed + this.speedOffset + parseFloat(i.movementSpeedBonus / 100);
          }
          let n = new THREE.Vector3(0, 0, this.speed);
          if (this.shipState === 0) {
            this.rotation += i !== undefined ? this.steering * e * 0.4 * (this.turnspeed + parseFloat(i.movementSpeedBonus * 0.05 / 100)) : this.steering * e * 0.4 * this.turnspeed;
            n.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
          } else {
            n.set(0, 0, 0);
          }
          this.velocity = n;
          this.leanvalue += (this.steering * 4 - this.leanvalue) * e;
          this.rottimer += e;
          if (hc && hc.parent && this.sail) {
            this.sail.material.visible = this.id !== hc.parent.id || Kc;
          }
          if (hc && hc.parent && this.mast) {
            this.mast.material.visible = this.id !== hc.parent.id || Kc;
          }
          if (!this.body || this.shipState !== 3 && this.shipState !== -1 && this.shipState !== 4) {
            this.body.material.opacity = 1;
            if (this.sail) {
              this.sail.material.opacity = 0.9;
            }
            if (this.mast) {
              this.mast.material.opacity = 0.9;
            }
          } else {
            this.rottimer = 0;
            this.leanvalue = 0;
            if (this.body.material.opacity >= 0.5) {
              this.body.material.opacity -= 0.0075;
            }
            if (this.sail && this.sail.material.opacity >= 0.5) {
              this.sail.material.opacity -= 0.0075;
            }
            if (this.mast && this.mast.material.opacity >= 0.5) {
              this.mast.material.opacity -= 0.0075;
            }
          }
          this.geometry.rotation.x = Math.sin(this.rottimer * 0.5 + 3) * Math.sin(this.rottimer) * 0.05;
          this.geometry.rotation.z = Math.sin(this.rottimer * 1) * 0.05 - this.leanvalue * 0.08;
          if (this.hp < 1) {
            if (hc && hc.parent === this) {
              Ud.playAudioFile(false, false, 1, "sink-crash");
              $("#shopping-modal").hide();
              $("#show-shopping-modal-button").hide();
            }
            this.sinktimer += e;
            if (this.sinktimer > 4) {
              Ed(this);
            }
          }
        }
        clientlogic() {
          this.position.y = this.getHeightAboveWater();
          let e = new THREE.Vector3(this.position.x, this.position.y, this.position.z);
          this.geometry.position.lerp(e, 0.5);
          this.geometry.rotation.y = Dh(this.geometry.rotation.y, this.rotation, 0.5);
        }
        parseTypeSnap(e) {
          if (e.h !== undefined && e.h !== this.hp) {
            this.hp = parseInt(e.h);
          }
          if (e.s !== undefined) {
            this.steering = parseFloat(e.s);
          }
          if (e.c !== undefined && e.c !== this.shipclassId || this.body === undefined) {
            this.setShipClass(e.c);
          }
          if (e.a !== undefined && e.a !== this.anchorIslandId) {
            this.anchorIslandId = e.a;
          }
          if (e.k !== undefined && e.k !== this.krewCount) {
            this.krewCount = e.k;
          }
          if (e.b !== undefined && this.captainId !== e.b) {
            this.captainId = e.b;
          }
          if (e.e !== undefined && this.speed !== e.e) {
            this.speed = parseFloat(e.e);
          }
          if (e.sO !== undefined && this.speedOffset !== e.sO) {
            this.speedOffset = parseFloat(e.sO);
          }
          if (e.r !== undefined && this.recruiting !== e.r) {
            this.recruiting = Ih(e.r);
          }
          if (e.l !== undefined && this.isLocked !== e.r) {
            this.isLocked = Ih(e.l);
          }
          if (e.d !== undefined && this.departureTime !== e.d) {
            this.departureTime = parseInt(e.d);
          }
          if (e.t !== undefined && this.shipState !== e.t) {
            this.shipState = parseInt(e.t);
            if (this.shipState === 0) {
              this.getKrewOnBoard();
            }
          }
          if (e.cS !== undefined && this.cargoSize !== e.cS) {
            this.cargoSize = e.cS;
          }
          if (e.hP !== undefined && this.maxHp !== e.hP) {
            this.maxHp = e.hP;
          }
          if (e.kM !== undefined && this.maxKrewCapacity !== e.kM) {
            this.maxKrewCapacity = e.kM;
          }
        }
        onDestroy() {
          this.children = {};
          Td.prototype.onDestroy.call(this);
          if (xc[this.id]) {
            delete xc[this.id];
          }
        }
      }
      class kd extends Td {
        constructor(e, t, i) {
          super();
          this.netType = 3;
          this.sendDelta = false;
          this.sendSnap = false;
          this.sendCreationSnapOnDelta = true;
          this.timeout = 1;
          this.size = new THREE.Vector3(1, 1, 1);
          this.position.x = t;
          this.position.y = 0;
          this.position.z = i;
          this.impactType = e;
          switch (e) {
            case 0:
              this.baseGeometry = bh.sphere;
              this.baseMaterial = yh.impact_water;
              for (let e = 0; e < 3; ++e) {
                Id({
                  vx: Math.random() * 10 - 5,
                  vy: 4 + Math.random() * 2,
                  vz: Math.random() * 10 - 5,
                  x: t,
                  z: i,
                  y: 0,
                  w: 0.3,
                  h: 0.3,
                  d: 0.3,
                  gravity: 5,
                  rotaSpeed: Math.random() * 20,
                  duration: 5,
                  sizeSpeed: -0.6,
                  material: yh.impact_water,
                  geometry: bh.box
                });
              }
              break;
            case 1:
              for (let e = 0; e < 5; ++e) {
                Id({
                  vx: Math.random() * 20 - 10,
                  vy: 5 + Math.random() * 5,
                  vz: Math.random() * 20 - 10,
                  x: t,
                  z: i,
                  y: 0,
                  w: 0.2 + Math.random() * 0.5,
                  h: 0.2 + Math.random() * 0.5,
                  d: 0.2 + Math.random() * 0.5,
                  gravity: 12,
                  rotaSpeed: Math.random() * 10,
                  duration: 2,
                  sizeSpeed: -0.8,
                  material: yh.splinter,
                  geometry: bh.box
                });
              }
          }
        }
        getTypeDelta() {
          this.spawnPacket ||= true;
        }
        logic(e) {
          this.timeout -= e * 0.8;
          if (this.timeout <= 0) {
            Ed(this);
          }
        }
        clientlogic(e) {
          if (this.impactType === 0) {
            this.geometry.position.set(this.position.x, this.position.y, this.position.z);
            this.geometry.scale.y = (this.timeout < 0.5 ? Ph(this.timeout * 2) : 1 - (t = (this.timeout - 0.5) * 2) * t * t * t * t) * 5;
            let e = Ph(this.timeout);
            this.geometry.scale.x = 1.5 - e;
            this.geometry.scale.z = 1.5 - e;
          }
          var t;
        }
        parseTypeSnap(e) {
          if (e.a !== undefined) {
            this.impactType = parseFloat(e.a);
          }
        }
      }
      class Ad extends Td {
        constructor(e, t, i, n) {
          super();
          this.netType = 5;
          this.sendDelta = false;
          this.sendSnap = false;
          this.sendCreationSnapOnDelta = true;
          this.name = n.name || "";
          this.setName(this.name);
          this.dockRadius = n.dockRadius;
          this.collisionRadius = 30;
          this.size = new THREE.Vector3(this.dockRadius, 20, this.dockRadius);
          this.position.x = t;
          this.position.z = i;
          this.baseModel = Tc[this.name.toLowerCase()];
          this.baseModel.children[0].material = yh.island;
          this.visualCue = new THREE.Mesh(new THREE.RingBufferGeometry(this.dockRadius - 1, this.dockRadius, 30), yh.islandradius);
          this.visualCue.rotation.x = -Math.PI / 2;
          this.visualCue.position.set(this.position.x, 1, this.position.z);
          mc.add(this.visualCue);
          this.landmarkType = e;
          this.wavetimer = 0;
          for (const e of Jl.christmasTree) {
            if (e === this.name) {
              this.christmasTree = Tc.christmasTree;
              this.christmasTree.position.set(this.position.x - this.dockRadius / 10, this.dockRadius / 50, this.position.z - this.dockRadius / 10);
              this.christmasTree.scale.x = this.dockRadius / (100 / 0.35);
              this.christmasTree.scale.y = this.dockRadius / (100 / 0.35);
              this.christmasTree.scale.z = this.dockRadius / (100 / 0.35);
              mc.add(this.christmasTree);
            }
          }
          for (const e of Jl.snowman) {
            if (e === this.name) {
              this.snowman = Tc.snowman;
              this.snowman.position.set(this.position.x + this.dockRadius / (10 / 3), this.dockRadius / (100 / 38), this.position.z + this.dockRadius / (100 / 35));
              this.snowman.rotation.set(0, -500, 0);
              this.snowman.scale.x = this.dockRadius / (100 / 0.17);
              this.snowman.scale.y = this.dockRadius / (100 / 0.17);
              this.snowman.scale.z = this.dockRadius / (100 / 0.17);
              mc.add(this.snowman);
            }
          }
        }
        setName(e) {
          if (this.geometry !== undefined) {
            if (this.label === undefined) {
              this.label = new THREE.TextSprite({
                textSize: 12,
                redrawInterval: Jl.Labels.redrawInterval,
                texture: {
                  text: e,
                  fontFamily: Jl.Labels.fontFamily
                },
                material: {
                  color: xh.landmark,
                  fog: false
                }
              });
              this.label.name = "label";
              this.label.position.set(0, 42, 0);
              this.geometry.add(this.label);
            }
            this.label.material.map.text = e;
            this.label.visible = this.inRange;
          }
          this.name = e;
        }
        logic(e) {}
        clientlogic(e) {
          this.wavetimer += e;
          let t = 0.5 + Math.sin(this.wavetimer) * 0.5;
          bc.position.y = 0.1 + t * 0.5;
        }
        parseTypeSnap(e) {}
      }
      class Ld extends Td {
        constructor(e, t, i, n) {
          super();
          this.netType = 4;
          this.sendDelta = n !== 1;
          this.sendSnap = n !== 1;
          this.sendCreationSnapOnDelta = true;
          this.spawnPacket = false;
          this.pickerId = "";
          this.type = n;
          this.picking = n === 1;
          this.catchingFish = false;
          this.needsUpdate = true;
          let a = 1;
          if (n === 0) {
            a = parseInt(e) + 1;
          }
          this.size = new THREE.Vector3(a, a, a);
          this.modelscale = new THREE.Vector3(a, a, a);
          this.pickupSize = e;
          this.position.x = t;
          this.position.z = i;
          switch (this.type) {
            case 0:
              this.baseGeometry = bh.box;
              this.baseMaterial = yh.crate;
              this.modelscale = new THREE.Vector3(a, a, a);
              break;
            case 1:
              this.baseModel = Tc.fish;
              break;
            case 2:
              if (Math.round(Math.random())) {
                this.baseModel = Tc.shell;
              } else {
                this.baseModel = Tc.starfish;
              }
              break;
            case 3:
              this.baseModel = Tc.crab;
              break;
            case 4:
              this.baseModel = Tc.chest;
              break;
            case 5:
              this.baseModel = Tc.goldenFish;
          }
          if (this.type <= 1 || this.type === 4) {
            this.floattimer = this.type === 0 ? Math.random() * 5 : Math.random() * 5 + 0.5;
            this.rotationspeed = Math.random() * 0.5 + 0.5;
          } else {
            this.floattimer = 1;
            this.rotationspeed = 0;
          }
        }
        setName() {
          if (this.geometry !== undefined) {
            if (this.label === undefined) {
              this.label = new THREE.TextSprite({
                textSize: 3,
                redrawInterval: Jl.Labels.redrawInterval,
                texture: {
                  text: this.id,
                  fontFamily: Jl.Labels.fontFamily
                },
                material: {
                  color: xh.player,
                  fog: false
                }
              });
              this.label.name = "label";
              this.label.position.set(0, 3, 0);
              this.geometry.add(this.label);
            }
            this.label.material.map.text = this.id;
          }
        }
        getTypeDelta() {
          if (this.type !== 1 && this.type !== 5) {
            let e = {
              s: this.deltaTypeCompare("s", this.pickupSize),
              p: this.deltaTypeCompare("p", this.picking),
              i: this.deltaTypeCompare("i", this.pickerId),
              t: this.deltaTypeCompare("t", this.type)
            };
            if (Nh(e)) {
              e = undefined;
            }
            return e;
          }
          this.spawnPacket ||= true;
        }
        logic(e) {}
        clientlogic(e) {
          this.floattimer += e * 3;
          this.geometry.rotation.x += e * this.rotationspeed;
          this.geometry.rotation.z += e * this.rotationspeed;
          if (this.picking === true && wc[this.pickerId]) {
            if (wc[this.pickerId].geometry) {
              let e = wc[this.pickerId].geometry.getWorldPosition(new THREE.Vector3());
              if (this.type === 0 || this.type === 4) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(e), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);
                if (hc && this.pickerId === hc.id && this.geometry.scale.x <= 0.05 && this.geometry.scale.x > 0) {
                  Ud.playAudioFile(false, false, 1, "get-crate");
                }
              }
              if (this.type === 1 || this.type === 5) {
                if (this.catchingFish) {
                  this.geometry.translateOnAxis(this.geometry.worldToLocal(e), 0.05);
                } else {
                  this.geometry.position.y += 0.5;
                }
                if (this.geometry.position.y >= 20) {
                  this.catchingFish = true;
                  if (hc && this.pickerId === hc.id) {
                    Ud.playAudioFile(false, false, 1, "catch-fish");
                  }
                }
                this.geometry.scale.set(this.geometry.scale.x - 0.009, this.geometry.scale.y - 0.009, this.geometry.scale.z - 0.009);
              }
              if (this.type === 2) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(e), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);
                if (wc[this.pickerId] !== undefined && wc[this.pickerId].gold > 500 && wc[this.pickerId].parent !== undefined && wc[this.pickerId].parent.netType !== 1) {
                  bd.hideSuggestionBox = false;
                }
              }
              if (this.type === 3) {
                this.geometry.translateOnAxis(this.geometry.worldToLocal(e), 0.05);
                this.geometry.scale.set(this.geometry.scale.x - 0.05, this.geometry.scale.y - 0.05, this.geometry.scale.z - 0.05);
                if (hc && this.pickerId === hc.id) {
                  Ud.playAudioFile(false, false, 1, "catch-crab");
                }
                if (wc[this.pickerId] !== undefined && wc[this.pickerId].gold > 500 && wc[this.pickerId].parent !== undefined && wc[this.pickerId].parent.netType !== 1) {
                  bd.hideSuggestionBox = false;
                }
              }
            }
          } else {
            if (this.type === 2 || this.type === 3) {
              this.dockedLogic();
            }
            if (this.type === 3 && this.geometry !== undefined) {
              if (Math.round(this.geometry.position.x) !== Math.round(this.position.x) || Math.round(this.geometry.position.z) !== Math.round(this.position.z)) {
                this.geometry.lookAt(this.position.x, this.actualY || this.position.y, this.position.z);
                if (Math.round(this.geometry.position.x) !== Math.round(this.position.x)) {
                  this.geometry.position.setX(Dh(this.geometry.position.x, this.position.x, 0.01));
                }
                if (Math.round(this.geometry.position.z) !== Math.round(this.position.z)) {
                  this.geometry.position.setZ(Dh(this.geometry.position.z, this.position.z, 0.01));
                }
              }
            }
          }
        }
        dockedLogic() {
          if (this.timeCounters.dockedLogic === undefined) {
            this.timeCounters.dockedLogic = {
              time: performance.now(),
              previousTime: performance.now()
            };
          } else {
            this.timeCounters.dockedLogic.time = performance.now();
          }
          if (this.timeCounters.dockedLogic.time - this.timeCounters.dockedLogic.previousTime > 2000) {
            this.timeCounters.dockedLogic.previousTime = this.timeCounters.dockedLogic.time;
            for (let e in wc) {
              let t = wc[e];
              if (t.netType === 4 && t.needsUpdate && (t.type === 2 || t.type === 3)) {
                const e = new THREE.Raycaster();
                const i = [];
                if (wc) {
                  const n = t.geometry.getWorldPosition(new THREE.Vector3()).clone();
                  e.set(new THREE.Vector3(n.x, 100, n.z), new THREE.Vector3(0, -1, 0));
                  for (let e in wc) {
                    if (wc[e].netType === 5) {
                      i.push(wc[e].geometry.children[0].children[0]);
                    }
                  }
                  let a = 0;
                  const r = e.intersectObjects(i);
                  if (r.length > 0) {
                    for (const e of r) {
                      if (e.point.y > a) {
                        a = e.point.y;
                      }
                    }
                  }
                  t.position.y = a;
                  t.actualY = a;
                  t.position.setY(a);
                  t.geometry.position.setY(a);
                  t.needsUpdate = false;
                }
              }
            }
          }
        }
        parseTypeSnap(e) {
          if (e.s !== undefined && e.s !== this.pickupSize) {
            this.pickupSize = parseInt(e.s);
          }
          if (e.p !== undefined && e.p !== this.picking) {
            this.picking = Ih(e.p);
          }
          if (e.i !== undefined && e.i !== this.pickerId) {
            this.pickerId = e.i;
          }
          if (e.t !== undefined && e.t !== this.type) {
            this.type = parseInt(e.t);
          }
        }
        onDestroy() {
          Td.prototype.onDestroy.call(this);
          if (Cc[this.id]) {
            delete Cc[this.id];
          }
        }
      }
      Ld.prototype.timeCounters = {};
      class Rd extends Td {
        constructor(e) {
          super();
          this.netType = 0;
          this.name = e !== undefined && e.name || "";
          this.setName(this.name);
          this.state = 0;
          this.isLoggedIn = e.t.l;
          this.position.y = 0;
          this.pitch = 0;
          this.size = wh.sizePlayer;
          this.walkForward = 0;
          this.walkSideward = 0;
          this.isFishing = false;
          this.activeWeapon = 0;
          this.use = false;
          this.cooldown = 0;
          this.rodRotationSpeed = Math.random() * 0.25 + 0.25;
          this.score = 50;
          this.overall_cargo = 0;
          this.gold = (e.startingItems || {}).gold || 0;
          this.shipsSank = 0;
          this.checkedItemsList = false;
          this.isCaptain = false;
          this.oldCaptainState = false;
          this.jumping = 0;
          this.jump_count = 0;
          this.jump = 0;
          this.jumpVel = 0;
          this.itemId = undefined;
          this.attackSpeedBonus = 0;
          this.movementSpeedBonus = 0;
          this.level = 0;
          this.experience = 0;
          this.experienceBase = 100;
          this.experienceMaxLevel = 50;
          this.experienceNeedsUpdate = true;
          this.points = {
            fireRate: 0,
            distance: 0,
            damage: 0
          };
          this.bank = {
            deposit: 0
          };
          this.clan = e.t.cl === "" ? undefined : e.t.cl;
          this.clanLeader = e.t.cll;
          this.clanOwner = e.t.clo;
          this.clanRequest = e.t.cr;
          this.alliance = e.t.al === "" ? undefined : e.t.al;
          this.allianceOwner = e.t.alo;
          kc[e.id] ||= this.name;
          this.notifiscationHeap = {};
          this.notifiscationDesk;
          this.reaction;
          this.crosshair = new THREE.TextSprite({
            textSize: 0.0365,
            redrawInterval: 10,
            texture: {
              text: "+",
              fontFamily: Jl.Labels.fontFamily
            },
            material: {
              color: xh.crosshair,
              fog: false
            }
          });
          this.pointsFormula = {
            getFireRate: () => this.points.fireRate * 1.4,
            getDistance: () => this.points.distance * 0.75,
            getDamage: () => this.points.damage * 0.75,
            getExperience: e => parseInt(e * 2.4)
          };
          this.experienceNeededForLevels = function (e) {
            let t = {
              0: {
                amount: 0,
                total: 0
              },
              1: {
                amount: e.experienceBase,
                total: e.experienceBase
              }
            };
            for (let i = 1; i < e.experienceMaxLevel + 1; i++) {
              t[i + 1] = {};
              t[i + 1].amount = Math.ceil(t[i].amount * 1.07);
              t[i + 1].total = t[i + 1].amount + t[i].total;
            }
            return t;
          }(this);
        }
        setName(e) {
          if (this.geometry !== undefined) {
            let t = "";
            if (this.clan !== undefined && this.clan !== "") {
              t = `[${this.clan}] `;
            }
            let i;
            let n = hc.parent !== undefined && hc.parent.netType === 1;
            let a = Jl.Devs.includes(this.name);
            let r = Jl.Admins.includes(this.name);
            let s = Jl.Mods.includes(this.name);
            let o = Jl.Helpers.includes(this.name);
            i = a ? xh.dev : r ? xh.admin : s ? xh.mod : o ? xh.helper : this.isPlayer ? xh.myself : hc !== undefined && hc.clan !== undefined && hc.clan !== "" && hc.clan === wc[this.id].clan ? xh.clan : hc !== undefined && hc.alliance !== undefined && hc.alliance !== "" && hc.alliance === wc[this.id].alliance ? xh.alliance : hc !== undefined && n && wc[this.id].parent !== undefined && hc.parent.id === wc[this.id].parent.id && wc[hc.parent.id] !== undefined && wc[hc.parent.id].captainId === this.id ? xh.captain : hc !== undefined && n && wc[this.id].parent !== undefined && hc.parent.id === wc[this.id].parent.id ? xh.krewmate : xh.player;
            const l = `${t + (a ? "[Dev] " : r ? "[Admin] " : s ? "[Mod] " : o ? "[Helper] " : "") + e} (Level ${this.level})`;
            if (this.label === undefined) {
              this.label = new THREE.TextSprite({
                textSize: 0.6,
                redrawInterval: Jl.Labels.redrawInterval,
                texture: {
                  text: l,
                  fontFamily: Jl.Labels.fontFamily
                },
                material: {
                  color: i,
                  fog: false
                }
              });
              this.label.name = "label";
              this.label.position.set(0, 2.3, 1.5);
              this.geometry.add(this.label);
            } else {
              this.label.material.color = i;
              this.label.material.map.text = l;
            }
            this.label.visible = hc && hc.parent && this.inRange && this.parent !== undefined && (this.parent.netType === 5 || this.parent.inRange);
          }
          this.name = e;
        }
        showReaction(e) {
          let t = new THREE.SpriteMaterial({
            map: Pc["_" + e],
            side: THREE.DoubleSide,
            transparent: true,
            depthWrite: false
          });
          this.reaction = new THREE.Sprite(t);
          this.reaction.name = "reaction";
          this.reaction.position.set(0, 4, 0);
          this.reaction.scale.set(3, 3, 3);
          this.geometry.add(this.reaction);
          this.reactionRemoveTimeout = setTimeout(() => {
            this.removeReaction();
          }, 10000);
        }
        removeReaction() {
          if (this.reaction != null) {
            clearTimeout(this.reactionRemoveTimeout);
            this.geometry.remove(this.reaction);
            delete this.reaction;
          }
        }
        setPlayerBody(e, t) {
          let i = (e = e || 0) < 0 ? Oc[e * -1 - 1] : Ic[e];
          this.playerBody = i.body.clone();
          this.playerBody.rotation.set(i.rotation.x, i.rotation.y, i.rotation.z);
          this.geometry.add(this.playerBody);
          this.geometry.receiveShadow = true;
          this.weapon = Tc.cannon.clone();
          this.weapon.position.set(0, 0, -0.4);
          this.weapon.rotation.set(0, 0, 0);
          this.weapon.name = "body";
          this.geometry.add(this.weapon);
          t = t || 0;
          this.captainHat = zc[t].clone();
          this.captainHat.name = "captainHat";
        }
        notifiscation() {
          if (!this.notifiscationDesk) {
            this.notifiscationDesk = new THREE.Mesh();
            this.notifiscationDesk.position.set(0, 0, 0);
            this.geometry.add(this.notifiscationDesk);
          }
          for (let e in this.notifiscationHeap) {
            if (this.notifiscationHeap[e].isNew) {
              this.notifiscationHeap[e].sprite = new THREE.TextSprite({
                textSize: this.notifiscationHeap[e].type === 1 ? 0.6 : 0.9,
                redrawInterval: 10,
                texture: {
                  text: this.notifiscationHeap[e].text,
                  fontFamily: Jl.Labels.fontFamily
                },
                material: {
                  color: this.notifiscationHeap[e].type === 1 ? 16766720 : 6487808,
                  fog: false,
                  opacity: 0
                }
              });
              this.notifiscationHeap[e].sprite.position.set(3, 1, 0);
              this.notifiscationDesk.add(this.notifiscationHeap[e].sprite);
              this.notifiscationHeap[e].isNew = false;
            } else {
              this.notifiscationDesk.rotation.x = -this.geometry.rotation.x;
              this.notifiscationHeap[e].sprite.position.y += 0.05;
              if (this.notifiscationHeap[e].sprite.position.y > 6) {
                this.notifiscationHeap[e].sprite.children[0].geometry.dispose();
                this.notifiscationHeap[e].sprite.geometry.dispose();
                this.notifiscationHeap[e].sprite.dispose();
                this.notifiscationDesk.remove(this.notifiscationHeap[e].sprite);
                delete this.notifiscationHeap[e];
              } else if (this.notifiscationHeap[e].sprite.position.y < 3) {
                this.notifiscationHeap[e].sprite.material.opacity += 0.025;
              }
            }
          }
        }
        updateExperience(e) {
          let t = this.experience;
          let i = 0;
          if (typeof e == "number") {
            t += this.pointsFormula.getExperience(e);
          }
          if (t > this.experienceNeededForLevels[this.experienceMaxLevel].total) {
            t = this.experienceNeededForLevels[this.experienceMaxLevel].total;
          }
          for (let e in this.experienceNeededForLevels) {
            if (t < this.experienceNeededForLevels[e].total) {
              break;
            }
            i = e;
          }
          i = parseInt(i);
          this.level = i;
          this.experience = t;
          if (bd !== undefined && this.experienceNeedsUpdate) {
            ed();
            this.experienceNeedsUpdate = false;
          }
        }
        changeWeapon() {
          if (this.weapon && this.activeWeapon === 0) {
            this.geometry.remove(this.weapon);
            this.weapon = Tc.cannon.clone();
            if (this.isPlayer) {
              Ud.playAudioFile(false, true, 1, "switch-rod-cannon");
            }
            this.weapon.position.set(0, 0.1, -0.8);
            this.weapon.rotation.set(0, 0, 0);
            this.weapon.name = "body";
            this.geometry.add(this.weapon);
          } else if (this.weapon && this.activeWeapon === 1) {
            this.geometry.remove(this.weapon);
            this.weapon = Tc.fishingrod.clone();
            if (this.isPlayer) {
              Ud.playAudioFile(false, true, 1, "switch-rod-cannon");
            }
            this.weapon.position.set(0, 0.1, -0.7);
            this.weapon.name = "body";
            this.geometry.add(this.weapon);
          } else if (this.weapon && this.activeWeapon === 2) {
            this.geometry.remove(this.weapon);
            if (this.isPlayer) {
              Ud.playAudioFile(false, true, 1, "switch-rod-cannon");
            }
            this.weapon = Tc.spyglass.clone();
            this.weapon.position.set(0, 0.85, -0.15);
            this.weapon.rotation.set(0.5, Math.PI / 2 + 0.07, 0.5);
            this.weapon.name = "body";
            this.geometry.add(this.weapon);
          }
        }
        tryJump() {
          if (!(this.jumpVel > 0) && !(this.jump > 0)) {
            this.jumpVel = 16;
          }
        }
        getTypeDelta() {
          let e = {
            f: this.deltaTypeCompare("f", this.walkForward),
            s: this.deltaTypeCompare("s", this.walkSideward),
            u: this.deltaTypeCompare("u", this.use),
            p: this.deltaTypeCompare("p", this.pitch.toFixed(2)),
            j: this.deltaTypeCompare("j", this.jumping),
            w: this.deltaTypeCompare("w", this.activeWeapon),
            c: this.deltaTypeCompare("c", this.checkedItemsList),
            d: this.deltaTypeCompare("d", this.itemId),
            v: this.deltaTypeCompare("v", this.availablePoints)
          };
          if (Nh(e)) {
            e = undefined;
          }
          return e;
        }
        logic(e) {
          this.oldCaptainState = this.isCaptain;
          this.isCaptain = this.parent && this.id === this.parent.captainId;
          if (this.parent) {
            let e = new THREE.Vector3(0, 0, 0);
            e.z = -this.walkForward;
            e.x = this.walkSideward;
            if (e.lengthSq() > 0) {
              e.normalize();
            }
            e.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation);
            this.velocity = e;
            this.velocity.x *= 4;
            this.velocity.z *= 4;
            if (this.parent.netType === 5 || this.parent.shipState === 3 || this.parent.shipState === 4 || this.parent.shipState === -1) {
              this.velocity.x *= 2;
              this.velocity.z *= 2;
            }
            if (this.parent.netType !== 5 && this.parent.shipState !== 3 && this.parent.shipState !== 2 && this.parent.shipState !== -1 && this.parent.shipState !== 4) {
              if (this.position.x > this.parent.size.x / 2) {
                this.position.x = this.parent.size.x / 2;
                if (this.isPlayer) {
                  Ud.playAudioFile(false, false, 1, "turning");
                }
              }
              if (this.position.z > this.parent.size.z / 2) {
                this.position.z = this.parent.size.z / 2;
                if (this.isPlayer) {
                  Ud.playAudioFile(false, false, 1, "turning");
                }
              }
              if (this.position.x < -this.parent.size.x / 2) {
                this.position.x = -this.parent.size.x / 2;
                if (this.isPlayer) {
                  Ud.playAudioFile(false, false, 1, "turning");
                }
              }
              if (this.position.z < -this.parent.size.z / 2) {
                this.position.z = -this.parent.size.z / 2;
                if (this.isPlayer) {
                  Ud.playAudioFile(false, false, 1, "turning");
                }
              }
              if (this.parent.arcFront > 0 && this.position.z > 0) {
                let e = this.parent.size.x / 2 - this.position.z * this.parent.arcFront;
                if (this.position.x > 0) {
                  if (this.position.x > e) {
                    this.position.x = e;
                  }
                } else if (this.position.x < -e) {
                  this.position.x = -e;
                }
              }
              if (this.parent.arcBack > 0 && this.position.z < 0) {
                let e = this.parent.size.x / 2 + this.position.z * this.parent.arcBack;
                if (this.position.x > 0) {
                  if (this.position.x > e) {
                    this.position.x = e;
                  }
                } else if (this.position.x < -e) {
                  this.position.x = -e;
                }
              }
            }
          }
          if (this.cooldown > 0) {
            this.cooldown -= e;
          }
          if (this.use === true && this.cooldown <= 0) {
            let e = parseFloat((this.attackSpeedBonus + this.pointsFormula.getFireRate()) / 100);
            this.cooldown = this.activeWeapon === 1 ? 0.7 : (1.5 - e).toFixed(2);
            if (this.activeWeapon === 0 && this.isPlayer && this.parent && this.parent.shipState !== 3 && this.parent.shipState !== 4) {
              Ud.playAudioFile(false, true, 1, "cannon");
            } else if (this.isPlayer && this.activeWeapon === 1) {
              Ud.playAudioFile(false, true, 1, "cast-rod");
            }
          }
          if (!this.isPlayer) {
            this.geometry.rotation.x = this.pitch + this.rotationOffset;
          }
        }
        clientlogic(e) {
          if (this.isPlayer && !Nh(this.notifiscationHeap)) {
            this.notifiscation();
          }
          if (this.reaction) {
            this.reaction.position.set(0, Math.cos(this.geometry.rotation.x) * 4, -Math.sin(this.geometry.rotation.x) * 4);
          }
          this.namesLogic();
          if (this.isPlayer) {
            this.walkForward = 0;
            this.walkSideward = 0;
            if (ah) {
              this.walkForward = 1;
            } else if (rh) {
              this.walkForward = -1;
            }
            if (nh) {
              this.walkSideward = 1;
            } else if (ih) {
              this.walkSideward = -1;
            }
            this.jumping = sh ? 1 : 0;
            if (this.state === 1 && !$("#game-over-modal").is(":visible")) {
              $("#game-over-modal").modal("show");
            }
            let e = 1;
            if (this.state === 2) {
              ec.position.set(0, 1, 5);
              ec.rotation.z = 0;
              ec.rotation.y = 0;
              ec.rotation.x = -0.4;
              this.geometry.add(ec);
              this.state = 0;
            }
            if (ec.parent === this.geometry) {
              let t;
              let i = new THREE.Vector3();
              if (this.activeWeapon !== 2) {
                if ($("#fp-mode-button").is(":checked")) {
                  t = 2 - Math.max(nc.cameraX, 2);
                  i = new THREE.Vector3(ec.position.x, 1.5 + Math.min(8, Math.max(0, nc.cameraX * 0.5)), 1.21 + t * 0.21);
                  if (this.captainHat != null) {
                    this.captainHat.visible = false;
                  }
                } else {
                  t = 0.2 - Math.max(nc.cameraX, 0.2);
                  i = new THREE.Vector3(ec.position.x, (Hc >= 1 && Hc <= 10 ? Hc * 2 : 2) + Math.min(Hc >= 1 && Hc <= 10 ? Hc * 8 : 8, Math.max(0, nc.cameraX * 10)), (Hc >= 1 && Hc <= 10 ? Hc * 8 : 8) + t * (Hc >= 1 && Hc <= 10 ? Hc * 8 : 8));
                  if (this.captainHat != null) {
                    this.captainHat.visible = true;
                  }
                }
                if (ec.zoom !== 1) {
                  ec.zoom = 1;
                  ec.updateProjectionMatrix();
                  mc.fog.density = 0.007;
                }
                this.crosshair.visible = true;
              } else if (this.activeWeapon === 2) {
                t = 2 - Math.max(nc.cameraX, 2);
                i = new THREE.Vector3(ec.position.x, 2, -0.01);
                mc.fog.density = 0.0055;
                ec.zoom = nc.zoom + 1.5;
                ec.updateProjectionMatrix();
                this.crosshair.visible = false;
              }
              this.geometry.rotation.x = Dh(this.geometry.rotation.x, Math.min(e, Math.max(-1, nc.cameraX + this.rotationOffset)), 0.8);
              this.rotation = nc.cameraY;
              ec.position.lerp(i, 1);
              ec.rotation.x = Dh(ec.rotation.x, t, 1);
              this.pitch = nc.cameraX;
              this.crosshair.position.x = ec.position.x;
              this.crosshair.position.y = ec.position.y + 0.01;
              this.crosshair.position.z = ec.position.z - 0.4;
            }
            if (nc.isMouseLookLocked) {
              this.use = nc.lmb;
            } else {
              this.use = false;
            }
          }
          if (this.jumping === 1) {
            this.tryJump();
          }
          this.jumpVel = this.jumpVel - e * 80;
          this.jump += this.jumpVel * e;
          if (this.jump < 0) {
            this.jump = 0;
          }
          if (this.isPlayer && this.parent) {
            if (this.parent.shipState === 0 || this.parent.shipState === 1) {
              if (this.walkForward !== 0) {
                Ud.playAudioFile(false, false, 1, "step-wood01");
              }
              if (this.walkSideward !== 0) {
                Ud.playAudioFile(false, false, 1, "step-wood02");
              }
            } else {
              if (this.walkForward !== 0) {
                Ud.playAudioFile(false, false, 1, "step-sand01");
              }
              if (this.walkSideward !== 0) {
                Ud.playAudioFile(false, false, 1, "step-sand02");
              }
            }
          }
          if (this.isPlayer && this.parent && (this.parent.shipState === 3 || this.parent.shipState === 2 || this.parent.shipState === -1 || this.parent.shipState === 4 || this.parent.netType === 5)) {
            ld();
            if (!bd.hideSuggestionBox && hc && hc.gold > 500 && !$("#shopping-modal").is(":visible") && $("#earn-gold").is(":visible")) {
              $("#earn-gold").hide();
            }
            let e = wc[this.parent.anchorIslandId || this.parent.id];
            let t = new THREE.Vector3(0, 0, 0);
            if (this.parent.netType === 5) {
              let i = this.geometry.position.clone();
              t.y = i.y;
              let n = i.distanceTo(t);
              if (e.dockRadius - 2 < n) {
                i.lerp(t, 1 - (e.dockRadius - 2) / n);
                this.position.x = i.x;
                this.position.z = i.z;
              }
            } else if (this.parent.netType === 1) {
              let i = wc[this.parent.id];
              let n = this.geometry.getWorldPosition(new THREE.Vector3()).clone();
              n = e.geometry.worldToLocal(n);
              t.y = n.y;
              let a = n.distanceTo(t);
              if (e.dockRadius - 2 < a) {
                n.lerp(t, 1 - (e.dockRadius - 2.5) / a);
                n = e.geometry.localToWorld(n);
                n = i.geometry.worldToLocal(n);
                this.position.x = n.x;
                this.position.z = n.z;
              }
            }
          }
          this.dockedLogic();
          this.geometry.position.set(this.position.x, this.position.y + this.jump, this.position.z);
          this.geometry.rotation.y = this.rotation;
          if (this.weapon !== undefined) {
            if (this.activeWeapon === 1) {
              this.weapon.rotation.x += e * this.rodRotationSpeed;
              if (this.weapon.rotation.x > 0.75) {
                this.weapon.rotation.x = 0;
              }
            } else {
              this.weapon.rotation.x = 0.1 - this.rotationOffset;
            }
          }
          if (this.isCaptain !== this.oldCaptainState) {
            if (this.parent && this.isPlayer && !this.isCaptain) {
              nd.showCenterMessage("You are not the captain anymore!", 4, 4000);
              if (this.parent.shipState === 3 || this.parent.shipState === 4 || this.parent.shipState === -1) {
                $("#toggle-shop-modal-button").removeClass("disabled").addClass("enabled");
                $("#toggle-krew-list-modal-button").removeClass("disabled").addClass("enabled");
                $("#exit-island-button").hide();
                $("#toggle-invite-link-button").show();
                $("#quests-button").show();
              } else {
                $("#toggle-shop-modal-button").removeClass("enabled").addClass("disabled");
                $("#toggle-krew-list-modal-button").removeClass("enabled").addClass("disabled");
              }
              if (this.parent.shipState === 1) {
                $("#docking-modal").hide();
              }
              $("#abandon-ship-button").show();
            }
            if (this.parent && this.isPlayer && this.isCaptain) {
              nd.showCenterMessage("You are the captain now!", 4, 4000);
              if (this.parent.shipState === 3 || this.parent.shipState === 4 || this.parent.shipState === -1) {
                $("#toggle-shop-modal-button").removeClass("disabled").addClass("enabled");
                $("#toggle-krew-list-modal-button").removeClass("disabled").addClass("enabled");
                $("#exit-island-button").show();
                $("#toggle-invite-link-button").show();
                $("#quests-button").show();
              } else {
                $("#toggle-shop-modal-button").removeClass("enabled").addClass("disabled");
                $("#toggle-krew-list-modal-button").removeClass("enabled").addClass("disabled");
              }
              if (this.parent.shipState === 1) {
                $("#docking-modal").show();
              }
              $("#abandon-ship-button").hide();
            }
            if (this.isCaptain) {
              this.playerBody.add(this.captainHat);
            } else {
              this.playerBody.remove(this.playerBody.getObjectByName("captainHat"));
            }
          }
        }
        namesLogic() {
          if (this.isPlayer) {
            let e = 5;
            if (this.timeCounters.namesLogic === undefined) {
              this.timeCounters.namesLogic = {
                time: performance.now(),
                previousTime: performance.now()
              };
            } else {
              this.timeCounters.namesLogic.time = performance.now();
            }
            if (this.timeCounters.namesLogic.time - this.timeCounters.namesLogic.previousTime > 1000 / e) {
              this.timeCounters.namesLogic.previousTime = this.timeCounters.namesLogic.time;
              requestAnimationFrame(() => {
                let e = ec.getWorldPosition(new THREE.Vector3());
                for (let t in wc) {
                  if (wc[t].netType === 0 || wc[t].netType === 1 || wc[t].netType === 5) {
                    let i = $h(e, wc[t].geometry.getWorldPosition(new THREE.Vector3()));
                    let n = this.activeWeapon === 2 ? ec.far : Jl.Labels.distanceMultiplier[wc[t].netType];
                    wc[t].inRange = i <= n;
                    if (Jl.setProperties.inVision) {
                      wc[t].inVision = wc[t].inRange && Oh(wc[t], ec);
                    }
                    if (wc[t].netType === 0) {
                      wc[t].setName(wc[t].name);
                    }
                    if (wc[t].netType === 1) {
                      wc[t].setName(wc[t].crewName);
                    }
                    if (wc[t].netType > 1) {
                      wc[t].setName(wc[t].name);
                    }
                  }
                }
              });
            }
          }
        }
        dockedLogic() {
          if (this.isPlayer) {
            let e = 20;
            if (this.timeCounters.dockedLogic === undefined) {
              this.timeCounters.dockedLogic = {
                time: performance.now(),
                previousTime: performance.now()
              };
            } else {
              this.timeCounters.dockedLogic.time = performance.now();
            }
            if (this.timeCounters.dockedLogic.time - this.timeCounters.dockedLogic.previousTime > 1000 / e) {
              let e;
              let t;
              this.timeCounters.dockedLogic.previousTime = this.timeCounters.dockedLogic.time;
              let i;
              let n = 100;
              let a = [];
              let r = {
                object: undefined,
                height: n
              };
              let s = 0;
              if (this.parent && wc) {
                t = new THREE.Vector3(0, -1, 0);
                e = this.geometry.getWorldPosition(new THREE.Vector3()).clone();
                e.set(e.x, n, e.z);
                let o = new THREE.Raycaster();
                o.set(e, t);
                if (this.parent && wc[this.parent.id] !== undefined) {
                  if (this.parent.shipState !== 3 && this.parent.shipState !== 4 || !wc[this.parent.anchorIslandId]) {
                    a.push(wc[this.parent.id].geometry.getObjectByName("body"));
                  } else {
                    a.push(wc[this.parent.anchorIslandId].geometry.children[0].children[0]);
                    wc[this.parent.id].geometry.children.forEach(e => {
                      if (e.name === "body") {
                        a.push(e);
                      }
                    });
                  }
                }
                i = o.intersectObjects(a);
                if (i.length > 0) {
                  r = {
                    height: i[0].distance,
                    object: i[0].object
                  };
                  s = n - r.height;
                }
                if (r.object && r.object.name === "body") {
                  s -= wc[this.parent.id].getHeightAboveWater();
                  let e = this.position.x < 0;
                  let t = Zl[wc[this.parent.id].shipclassId].width / 2;
                  if (this.position.x !== 0) {
                    if (this.isCaptain) {
                      s += Math.abs(wc[this.parent.id].leanvalue / 2);
                    } else if (e) {
                      s -= wc[this.parent.id].leanvalue / 2 * (Math.abs(this.position.x) / t);
                    } else {
                      s += wc[this.parent.id].leanvalue / 2 * (Math.abs(this.position.x) / t);
                    }
                  }
                }
                if (r.object && r.object.name !== "body" && wc[this.parent.id] !== undefined && wc[this.parent.id].netType === 1) {
                  s -= wc[this.parent.id].getHeightAboveWater();
                }
                this.position.y = s;
              }
            }
          }
        }
        parseTypeSnap(e) {
          e.f;
          e.s;
          if (e.u !== undefined) {
            this.use = Ih(e.u);
          }
          if (e.p !== undefined) {
            this.pitch = parseFloat(e.p);
          }
          if (e.j !== undefined) {
            this.jumping = parseInt(e.j);
          }
          if (e.m !== undefined) {
            this.movementSpeedBonus = parseInt(e.m);
          }
          if (e.v !== undefined && e.v !== this.availablePoints) {
            this.availablePoints = parseInt(e.v);
          }
          if (e.c !== undefined && e.c !== this.checkedItemsList) {
            this.checkedItemsList = Ih(e.c);
          }
          if (e.d !== undefined && parseInt(e.d) !== this.itemId) {
            this.itemId = parseInt(e.d);
            if (bd !== undefined) {
              fd();
            }
          }
          if (e.w !== undefined && e.w !== this.activeWeapon) {
            this.activeWeapon = parseInt(e.w);
            this.changeWeapon();
          }
        }
        onDestroy() {
          Td.prototype.onDestroy.call(this);
          if (this === hc) {
            hc = undefined;
          }
          if (this.parent) {
            delete this.parent.children[this.id];
            if (this.parent.netType === 1) {
              this.parent.updateProps();
              if (Object.keys(this.parent.children).length === 0) {
                Ed(this.parent);
              }
            }
          }
          if (Ac[this.id]) {
            delete Ac[this.id];
          }
        }
      }
      Rd.prototype.rotationOffset = -0.45;
      Rd.prototype.timeCounters = {};
      class Pd extends Td {
        constructor() {
          super();
          this.netType = 2;
          this.size = wh.sizeProjectile;
          this.muted = ["x", "z"];
          this.sendDelta = false;
          this.sendSnap = false;
          this.sendCreationSnapOnDelta = true;
          this.spawnPacket = false;
          this.type = -1;
          this.reel = false;
          this.shooterid = "";
          this.impact = undefined;
          this.setProjectileModel = true;
          this.particletimer = 0;
          this.shooterStartPos = new THREE.Vector3();
          this.startPoint = new THREE.Vector3();
          this.endPoint = new THREE.Vector3();
        }
        getTypeDelta() {
          this.spawnPacket ||= true;
        }
        logic(e) {
          if (this.shooterid === "" || wc[this.shooterid] === undefined || wc[this.shooterid] !== undefined && this.type !== -1 && this.type !== wc[this.shooterid].activeWeapon) {
            if (this.impact) {
              this.impact.destroy = true;
            }
            Ed(this);
            return;
          }
          if (wc[this.shooterid] !== undefined && wc[this.shooterid].use === false) {
            wc[this.shooterid].isFishing = false;
          }
          if (this.position.y >= 0) {
            this.velocity.y -= e * 25;
            this.position.y += this.velocity.y * e;
          }
          if (wc[this.shooterid] !== undefined && wc[this.shooterid].parent !== undefined) {
            let e = wc[this.shooterid].worldPos();
            if (wc[this.shooterid].parent !== undefined && wc[this.shooterid].parent.netType === 5) {
              if (e.z.toFixed(2) !== this.shooterStartPos.z.toFixed(2) && e.x.toFixed(2) !== this.shooterStartPos.x.toFixed(2)) {
                this.reel = true;
                wc[this.shooterid].isFishing = false;
              }
            } else if (e.distanceTo(this.shooterStartPos) >= 40) {
              this.reel = true;
              wc[this.shooterid].isFishing = false;
            }
          }
          if (this.position.y < 10) {
            let e = false;
            if (this.position.y < 0 || e) {
              if (this.reel || this.shooterid === "" || wc[this.shooterid] === undefined || wc[this.shooterid].use === true || wc[this.shooterid].activeWeapon === 0 || this.position.x > Jl.worldsize || this.position.z > Jl.worldsize || this.position.x < 0 || this.position.z < 0) {
                if (this.impact) {
                  this.impact.destroy = true;
                }
                Ed(this);
              } else {
                this.velocity.x = 0;
                this.velocity.z = 0;
                if (hc && this.shooterid === hc.id) {
                  Ud.playAudioFile(false, false, 1, "fishing");
                }
                wc[this.shooterid].isFishing = true;
              }
            }
          }
        }
        clientlogic(e) {
          let t = wc[this.shooterid];
          let i = new THREE.Box3();
          if (t === undefined || t && t.parent && t.parent.hp <= 0) {
            mc.remove(this.geometry);
            if (this.line !== undefined) {
              mc.remove(this.line);
              this.line.geometry.dispose();
            }
          }
          if (t && this.setProjectileModel === true) {
            mc.remove(this.geometry);
            if (t.activeWeapon === 0) {
              this.geometry = new THREE.Sprite(yh.cannonball);
            } else if (t.activeWeapon === 1) {
              this.baseGeometry = bh.plane;
              this.baseMaterial = yh.hook;
              let e = bh.line.clone();
              e.vertices.push(this.startPoint);
              e.vertices.push(this.endPoint);
              this.line = new THREE.Line(e, new THREE.MeshBasicMaterial({
                color: 0
              }));
              Rc[this.id] = this.line;
              this.line.frustumCulled = false;
              if (wc[this.shooterid].weapon) {
                i.setFromObject(wc[this.shooterid].weapon);
                this.startPoint.set(i.max.x - 0.5, i.max.y, i.max.z - 0.5);
              }
              mc.add(this.line);
              this.geometry = new THREE.Mesh(this.baseGeometry, this.baseMaterial);
              this.geometry.rotation.x = Math.PI;
            }
            Lc[this.id] = this.geometry;
            this.geometry.renderOrder = 16;
            mc.add(this.geometry);
            this.setProjectileModel = false;
          }
          this.geometry.position.set(this.position.x, this.position.y, this.position.z);
          if (this.line) {
            if (t && t.weapon) {
              i.setFromObject(wc[this.shooterid].weapon);
              this.startPoint.set(i.max.x - 0.5, i.max.y, i.max.z - 0.5);
            }
            this.endPoint.set(this.position.x, this.position.y + 0.8, this.position.z);
            this.line.geometry.verticesNeedUpdate = true;
            this.geometry.rotation.y += e * 1.5;
          } else if (t && t.activeWeapon === 0 && (this.particletimer -= e, this.particletimer < 0)) {
            let e = hc && this.shooterid === hc.id;
            let t = hc && hc.parent && hc.parent.children[this.shooterid];
            this.particletimer = 0.04;
            Id({
              vx: 0,
              vy: 0,
              vz: 0,
              x: this.position.x,
              z: this.position.z,
              y: this.position.y,
              w: e ? 0.7 : 0.4,
              h: e ? 0.7 : 0.4,
              d: e ? 0.7 : 0.4,
              gravity: 0,
              duration: 2,
              rotaSpeed: Math.random() * 5,
              sizeSpeed: -1.8,
              material: e ? yh.smoke_player : t ? yh.smoke_friendly : yh.smoke_enemy,
              geometry: bh.box
            });
          }
        }
        parseTypeSnap(e) {
          if (e.vx !== undefined) {
            this.velocity.x = parseFloat(e.vx);
          }
          if (e.vy !== undefined) {
            this.velocity.y = parseFloat(e.vy);
          }
          if (e.vz !== undefined) {
            this.velocity.z = parseFloat(e.vz);
          }
          if (e.x !== undefined) {
            this.position.x = parseFloat(e.x);
          }
          if (e.z !== undefined) {
            this.position.z = parseFloat(e.z);
          }
          if (e.y !== undefined) {
            this.position.y = parseFloat(e.y);
          }
          if (e.i !== undefined && e.i !== this.shooterid) {
            this.shooterid = e.i;
          }
          if (e.r !== undefined && e.r !== this.reel) {
            this.reel = Ih(e.r);
          }
          if (e.sx !== undefined) {
            this.shooterStartPos.x = parseFloat(e.sx);
          }
          if (e.sz !== undefined) {
            this.shooterStartPos.z = parseFloat(e.sz);
          }
        }
      }
      let Dd = {
        promises: [],
        loadModel: e => {
          Dd.promises.push(new Promise((t, i) => {
            dh.load(e, i => {
              let n = new THREE.Object3D();
              n.children = i.children;
              Tc[e.substring(e.lastIndexOf("/") + 1, e.length).replace(/\.[^/.]+$/, "")] = n;
              t();
            });
          }));
          return Dd.promises[Dd.promises.length - 1];
        },
        loadTexture: e => {
          Dd.promises.push(new Promise((t, i) => {
            let n = e.split("/").pop().split(".");
            let a = n.pop();
            let r = n.pop();
            if (a !== "tga") {
              if (a === "mtl") {
                let i = e.split("/");
                i.pop();
                i = `${i.join("/")}/`;
                uh.setPath(i);
                uh.load(`${r}.${a}`, e => {
                  e.preload();
                  dh.setMaterials(e);
                  t();
                });
                return;
              }
              hh.load(e, i => {
                Pc[e.substring(e.lastIndexOf("/") + 1, e.length).replace(/\.[^/.]+$/, "")] = i;
                t();
              }, e => {});
            } else {
              ph.load(e, e => {
                Pc[r] = e;
                t();
              });
            }
          }));
        },
        loadObjWithMtl: e => {
          let t = new THREE.OBJLoader();
          let i = new THREE.MTLLoader();
          let n = e.split("/");
          let a = n.pop().split(".");
          a.pop();
          let r = a.pop();
          n = `${n.join("/")}/`;
          Dd.promises.push(new Promise((a, s) => {
            i.setPath(n);
            i.load(`${r}.mtl`, i => {
              i.preload();
              t.setMaterials(i);
              t.load(e, t => {
                let i = new THREE.Object3D();
                i.children = t.children;
                Tc[e.substring(e.lastIndexOf("/") + 1, e.length).replace(/\.[^/.]+$/, "")] = i;
                a();
              });
            });
          }));
          return Dd.promises[Dd.promises.length - 1];
        },
        onFinish: e => {
          Promise.all(Dd.promises).then(t => {
            if (e) {
              e();
            }
          });
        }
      };
      let Id = function (e) {
        if (!!hc && !!hc.parent && !(Math.pow(e.x - hc.parent.position.x, 2) + Math.pow(e.z - hc.parent.position.z, 2) > 10000)) {
          Nc.push(new $d(e));
        }
      };
      class $d {
        constructor(e) {
          this.vx = e.vx;
          this.vy = e.vy;
          this.vz = e.vz;
          this.gravity = e.gravity;
          this.rotaSpeed = e.rotaSpeed;
          this.duration = e.duration;
          this.timeleft = this.duration;
          this.sizeSpeed = e.sizeSpeed;
          this.globalscale = 1;
          this.w = e.w;
          this.h = e.h;
          this.d = e.d;
          this.x = e.x;
          this.y = e.y;
          this.z = e.z;
          this.geometry = new THREE.Mesh(e.geometry, e.material);
          this.geometry.position.set(e.x, e.y, e.z);
          this.geometry.scale.set(e.w, e.h, e.d);
          this.geometry.renderOrder = 24;
          this.deleteMe = false;
          mc.add(this.geometry);
        }
        tick(e) {
          this.vy -= this.gravity * e;
          this.geometry.position.set(this.geometry.position.x + this.vx * e, this.geometry.position.y + this.vy * e, this.geometry.position.z + this.vz * e);
          this.geometry.rotation.set(this.geometry.rotation.x + this.rotaSpeed * e, this.geometry.rotation.y + this.rotaSpeed * e, this.geometry.rotation.z + this.rotaSpeed * e);
          this.globalscale += this.sizeSpeed * e;
          this.geometry.scale.set(this.w * this.globalscale, this.h * this.globalscale, this.d * this.globalscale);
          this.timeleft -= e;
          if (this.timeleft <= 0 || this.globalscale <= 0) {
            mc.remove(this.geometry);
            this.deleteMe = true;
          }
        }
      }
      let zd = () => {
        Mc.boundaryLeft = new THREE.Mesh(bh.box, yh.boundary);
        Mc.boundaryLeft.position.set(Jl.worldsize * 0.5, 1.5, 0);
        Mc.boundaryLeft.scale.set(Jl.worldsize, 0.1, 3);
        mc.add(Mc.boundaryLeft);
        Mc.boundaryRight = new THREE.Mesh(bh.box, yh.boundary);
        Mc.boundaryRight.position.set(Jl.worldsize * 0.5, 1.5, Jl.worldsize);
        Mc.boundaryRight.scale.set(Jl.worldsize, 0.1, 3);
        mc.add(Mc.boundaryRight);
        Mc.boundaryUp = new THREE.Mesh(bh.box, yh.boundary);
        Mc.boundaryUp.position.set(0, 1.5, Jl.worldsize * 0.5);
        Mc.boundaryUp.scale.set(3, 0.1, Jl.worldsize);
        mc.add(Mc.boundaryUp);
        Mc.boundaryDown = new THREE.Mesh(bh.box, yh.boundary);
        Mc.boundaryDown.position.set(Jl.worldsize, 1.5, Jl.worldsize * 0.5);
        Mc.boundaryDown.scale.set(3, 0.1, Jl.worldsize);
        mc.add(Mc.boundaryDown);
      };
      let Nd = e => {
        if (!bc || bc && window.currentTime === e) {
          return;
        }
        let t = {
          r: 0,
          g: 197,
          b: 255
        };
        let i = {
          r: 0,
          g: 36,
          b: 112
        };
        let n = {
          r: 125,
          g: 232,
          b: 255
        };
        let a = {
          r: 21,
          g: 35,
          b: 69
        };
        let r = {
          r: 0,
          g: 102,
          b: 128
        };
        let s = {
          r: 0,
          g: 51,
          b: 77
        };
        window.currentTime = e;
        if (e === 1) {
          let e = 0;
          let o = setInterval(() => {
            e++;
            cc.intensity -= 0.02;
            tc.material.color.set(Rh(t, i, e / 100));
            oc.material.color.set(Rh(t, i, e / 100));
            mc.fog.color.set(Rh(n, a, e / 100));
            mc.background = new THREE.Color(Rh(n, a, e / 100));
            bc.material.uniforms.waterColor.value = new THREE.Color(Rh(r, s, e / 100));
            if (e === 100) {
              clearInterval(o);
            }
          }, 20);
        } else if (e === 0) {
          let e = 0;
          let o = setInterval(() => {
            e++;
            cc.intensity += 0.02;
            tc.material.color.set(Rh(i, t, e / 100));
            oc.material.color.set(Rh(i, t, e / 100));
            mc.fog.color.set(Rh(a, n, e / 100));
            mc.background = new THREE.Color(Rh(a, n, e / 100));
            bc.material.uniforms.waterColor.value = new THREE.Color(Rh(s, r, e / 100));
            if (e === 100) {
              clearInterval(o);
            }
          }, 20);
        }
      };
      let Od = () => {
        Sc.seadog = Tc.seadog.children[0].geometry;
        Sc.seafox = Tc.seafox.children[0].geometry;
        Tc.babyFancy.children[0].name = "body";
        Tc.babyFancy.children[1].name = "mast";
        Tc.babyFancy.children[2].name = "sail";
        Tc.silentDragon.children[2].name = "sail";
        Tc.silentDragon.children[0].name = "body";
        Tc.silentDragon.children[1].name = "mast";
        Tc.blackOyster.children[0].name = "body";
        Tc.blackOyster.children[1].name = "mast";
        Tc.blackOyster.children[2].name = "sail";
        Tc.boat.children[0].name = "body";
        Tc.boat.children[1].name = "mast";
        Tc.boat.children[2].name = "sail";
        Tc.boat2.children[0].name = "body";
        Tc.boat2.children[1].name = "mast";
        Tc.boat2.children[2].name = "sail";
        Tc.boat3.children[0].name = "body";
        Tc.boat3.children[1].name = "mast";
        Tc.boat3.children[2].name = "sail";
        Tc.echelle.children[0].name = "body";
        Tc.echelle.children[1].name = "mast";
        Tc.echelle.children[2].name = "sail";
        Tc.calmSpirit.children[0].name = "body";
        Tc.calmSpirit.children[1].name = "mast";
        Tc.calmSpirit.children[2].name = "sail";
        Tc.battalion.children[0].name = "body";
        Tc.battalion.children[1].name = "mast";
        Tc.battalion.children[2].name = "sail";
        Tc.destroyer.children[0].name = "body";
        Tc.destroyer.children[1].name = "mast";
        Tc.destroyer.children[2].name = "sail";
        Tc.destroyer2.children[0].name = "body";
        Tc.destroyer2.children[1].name = "mast";
        Tc.destroyer2.children[2].name = "sail";
        Tc.fortuneTrader.children[0].name = "body";
        Tc.fortuneTrader.children[1].name = "mast";
        Tc.fortuneTrader.children[2].name = "sail";
        Tc.junkie.children[0].name = "body";
        Tc.junkie.children[1].name = "sail";
        Tc.junkie.children[2].name = "mast";
        Tc.queenBarbsJustice.children[0].name = "body";
        Tc.queenBarbsJustice.children[1].name = "mast";
        Tc.queenBarbsJustice.children[2].name = "sail";
        Tc.raft.children[1].name = "body";
        Tc.raft.children[2].name = "mast";
        Tc.raft.children[0].name = "sail";
        Tc.raider.children[0].name = "body";
        Tc.raider.children[1].name = "mast";
        Tc.raider.children[2].name = "sail";
        Tc.royalFortune.children[0].name = "body";
        Tc.royalFortune.children[1].name = "mast";
        Tc.royalFortune.children[2].name = "sail";
        Tc.trader.children[0].name = "body";
        Tc.trader.children[1].name = "mast";
        Tc.trader.children[2].name = "sail";
        Tc.trader2.children[0].name = "body";
        Tc.trader2.children[1].name = "mast";
        Tc.trader2.children[2].name = "sail";
        Tc.trader3.children[0].name = "body";
        Tc.trader3.children[1].name = "mast";
        Tc.trader3.children[2].name = "sail";
        Tc.nightWind.children[0].name = "body";
        Tc.nightWind.children[1].name = "mast";
        Tc.nightWind.children[2].name = "sail";
        Tc.flyingDutchman.children[0].name = "body";
        Tc.flyingDutchman.children[1].name = "mast";
        Tc.flyingDutchman.children[2].name = "sail";
        Tc.pinta.children[0].name = "body";
        Tc.pinta.children[1].name = "mast";
        Tc.pinta.children[2].name = "sail";
        Tc.queenAnnesRevenge.children[0].name = "body";
        Tc.queenAnnesRevenge.children[1].name = "mast";
        Tc.queenAnnesRevenge.children[2].name = "sail";
        Tc.taiping.children[0].name = "body";
        Tc.taiping.children[1].name = "mast";
        Tc.taiping.children[2].name = "sail";
        (() => {
          for (let e in Zl) {
            let t = Zl[e];
            if (Tc[t.body] !== undefined) {
              t.body = Tc[t.body].getObjectByName("body");
            }
            if (t.sail !== undefined && Tc[t.sail] !== undefined) {
              t.sail = Tc[t.sail].getObjectByName("sail");
            }
            if (t.mast !== undefined && Tc[t.mast] !== undefined) {
              t.mast = Tc[t.mast].getObjectByName("mast");
            }
          }
        })();
        (() => {
          for (const [e, t, i] of Uc) {
            let e;
            yh[i] = new THREE.MeshPhongMaterial({
              color: 16777215,
              map: Pc[i]
            });
            e = t === "floppyEars" ? Sc.seafox : Sc.seadog;
            const n = new THREE.Mesh(e, yh[i]);
            Ic.push({
              body: n,
              rotation: new THREE.Vector3(0.4, 0, 0)
            });
          }
        })();
        zc.push(Tc.pirateHat);
        zc.push(Tc.sailorHat);
        zc.push(Tc.shipMasterHat);
        zc.push(Tc.pirateHat2);
      };
      let Ud = {
        musicPlaying: undefined,
        fadingIn: [],
        fadingOut: [],
        inBattle: false,
        updateMusicVolume: () => {
          let e = document.querySelectorAll("audio");
          const t = document.getElementById("music-control");
          for (let i = 0; i < e.length; i++) {
            e[i].volume = t.value * 0.1 / t.max;
          }
        },
        turnOffMusic: () => {
          let e = document.querySelectorAll("audio");
          for (let t = 0; t < e.length; t++) {
            e[t].volume = 0;
          }
        },
        playAudioFile: (e, t, i, n) => {
          const a = document.getElementById("music-control");
          const r = document.getElementById("sfx-control");
          document.getElementById(n).loop = e;
          if (t) {
            let t = document.getElementById(n).cloneNode(true);
            t.volume = lh ? 0 : e ? i * 0.1 * a.value / a.max : i * 0.35 * r.value / r.max;
            t.play();
          } else {
            document.getElementById(n).volume = lh ? 0 : e ? i * 0.1 * a.value / a.max : i * 0.45 * r.value / r.max;
            document.getElementById(n).play();
          }
        },
        stopAudioFile: e => {
          document.getElementById(e).volume = 0;
          document.getElementById(e).pause();
        },
        fadeAudio: (e, t, i, n, a) => new Promise(r => {
          const s = document.getElementById("music-control");
          const o = document.getElementById("sfx-control");
          Ud.playAudioFile(n, false, 0, t);
          let l = 0;
          let c = document.getElementById(e).volume;
          let h = setInterval(() => {
            l += 50;
            document.getElementById(t).volume = lh ? 0 : Math.min(i, n ? i * (l / a) * 0.1 * s.value / s.max : i * (l / a) * 0.35 * o.value / o.max);
            document.getElementById(e).volume = lh ? 0 : Math.max(0, c * ((a - l) / a));
            if (l >= a) {
              Ud.stopAudioFile(e);
              document.getElementById(t).volume = lh ? 0 : n ? i * 0.1 * s.value / s.max : i * 0.35 * o.value / o.max;
              r();
              clearInterval(h);
            }
          }, 50);
        }),
        changeMusic: async (e, t) => {
          if (t) {
            Ud.inBattle = false;
          }
          if (!Ud.inBattle) {
            let t;
            let n;
            switch (e) {
              case "battle":
                var i = vh(1, 4);
                Ud.inBattle = true;
                switch (i) {
                  case 1:
                    n = "battle-music";
                    t = 3;
                    break;
                  case 2:
                    n = "battle-music-2";
                    t = 3;
                    break;
                  case 3:
                  case 4:
                    n = "battle-music-3";
                    t = 3;
                }
                break;
              case "ocean":
                i = vh(1, 4);
                Ud.inBattle = true;
                switch (i) {
                  case 1:
                    n = "ocean-music";
                    t = 1;
                    break;
                  case 2:
                    n = "ocean-music-2";
                    t = 3;
                    break;
                  case 3:
                  case 4:
                    n = "ocean-music-3";
                    t = 3;
                }
                break;
              case "island":
                if (Math.random() >= 0.5) {
                  n = "island-music";
                  t = 1;
                } else {
                  n = "island-music-2";
                  t = 4;
                }
                break;
              default:
                return;
            }
            Ud.fadingIn.push(n);
            Ud.fadingOut.push(Ud.musicPlaying);
            await Ud.fadeQueued(n, Ud.musicPlaying);
            await Ud.fadeAudio(Ud.musicPlaying, n, t, true, Ud.inBattle ? 2000 : 4000);
            Ud.fadingIn.shift();
            Ud.fadingOut.shift();
            Ud.musicPlaying = n;
          }
        },
        fadeQueued: (e, t) => new Promise(i => {
          let n = setInterval(() => {
            if (Ud.fadingIn[0] === e && Ud.fadingOut[0] === t) {
              i();
              clearInterval(n);
            }
          }, 100);
        })
      };
      let Fd = () => {
        let e = (() => {
          let e = CanvasMap(document.getElementById("minimap"), Jl.worldsize, Jl.worldsize);
          e.useRadians = true;
          e.zoom = 0.9;
          let t = {
            x: e.text({
              x: Gc,
              y: Gc,
              text: "+",
              fill: "rgba(84,48,13,0.7)",
              size: 260,
              baseline: "middle"
            }),
            n: e.text({
              x: Gc,
              y: Gc - 400,
              text: "N",
              fill: "rgba(84,48,13,0.7)",
              size: 200,
              baseline: "middle"
            }),
            s: e.text({
              x: Gc,
              y: Gc + 400,
              text: "S",
              fill: "rgba(84,48,13,0.7)",
              size: 200,
              baseline: "middle"
            }),
            w: e.text({
              x: Gc - 400,
              y: Gc,
              text: "W",
              fill: "rgba(84,48,13,0.7)",
              size: 200,
              baseline: "middle"
            }),
            e: e.text({
              x: Gc + 400,
              y: Gc,
              text: "E",
              fill: "rgba(84,48,13,0.7)",
              size: 200,
              baseline: "middle"
            }),
            boundary: e.rect({
              x: 0,
              y: 0,
              width: Jl.worldsize,
              height: Jl.worldsize,
              stroke: {
                color: "rgba(84,48,13,1)",
                width: 8
              }
            })
          };
          e.add(t.x).add(t.n).add(t.s).add(t.w).add(t.e).add(t.boundary);
          e.update = () => {
            if (performance.now() - mh > 1000 / 24) {
              if (wc === undefined) {
                e.elements = {};
              } else {
                for (let t in e.elements) {
                  if ((e.elements[t].netType === 5 || e.elements[t].netType === 0 || e.elements[t].netType === 4) && wc[t] === undefined) {
                    e.remove(e.elements[t]);
                  }
                }
                for (let t in wc) {
                  if (wc[t].netType === 5 && e.elements[t] === undefined) {
                    e.add(e.point({
                      x: wc[t].position.x,
                      y: wc[t].position.z,
                      r: wc[t].dockRadius,
                      fill: "green",
                      id: t,
                      netType: 5
                    })).add(e.text({
                      x: wc[t].position.x,
                      y: wc[t].position.z - 140,
                      text: wc[t].name,
                      fill: "rgba(84,48,13,1)",
                      font: "serif",
                      id: `${t}-label`,
                      size: 165
                    }));
                  }
                  if (wc[t].netType === 4 && wc[t].type === 4 && e.elements[t] === undefined) {
                    e.add(e.text({
                      x: wc[t].position.x,
                      y: wc[t].position.z,
                      text: "x",
                      fill: "rgba(204, 10, 10, 1)",
                      font: "sans-serif",
                      id: t,
                      size: 140,
                      netType: 4
                    }));
                  }
                }
                for (let t in Ec) {
                  if (e.elements[t] === undefined) {
                    e.add(e.point({
                      x: Ec[t].x,
                      y: Ec[t].y,
                      r: 30,
                      d: 0.5,
                      id: t,
                      creatTime: performance.now(),
                      fill: "rgba(255, 0, 0, 0.5)"
                    }));
                  }
                  if (e.elements[t] !== undefined) {
                    if (e.elements[t].creatTime < performance.now() - 10000) {
                      e.remove(e.elements[t]);
                      delete Ec[t];
                    } else {
                      e.elements[t].r = e.elements[t].r + Math.sin(e.elements[t].d) * 5;
                      e.elements[t].d += 0.2;
                    }
                  }
                }
              }
              if (hc && hc.geometry) {
                let t;
                let i = hc.geometry.getWorldPosition(new THREE.Vector3());
                let n = new THREE.Quaternion();
                if (hc.parent && hc.parent.netType === 1 && hc.parent.shipState === 0) {
                  hc.parent.geometry.getWorldQuaternion(n);
                  t = 180;
                } else {
                  hc.geometry.getWorldQuaternion(n);
                  t = 0;
                }
                let a = new THREE.Vector3(1, 0, 0).applyQuaternion(n);
                let r = Math.atan2(a.z, a.x) * 180 / Math.PI;
                r = r > 0 ? r : r + 360;
                let s = (r % 360 + t) * Math.PI / 180;
                if (e.elements[hc.id] === undefined) {
                  e.add(e.triangle({
                    x: hc.position.x,
                    y: hc.position.z,
                    size: 80,
                    rotation: s,
                    fill: "white",
                    stroke: {
                      color: "black",
                      width: 20
                    },
                    id: hc.id,
                    netType: 0
                  }));
                }
                if (e.elements[hc.id] !== undefined) {
                  e.elements[hc.id].x = i.x;
                  e.elements[hc.id].y = i.z;
                  e.elements[hc.id].rotation = s;
                }
              }
              if (hc?.clan != null && ch) {
                for (let t in wc) {
                  if (t != hc.id && t != hc?.parent?.id && wc[t]?.netType === 1 && wc[t]?.hp > 0 && hc?.parent?.hp > 0 && wc[t]?.shipState != -1 && (wc[wc[t]?.captainId]?.clan === hc?.clan || wc[wc[t]?.captainId]?.alliance === hc?.alliance && hc?.alliance != null && hc.alliance != "")) {
                    let i;
                    let n = wc[t].geometry.getWorldPosition(new THREE.Vector3());
                    let a = new THREE.Quaternion();
                    if (wc[t].netType === 1 && wc[t].shipState === 0) {
                      wc[t].geometry.getWorldQuaternion(a);
                      i = 180;
                    } else {
                      wc[t].geometry.getWorldQuaternion(a);
                      i = 0;
                    }
                    let r = new THREE.Vector3(1, 0, 0).applyQuaternion(a);
                    let s = Math.atan2(r.z, r.x) * 180 / Math.PI;
                    s = s > 0 ? s : s + 360;
                    let o = (s % 360 + i) * Math.PI / 180;
                    if (e.elements[t] === undefined) {
                      e.add(e.triangle({
                        x: wc[t].position.x,
                        y: wc[t].position.z,
                        size: 80,
                        rotation: o,
                        fill: "white",
                        stroke: {
                          color: wc[wc[t].captainId]?.clan === hc.clan ? "#eb941a" : "#d97422",
                          width: 20
                        },
                        id: t,
                        netType: 0
                      }));
                    }
                    if (e.elements[t] !== undefined) {
                      e.elements[t].x = n.x;
                      e.elements[t].y = n.z;
                      e.elements[t].rotation = o;
                    }
                  }
                }
              }
              e.draw();
              mh = performance.now();
            }
          };
          return e;
        })();
        pc = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance"
        });
        pc.shadowMap.enabled = true;
        pc.shadowMap.type = THREE.PCFShadowMap;
        pc.outputEncoding = THREE.LinearEncoding;
        pc.toneMapping = THREE.NoToneMapping;
        document.body.appendChild(pc.domElement);
        mc = new THREE.Scene();
        ec = new THREE.PerspectiveCamera(75, 1.8, 0.1, 300);
        ec.position.set(0, 10, 0);
        uc = new THREE.Raycaster();
        mc.background = new THREE.Color(8251647);
        mc.fog = new THREE.FogExp2(8251647, 0.009);
        if (mc?.fog?.density != 0.009) {
          location.href = "https://krew.io/admin";
        }
        vc = new THREE.AmbientLight(16765613, 0.7);
        mc.add(vc);
        ac = new THREE.AmbientLight(13952255, 0.3);
        mc.add(ac);
        cc = new THREE.DirectionalLight(16768939, 1);
        cc.position.set(0, 10, 20);
        mc.add(cc);
        tc = new THREE.Mesh(new THREE.PlaneBufferGeometry(Jl.worldsize * 1.5, Jl.worldsize * 1.5), yh.sky);
        tc.rotation.x = -Math.PI * 0.5;
        tc.position.set(Jl.worldsize * 0.5, 140, Jl.worldsize * 0.5);
        mc.add(tc);
        oc = new THREE.Mesh(new THREE.SphereGeometry(Jl.worldsize * 2), yh.sky);
        oc.position.set(Jl.worldsize * 0.5, 0, Jl.worldsize * 0.5);
        mc.add(oc);
        (() => {
          let e = new THREE.PlaneBufferGeometry(Jl.worldsize * 1.5, Jl.worldsize * 1.5);
          let t = THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            time: {
              value: 1
            },
            waterColor: {
              value: new THREE.Color(0, 0.4, 0.5)
            }
          }]);
          let i = new THREE.ShaderMaterial({
            lights: true,
            fog: true,
            uniforms: t,
            vertexShader: "\n    uniform float time;\n    varying vec2 vUv;\n    #include <common>\n    #include <fog_pars_vertex>\n    void main() {\n        vUv = uv;\n        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0);\n        gl_Position = projectionMatrix * mvPosition;\n        #include <fog_vertex>\n    }",
            fragmentShader: "\n    uniform float time;\n    uniform float fog;\n    uniform vec3 waterColor;\n    varying vec2 vUv;\n    #define fa length(fract(q*=m*=.6+.1*d++)-.5)\n    #include <common>\n    #include <fog_pars_fragment>\n    void main() {\n        float d = 0.;\n        vec3 q = vec3(vUv*140.0, time*.2);\n        mat3 m = mat3(-2,-1,2, 3,-2,1, -1,1,3);\n        vec3 col = vec3(pow(min(min(fa,fa),fa), 7.)*5.);\n        vec3 outgoingLight = vec3(clamp(col + vec3(waterColor.r, waterColor.g, waterColor.b), 0.0, 1.0));\n        gl_FragColor = vec4(outgoingLight, 1.0);\n        #include <fog_fragment>\n    }"
          });
          bc = new THREE.Mesh(e, i);
          bc.rotation.x = -Math.PI * 0.5;
          bc.position.set(Jl.worldsize * 0.5, 0, Jl.worldsize * 0.5);
          mc.add(bc);
        })();
        zd();
        Sh();
        let t = pc.domElement;
        lc = t.getContext("webgl2");
        lc ||= t.getContext("experimental-webgl");
        sc = lc.canvas.width;
        rc = lc.canvas.height;
        let i = performance.now();
        let n = () => {
          let t = performance.now();
          bc.material.uniforms.time.value += 1 / 60;
          let a = Math.min((t - i) / 1000, 0.1);
          i = t;
          (e => {
            for (let t in wc) {
              wc[t].tick(e);
            }
          })(a);
          (function (e) {
            let t = Nc.length;
            while (t--) {
              Nc[t].tick(e);
              if (Nc[t].deleteMe) {
                Nc.splice(t, 1);
              }
            }
          })(a);
          e.update();
          requestAnimationFrame(n);
          pc.clear();
          pc.render(mc, ec);
        };
        pc.getContext().canvas.addEventListener("webglcontextlost", e => {
          e.preventDefault();
          cancelAnimationFrame(n);
          nd.showCenterMessage("We have detected a white screen issue. You will need to RELOAD the page and re-join to keep playing.", 3, 120000);
          location.reload(true);
        }, false);
        n();
      };
      let Bd = () => {
        if (mc != null && mc !== [] && mc !== {} && mc !== "") {
          kh(mc, e => {
            if (e != null && e !== [] && e !== {} && e !== "") {
              if (e instanceof THREE.Mesh) {
                for (let t in Lc) {
                  if (Lc[t] === e) {
                    mc.remove(e);
                    delete Lc[t];
                  }
                }
              }
              if (e instanceof THREE.Line) {
                for (let t in Rc) {
                  if (Rc[t] === e) {
                    mc.remove(e);
                    Rc[t].geometry.dispose();
                    delete Rc[t];
                  }
                }
              }
            }
          });
        }
      };
      $(document).ready(() => {
        if (location.host.includes("www")) {
          location.href = location.href.replace("www.", "");
        }
        KeyboardEvent = () => {};
        setTimeout(() => {
          if (window.io != null) {
            location.href = "https://krew.io/admin";
          }
        }, 2500);
        (async () => {
          let e = document.createElement("div");
          e.innerHTML = "&nbsp;";
          e.className = "adsbox";
          document.body.appendChild(e);
          window.setTimeout(() => {
            if (e.offsetHeight === 0) {
              jc = true;
            }
            e.remove();
          }, 1000);
          if (await (async () => {
            let e = false;
            try {
              await fetch(new Request("https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"));
            } catch (t) {
              e = true;
            }
            return e;
          })()) {
            jc = true;
          }
        })();
        window.location.hostname;
        if (localStorage.getItem("permToken") == null) {
          localStorage.setItem("permToken", (e => {
            let t = "";
            while (t.length < 50) {
              t += Math.random().toString(36).substring(2);
            }
            return t.substring(0, 50);
          })());
        }
        console.log("\n\n\n\n           \n        \n           \n         \n    \n       \n\nKrew Client v2\n\n\n\n\n");
        (() => {
          let e = performance.now();
          Dd.loadModel("./assets/models/dogs/models/seadog.obj");
          Dd.loadModel("./assets/models/dogs/models/seafox.obj");
          for (const [e, t, i] of Uc) {
            Dd.loadTexture(`./assets/models/dogs/textures/${e}/${i}.png`);
          }
          Dd.loadObjWithMtl("./assets/models/hats/pirateHat.obj");
          Dd.loadObjWithMtl("./assets/models/hats/sailorHat.obj");
          Dd.loadObjWithMtl("./assets/models/hats/shipMasterHat.obj");
          Dd.loadObjWithMtl("./assets/models/hats/pirateHat2.obj");
          Dd.loadModel("./assets/models/islands/spain.obj");
          Dd.loadModel("./assets/models/islands/guinea.obj");
          Dd.loadModel("./assets/models/islands/jamaica.obj");
          Dd.loadModel("./assets/models/islands/labrador.obj");
          Dd.loadModel("./assets/models/islands/brazil.obj");
          Dd.loadModel("./assets/models/islands/cuba.obj");
          Dd.loadModel("./assets/models/islands/malaysia.obj");
          Dd.loadTexture("./assets/models/islands/island.png");
          Dd.loadObjWithMtl("./assets/models/pickups/shell.obj");
          Dd.loadObjWithMtl("./assets/models/pickups/crab.obj");
          Dd.loadObjWithMtl("./assets/models/pickups/starfish.obj");
          Dd.loadObjWithMtl("./assets/models/pickups/chest.obj");
          Dd.loadTexture("./assets/models/pickups/crate.png");
          Dd.loadObjWithMtl("./assets/models/pickups/fish.obj");
          Dd.loadObjWithMtl("./assets/models/pickups/goldenFish.obj");
          Dd.loadTexture("./assets/models/projectiles/cannonball.png");
          Dd.loadTexture("./assets/models/projectiles/hook.png");
          Dd.loadObjWithMtl("./assets/models/ships/raft/raft.obj");
          Dd.loadObjWithMtl("./assets/models/ships/boat/boat.obj");
          Dd.loadObjWithMtl("./assets/models/ships/boat2/boat2.obj");
          Dd.loadObjWithMtl("./assets/models/ships/boat3/boat3.obj");
          Dd.loadObjWithMtl("./assets/models/ships/trader/trader.obj");
          Dd.loadObjWithMtl("./assets/models/ships/trader2/trader2.obj");
          Dd.loadObjWithMtl("./assets/models/ships/trader3/trader3.obj");
          Dd.loadObjWithMtl("./assets/models/ships/destroyer/destroyer.obj");
          Dd.loadObjWithMtl("./assets/models/ships/destroyer2/destroyer2.obj");
          Dd.loadObjWithMtl("./assets/models/ships/babyFancy/babyFancy.obj");
          Dd.loadObjWithMtl("./assets/models/ships/silentDragon/silentDragon.obj");
          Dd.loadObjWithMtl("./assets/models/ships/royalFortune/royalFortune.obj");
          Dd.loadObjWithMtl("./assets/models/ships/echelle/echelle.obj");
          Dd.loadObjWithMtl("./assets/models/ships/calmSpirit/calmSpirit.obj");
          Dd.loadObjWithMtl("./assets/models/ships/battalion/battalion.obj");
          Dd.loadObjWithMtl("./assets/models/ships/junkie/junkie.obj");
          Dd.loadObjWithMtl("./assets/models/ships/raider/raider.obj");
          Dd.loadObjWithMtl("./assets/models/ships/queenBarbsJustice/queenBarbsJustice.obj");
          Dd.loadObjWithMtl("./assets/models/ships/blackOyster/blackOyster.obj");
          Dd.loadObjWithMtl("./assets/models/ships/fortuneTrader/fortuneTrader.obj");
          Dd.loadObjWithMtl("./assets/models/ships/nightWind/nightWind.obj");
          Dd.loadObjWithMtl("./assets/models/ships/flyingDutchman/flyingDutchman.obj");
          Dd.loadObjWithMtl("./assets/models/ships/pinta/pinta.obj");
          Dd.loadObjWithMtl("./assets/models/ships/queenAnnesRevenge/queenAnnesRevenge.obj");
          Dd.loadObjWithMtl("./assets/models/ships/taiping/taiping.obj");
          Dd.loadObjWithMtl("./assets/models/tools/cannon.obj");
          Dd.loadObjWithMtl("./assets/models/tools/fishingrod.obj");
          Dd.loadObjWithMtl("./assets/models/tools/spyglass.obj");
          Dd.loadTexture("./assets/models/misc/water.jpg");
          for (let e = 1; e <= 68; e++) {
            Dd.loadTexture(`./assets/img/reactions/_${e}.png`);
          }
          Dd.loadTexture("./assets/models/misc/wave.png");
          Dd.onFinish(() => {
            if (window?.CrazyGames?.SDK?.environment === "crazygames") {
              window.CrazyGames.SDK.game.loadingStop();
            }
            Od();
            yh.cannonball = new THREE.SpriteMaterial({
              map: Pc.cannonball,
              color: 16777215,
              fog: true
            });
            yh.island = new THREE.MeshLambertMaterial({
              map: Pc.island,
              side: THREE.DoubleSide
            });
            yh.hook = new THREE.MeshBasicMaterial({
              map: Pc.hook,
              side: THREE.DoubleSide,
              transparent: true
            });
            yh.crate = new THREE.MeshBasicMaterial({
              map: Pc.crate
            });
            Pc.water.wrapS = Pc.water.wrapT = THREE.RepeatWrapping;
            Pc.wave.repeat.set(500, 500);
            Pc.wave.wrapT = THREE.RepeatWrapping;
            Pc.wave.wrapS = THREE.RepeatWrapping;
            yh.wave = new THREE.MeshBasicMaterial({
              map: Pc.wave
            });
            Fd();
            Xc = true;
            console.log(`\nLoaded all models in ${Math.round((performance.now() - e) * 1000) / 1000}ms\n\n`);
            $("#play-btn").text("Play").attr("disabled", false);
          });
        })();
        bd.setListeners();
        $.get("/api/servers", (e, t) => {
          if (t === "success") {
            bd.servers = e;
            let t = false;
            $("#server-select").html("");
            let i;
            let n = 0;
            for (i in e) {
              let a = e[i];
              n++;
              let r = $("<option/>", {
                html: `Server ${n} (${a.playerCount}/${a.maxPlayerCount})`,
                value: i
              });
              $("#server-select").append(r);
              if (!t && a.playerCount < a.maxPlayerCount) {
                $("#server-select").val(i);
                t = true;
              }
            }
            let a = Lh();
            if (a.sid) {
              $("#server-select").val(a.sid);
            }
          }
        });
        $.get("/api/wall_of_fame", (e, t) => {
          if (t === "success") {
            let t = "";
            for (const i in e) {
              let n = e[i].highscore;
              const a = e[i].clan !== "" ? `[${e[i].clan}]` : "";
              if (n >= 1000 && n.toString().length <= 6) {
                n = n / 1000 + " K";
              } else if (n.toString().length >= 7) {
                n = Math.floor(n / 1000) / 1000 + " M";
              }
              t = i <= 2 ? `<tr class="wof-player-top-${parseInt(i) === 0 ? 1 : 2}"><td class="rank">${parseInt(i) + 1}</td><td>${e[i].username}</td><td>${a}</td><td>${n}</td></tr>` : i <= 24 ? `<tr><td class="rank">${parseInt(i) + 1}</td><td>${e[i].username}</td><td>${a}</td><td>${n}</td></tr>` : `<tr class="top50" style="display:none"><td class="rank">${parseInt(i) + 1}</td><td>${e[i].username}</td><td>${a}</td><td>${n}</td></tr>`;
              $("#wall-of-fame-table").append(t);
            }
          }
        });
        $.get("/api/wall_of_fame_clans", (e, t) => {
          if (t === "success") {
            let t = "";
            for (let i in e) {
              let n = e[i].highscore;
              if (n >= 1000 && n.toString().length <= 6) {
                n = n / 1000 + " K";
              } else if (n.toString().length >= 7) {
                n = Math.floor(n / 1000) / 1000 + " M";
              }
              t = i <= 2 ? `<tr class="wof-player-top-${parseInt(i) === 0 ? 1 : 2}"><td class="rank">${parseInt(i) + 1}</td><td>[${e[i].name}]</td><td>${e[i].owner}</td><td>${n}</td></tr>` : i <= 24 ? `<tr><td class="rank">${parseInt(i) + 1}</td><td>[${e[i].name}]</td><td>${e[i].owner}</td><td>${n}</td></tr>` : `<tr class="top50-clans" style="display:none"><td class="rank">${parseInt(i) + 1}</td><td>[${e[i].name}]</td><td>${e[i].owner}</td><td>${n}</td></tr>`;
              $("#wall-of-fame-table-clans").append(t);
            }
          }
        });
      });
      window.onerror = e => {};
      let Hd = function (e) {
        if (gc !== undefined) {
          return;
        }
        if (Lh().pid && bd.serverList[Lh().pid]) {
          e = Lh().pid;
        }
        let t = bd.servers[e];
        let i = window.location.hostname === "localhost" ? "http://localhost" : Jl.url;
        if (parseInt(t.port) !== 80) {
          i += `:${t.port}`;
        }
        gc = Xl(i, {
          parser: Yl,
          rejectUnauthorized: false,
          withCredentials: true,
          closeOnBeforeunload: false,
          reconnection: false,
          extraHeaders: {
            token: localStorage.getItem("permToken")
          }
        });
        gc.onEvent = function (e, ...t) {
          if (!gc.hasListeners(e)) {
            gc.on(e, ...t);
          }
        };
        Vd();
        nc = new Md();
        document.onkeydown = xd;
        document.onkeyup = wd;
        $("#game-ui").show();
        $("#splash-modal").modal("hide");
        console.log("\n\nSuccessfully connected!\nGood luck sailor! \n\n\n");
      };
      let Vd = () => {
        gc.onEvent("handshake", e => {
          Fc = e;
          nd.showCenterMessage("Successfully connected to the server!", 3, 15000);
          console.log("Jumped into handshake!");
          let t;
          let i = {
            id: Uh.password ?? undefined,
            type: Lh().bid,
            auth: location.hostname.startsWith("testserver") ? Lh()?.auth : "",
            hex: vd(),
            item: Uh.username ?? undefined,
            disconnected: false,
            version: Jl.version
          };
          gc.emit("buy", i);
          if (t !== undefined) {
            clearInterval(t);
            t = undefined;
          }
          t = setInterval(() => {
            if (!hc || gc?.connected != 1) {
              return;
            }
            let e = hc.getDelta();
            if (e) {
              gc.emit("u", e);
            }
          }, 200);
        });
        $(window).on("beforeunload", e => confirm() ? (gc && gc.disconnect(), console.log("Closed for 1"), true) : (e.preventDefault(), false));
        $(window).on("unload", () => {
          if (gc) {
            gc.disconnect();
          }
          console.log("Closed for 2");
        });
        let e = 0;
        let t = 0;
        let i = false;
        let n = () => {
          let e = Date.now();
          gc.timeout(5000).emit("ping", (t, i) => {
            if (t) {
              $("#ping-wrapper > span").text("LOST CONNECTION");
            } else {
              let t = Date.now() - e;
              $("#ping-wrapper > span").text(`${t} MS`);
            }
          });
        };
        setInterval(n, 10000);
        gc.onEvent("startGame", () => {
          _d("hide");
          nd.showCenterMessage("Use WASD to move. Press space to jump. Left click to shoot/fish. Use 1, 2, and 3 to switch tools. For more help click the help icon above. You do NOT need a sail, your ship has it, it's just hidden! Good luck, Sailor!", 4, 20000);
          n();
        });
        gc.onEvent("playerNames", e => {
          kc = e;
        });
        gc.onEvent("s", e => {
          e = JSON.parse(e);
          for (let t in e) {
            Mh(t, e[t]);
          }
        });
        gc.onEvent("error", e => {
          console.log(e);
        });
        gc.onEvent("disconnect", e => {
          nd.showCenterMessage("Your connection to the server has been closed. Trying to reconnect... If the game is open on multiple pages, close all others except this one.", 1, 60000);
          console.log(`Reason: ${e}`);
          if (e != "io server disconnect") {
            clearInterval(qc);
            qc = setInterval(() => {
              if (gc.connected) {
                return clearInterval(qc);
              }
              console.log("Trying to reconnect...");
              gc.open();
            }, 1000);
          }
        });
        gc.onEvent("end", td);
        gc.onEvent("scores", e => {
          (e => {
            let t = e.players;
            let i = e.boats;
            if (!hc || !hc.parent || !wc) {
              return;
            }
            if (wc) {
              hc = wc[Fc];
            }
            if (e.boats.length > 0) {
              for (let t in e.boats) {
                if (!hc.parent) {
                  return;
                }
                if (e.boats[t] && e.boats[t].id === hc.parent.id) {
                  hc.parent.overall_kills = e.boats[t].ok;
                  hc.parent.overall_cargo = e.boats[t].oc;
                  hc.parent.overall_scores = e.boats[t].oS;
                }
              }
            }
            i.forEach(e => {
              if (wc[e.id] !== undefined) {
                wc[e.id].setName(e.cN);
              }
            });
            let n = i.filter(e => {
              if (hc.parent) {
                return e.id === hc.parent.id;
              }
            }).pop();
            if (hc.parent && n) {
              bd.captainUiConfiguration.active = n.cI === hc.id;
              bd.updateCaptainUi();
              let e = n.cU;
              $(".ship-cargo").html(`${e} / ${Zl[hc.parent.shipclassId].cargoSize}`);
              $(".my-krew-name").text(hc.parent.crewName);
            } else {
              $(".ship-cargo").html(" / ");
              $(".my-krew-name").html("Join a krew or buy a ship").css("fontSize", 17);
            }
            t.sort((e, t) => t.g - e.g);
            let a;
            let r = t.slice(0, 15);
            let s = 0;
            let o = r.length;
            let l = `${t.length} players`;
            let c = $("<div id=\"player-leaderbord-data\"/>");
            if (hc) {
              for (; s < 15 && s < o; s++) {
                let e;
                let t;
                let i = r[s].sS;
                let n = r[s].d;
                let o = r[s].l;
                a = r[s].c !== undefined && r[s].c !== "" ? `[${r[s].c}]` : "";
                e = r[s].s >= 1050 && r[s].s.length <= 6 ? `${Math.floor((r[s].s - 50) / 1000)} K` : r[s].s - 50;
                t = r[s].g >= 1000 && r[s].g.toString().length <= 6 ? `${Math.floor(r[s].g / 1000)} K` : r[s].g.toString().length >= 7 ? Math.floor(r[s].g / 1000) / 1000 + " M" : r[s].g;
                let l = $(`<div style="max-width: 100%; grid-column: 1;"${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${s + 1}.</div><div style="grid-column: 2"><span class="playerName${r[s].id === hc.id ? " text-success\"" : "\""}" style="margin-left:2px;font-size: 13px"></span></div><div style="grid-column: 3"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${a}</span></div><div style="grid-column: 4"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${o}</span></div><div style="grid-column: 5"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${i}</span></div><div style="grid-column: 6"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${n}</span></div><div style="grid-column: 7"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${e}</span></div><div style="grid-column: 8; text-align: right"><span${r[s].id === hc.id ? " class=\"text-success\"" : ""}>${t}</span></div>`);
                l.find(".playerName").text(r[s].n);
                c.append(l);
              }
            }
            $("#playerScoreData").html(c);
            $("#player-count").html(l);
            e.boats.sort((e, t) => t.g - e.g);
            let h;
            let d = e.boats.slice(0, 10);
            let u = $("<div id=\"leaderboard-data-div\"/>");
            let p = 0;
            let m = d.length;
            if (hc.parent) {
              for (; p < 10 && p < m; p++) {
                h = `${e.boats.length} boats`;
                let t = d[p].ok;
                let i = d[p].oS;
                let n = d[p].oc;
                a = d[p].c !== undefined && d[p].c !== "" ? `[${d[p].c}]` : "";
                let r;
                let s = d[p].oql;
                r = d[p].g >= 1000 && d[p].g.toString().length <= 6 ? `${Math.floor(d[p].g / 1000)} K` : d[p].g.toString().length >= 7 ? Math.floor(d[p].g / 1000) / 1000 + " M" : d[p].g;
                let o = $(`<div${d[p].id === hc.parent.id ? " class=\"text-success grid-left\"" : " class=\"grid-left\""}>${a}</div><div style="max-width: 100%;"${d[p].id === hc.parent.id ? " class=\"text-success grid-middle\"" : " class=\"grid-middle\""}><span class='krewName' style='margin-left:2px;font-size: 13px'></span></div><div class="grid-middle"><img src="/assets/img/medals/medal_${n >= 5000000 ? "ruby" : n >= 500000 ? "gold" : n >= 75000 ? "silver" : "bronze"}.png"${n >= 12000 ? " style=\"height: 17px\"" : "style=\"height: 17px; display:none\""}><img src="/assets/img/medals/medal_${t >= 75 && i >= 100000 ? "ruby" : t >= 40 && i >= 30000 ? "gold" : t >= 25 && i >= 15000 ? "silver" : "bronze"}.png"${t >= 10 ? " style=\"height: 17px\"" : "style=\"height: 17px; display:none\""}><img src="/assets/img/medals/medal_${s === 4 ? "ruby" : s === 3 ? "gold" : s === 2 ? "silver" : "bronze"}.png"${s > 0 ? " style=\"height: 17px\"" : "style=\"height: 17px; display:none\""}></div><div${d[p].id === hc.parent.id ? " class=\"text-success grid-right\"" : " class=\"grid-right\""}>${r}</div>`);
                o.find(".krewName").text(d[p].cN);
                u.append(o);
              }
            }
            $("#leaderboard-data").html(u);
            $("#boat-count").html(h);
            let f = [];
            let g = 0;
            let _ = $("<div/>");
            for (let e in t) {
              if (wc[t[e].id] !== undefined) {
                wc[t[e].id].setName(t[e].n);
              }
              if (hc.parent && t[e].pI === hc.parent.id) {
                f.push({
                  key: e,
                  value: t[e]
                });
              }
            }
            f.sort((e, t) => e.value.s - t.value.s);
            for (let e in f) {
              let t = f[e].value;
              let i = t.n;
              let n = "<div class=\"player-list-item\">";
              n += `${i}${t.id === Fc ? " (ME)" : ""}`;
              n += "<span class=\"float-sm-right\">";
              if (t.id === Fc && hc.goods !== undefined) {
                for (let e in hc.goods) {
                  if (hc.goods[e] > 0) {
                    n += ` ${hc.goods[e]} ${e}`;
                  }
                }
                n += ` <i class="text-warning icofont icofont-cube"></i> ${t.cU}`;
              } else {
                n += ` <i class="text-warning icofont icofont-cube"></i> ${t.cU}`;
              }
              if (t.id !== Fc && hc.isCaptain === true) {
                n += `<span class="btn btn-danger btn-kick-player float-right" data-event="kick" data-name="${i}" data-id="${t.id}"><i data-event="kick" data-name="${i}" data-id="${t.id}" class="icofont icofont-delete"></i></span><span class="btn btn-warning btn-transfer-ship float-right" data-event="transfer" data-id="${t.id}"><i data-event="transfer" data-name="${i}" data-id="${t.id}" class="icofont icofont-ship-wheel"></i></span>`;
              }
              n += "</span>";
              n += "</div>";
              let a = $(n);
              a.prepend($("<span/>", {
                class: "icofont icofont-ship-wheel text-warning",
                text: " ",
                style: "opacity: " + (hc.parent.captainId === t.id ? 1 : 0)
              }));
              if (t.id === Fc) {
                a.addClass("text-success");
                bd.checkGoldDelta(t.g);
                hc.clan = t.c;
                hc.clanLeader = t.cL;
                hc.clanOwner = t.cO;
                hc.alliance = t.al;
                hc.allianceOwner = t.alO;
                if (hc.clanRequest !== t.cR) {
                  hc.clanRequest = t.cR;
                  sd.setClanData("force");
                } else {
                  hc.clanRequest = t.cR;
                }
                hc.gold = parseInt(t.g);
                if (hc.gold >= Vc) {
                  Vc *= 2;
                }
                hc.score = parseInt(t.s);
                hc.shipsSank = parseInt(t.sS);
                hc.overall_cargo = parseInt(t.oc);
              }
              _.append(a);
              g++;
            }
            if (hc.parent) {
              (e => {
                if (hc && hc.parent && hc.parent.netType === 1) {
                  $(".ship-hp").html(hc.parent.hp);
                  $(".ship-max-hp").html(hc.parent.maxHp ?? 0);
                  $("#ship-name").html(Zl[hc.parent.shipclassId].name);
                  $(".ship-speed").html(hc.parent.speed.toFixed(1));
                  let t = hc.parent.cargoSize ?? 0;
                  $("#cargo-size").html(t);
                  $(".ship-krew-count").html(e.krewCount);
                  $(".ship-max-capacity").html(hc.parent.maxKrewCapacity ?? 0);
                } else {
                  $(".ship-hp").html("");
                  $(".ship-max-hp").html("");
                  $("#ship-name").html("");
                  $("#cargo-size").html("");
                  $(".ship-krew-count").html("");
                  $(".ship-max-capacity").html("");
                  $(".ship-speed").html("/");
                }
              })({
                krewCount: g
              });
            }
            $("#krew-list").html(_);
          })(e = JSON.parse(e));
        });
        gc.onEvent("setBankData", e => {
          (e => {
            if (e.warn) {
              $("#bankContainer").hide();
              $("#nabankContainer").show();
            } else {
              $("#bankContainer").show();
              $("#nabankContainer").hide();
              $("#my-deposits").text(e.my);
              $("#make-deposit").attr({
                max: hc.gold
              });
              $("#take-deposit").attr({
                max: e.my
              });
            }
          })(e);
        });
        gc.onEvent("updateKrewsList", () => {
          ld();
        });
        gc.onEvent("cargoUpdated", () => {
          if ($("#buy-goods").hasClass("active")) {
            cd.getList();
          }
        });
        gc.onEvent("enterIsland", e => (e => {
          if (e.captainId === Fc && hc && hc.parent && hc.parent.shipState !== 2) {
            $("#docking-modal").show();
          }
          if ($("#toggle-shop-modal-button").hasClass("enabled")) {
            $("#docking-modal").hide();
          }
          if (hc) {
            Ud.changeMusic("island", false);
          }
        })(e));
        gc.onEvent("showIslandMenu", () => md());
        gc.onEvent("exitIsland", e => (e => {
          nc.lockMouseLook();
          if (e.captainId === Fc) {
            $("#docking-modal").hide();
            $("#departure-modal").hide();
          }
          bd.hideSuggestionBox = true;
          if (hc) {
            Ud.changeMusic("ocean", false);
          }
          $("#toggle-bank-modal-button").removeClass("btn btn-md enabled toggle-shop-modal-button").addClass("btn btn-md disabled toggle-shop-modal-button").attr("data-tooltip", "Bank is available at Labrador");
          $("#exit-island-button").hide();
          bd.closeAllPages();
          fd();
          $("#docking-modal-button").removeClass("btn btn-primary enabled btn-lg").addClass("btn btn-primary disabled btn-lg");
          $("#toggle-shop-modal-button").removeClass("btn btn-md enabled toggle-shop-modal-button").addClass("btn btn-md disabled toggle-shop-modal-button");
          $("#toggle-krew-list-modal-button").removeClass("btn btn-md enabled toggle-krew-list-modal-button").addClass("btn btn-md disabled toggle-krew-list-modal-button");
        })(e));
        gc.onEvent("showAdinplayCentered", () => ud());
        gc.onEvent("departureWarning", () => {
          if ($("#toggle-krew-list-modal-button").hasClass("enabled")) {
            $("#toggle-krew-list-modal-button").addClass("glowing");
            setTimeout(() => {
              $("#toggle-krew-list-modal-button").removeClass("glowing");
            }, 5000);
          }
        });
        gc.onEvent("showCenterMessage", (e, t, i, n) => {
          if (bd && nd.showCenterMessage) {
            nd.showCenterMessage(e, t || 3, i, n);
          }
          if (e.startsWith("Achievement trading")) {
            $("#shopping-modal").hide();
          }
        });
        gc.onEvent("bounty", e => {
          Dc = e;
        });
        gc.onEvent("showKillMessage", e => {
          if (bd && nd.showKillMessage) {
            nd.showKillMessage(e);
          }
        });
        gc.onEvent("showDamageMessage", (n, a) => {
          if (bd && nd.showDamageMessage) {
            if (a === 2) {
              Ud.playAudioFile(false, true, 1, "cannon-hit");
            }
            nd.showDamageMessage(n, a);
            e = Date.now();
            if (!i) {
              if (t >= 1 && Date.now() - e < 20000) {
                i = true;
                t = 0;
                Ud.changeMusic("battle", false);
              } else {
                t++;
              }
            }
          }
        });
        setInterval(() => {
          if (i && Date.now() - e > 20000) {
            i = false;
            if (hc && hc.parent && (hc.parent.shipState === 3 || hc.parent.shipState === 4)) {
              Ud.changeMusic("island", true);
            } else {
              Ud.changeMusic("ocean", true);
            }
          }
        }, 20000);
        gc.onEvent("levelUpdate", e => {
          if (wc[e.id] !== undefined && wc[e.id].netType === 0) {
            wc[e.id].level = e.level;
            if (e.id === Fc) {
              Ud.playAudioFile(false, true, 0.9, "level-up");
              hc.updateExperience();
              if (!Yc) {
                hc.notifiscationHeap[Math.random().toString(36).substring(6, 10)] = {
                  text: "Level Up!",
                  type: 2,
                  isNew: true
                };
              }
            }
          }
        });
        gc.onEvent("clanMarker", e => {
          let t = Math.random().toString(36).substring(6, 10);
          Ec[t] = e;
        });
        gc.onEvent("alliance", e => {
          if (e.id === "invited-to-alliance") {
            nd.showCenterMessage(`You were invited to the [${e.name}] alliance by ${e.owner}. Press "Y" on the keyboard to open a menu to accept the alliance request, or press "N" to decline it. `, 4, 30000);
            hc.allianceRequest = e.name;
            setTimeout(() => {
              hc.allianceRequest = undefined;
            }, 30000);
          }
        });
        gc.onEvent("chat message", e => {
          if (hc && hc.parent && (hc.parent.hasChild(e.playerId) || e.recipient === "global" || e.recipient === "local" || e.recipient === "clan" || e.recipient === "staff" || e.recipient === "alliance") && wc[e.playerId] !== undefined) {
            let t = "global-chat";
            let i = $("#chat-history");
            if (e.recipient === "global") {
              t = "global-chat";
            } else if (e.recipient === "local") {
              t = "local-chat";
            } else if (e.recipient === "staff") {
              t = "staff-chat";
            } else if (e.recipient === "clan") {
              t = "clan-chat";
            } else if (e.recipient === "alliance") {
              t = "alliance-chat";
            }
            if (fh.includes(e.playerName.toLowerCase())) {
              return;
            }
            let n = hc !== undefined && hc.parent !== undefined && hc.parent.netType === 1 && wc[e.playerId].parent !== undefined && wc[e.playerId].parent.netType === 1;
            const a = Jl.Devs.includes(e.playerName);
            const r = Jl.Admins.includes(e.playerName);
            const s = Jl.Mods.includes(e.playerName);
            const o = Jl.Helpers.includes(e.playerName);
            const l = e.playerId === Fc;
            const c = hc.clan !== "" && hc.clan !== undefined && hc.clan === wc[e.playerId].clan && !l;
            const h = hc.alliance !== "" && hc.alliance !== undefined && hc.alliance === wc[e.playerId].alliance && !l;
            const d = n && hc.parent.id === wc[e.playerId].parent.id && wc[hc.parent.id].captainId === e.playerId;
            const u = n && hc.parent.id === wc[e.playerId].parent.id;
            let p;
            p = e?.message.toLowerCase().includes(`@${hc.name.toLowerCase()}`) || hc?.clan != null && e?.message.toLowerCase().includes(`@${hc?.clan?.toLowerCase()}`) ? "ping-color" : a ? "dev-color" : r ? "admin-color" : s ? "mod-color" : o ? "helper-color" : l ? "myself-color" : c ? "clan-color" : h ? "alliance-color" : d ? "captain-color" : u ? "krewmate-color" : "white";
            e.message = e.message.replace(Jl.emojiRegex, e => Th[e] || e);
            let m = $("<div/>", {
              text: `${(e.playerClan ? `[${e.playerClan}] ` : "") + (a ? "[Dev] " : r ? "[Admin] " : s ? "[Mod] " : o ? "[Helper] " : "") + e.playerName}: ${e.message}`,
              class: `${t} text-${p}`
            });
            let f = ["staff-chat", "alliance-chat", "clan-chat", "local-chat", "global-chat"];
            for (let e = 0; e < f.length; e++) {
              let t = f[e];
              if ($(`.${t}`).length > 15) {
                $(`.${t}`).first().remove();
              }
            }
            if (e.recipient === "global" && !th) {
              $("#global-chat-alert").show();
              m.hide();
            }
            if (e.recipient === "local" && !eh) {
              $("#local-chat-alert").show();
              m.hide();
            }
            if (e.recipient === "clan" && !Qc) {
              $("#clan-chat-alert").show();
              m.hide();
            }
            if (e.recipient === "alliance" && !Zc) {
              $("#alliance-chat-alert").show();
              m.hide();
            }
            if (e.recipient === "staff" && !Jc) {
              $("#staff-chat-alert").show();
              m.hide();
            }
            let g = false;
            if ($(i).scrollTop() + $(i).innerHeight() >= $(i)[0].scrollHeight) {
              g = true;
            }
            i.append(m);
            if (g === true) {
              i.scrollTop(function () {
                return this.scrollHeight;
              });
            }
          }
        });
        gc.onEvent("clear", () => {
          $(".global-chat").remove();
        });
        gc.onEvent("clearPlayerMessages", e => {
          const t = document.querySelectorAll(".global-chat");
          for (const i of t) {
            if (i.innerHTML.includes(`${e}: `)) {
              i.remove();
            }
          }
        });
        gc.onEvent("cycle", e => {
          if (e === "day") {
            Nd(0);
          } else if (e === "night") {
            Nd(1);
          }
        });
        gc.onEvent("reaction", e => {
          let t = wc[e.playerId];
          if (t != null) {
            t.removeReaction();
            t.showReaction(e.reaction);
          }
        });
      };
    })();
  })();
